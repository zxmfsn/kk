<!DOCTYPE html>
<!-- saved from url=(0029)https://koko1112.netlify.app/ -->
<html lang="zh-CN" style="--main-font: &#39;Nunito&#39;, sans-serif;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>koko小手机</title>
<script src="./koko小手机_files/StreamSaver.min.js"></script>
    <meta name="apple-mobile-web-app-capable" content="yes">

<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<meta name="apple-mobile-web-app-title" content="koko">
    <link rel="stylesheet" href="./koko小手机_files/all.min.css">
    <link rel="manifest" href="https://koko1112.netlify.app/manifest.json">
<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">

<meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
    <style>
@import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap');

        :root {
            --theme-primary: #81c784;
            --theme-primary-hover: #66bb6a;
            --theme-secondary: #aed581;
            --sent-message-bg: #e6f5c9;
            --background-start: #f1f8e9;
            --background-end: #ffffff;
            --text-on-primary: #ffffff;
            --text-dark: #424242;
            --text-gray: #757575;
            --soft-red: #ff8a80;
            --border-color: #e8e8e8;
            --shadow-color: rgba(129, 199, 132, 0.12);
            --soft-radius: 16px;
            --card-background: rgba(255, 255, 255, 0.7);
        }
        
       /* --- 您新增的叙事模式美化样式 --- */
.narrative-speech {
    background-color: #e6f5c9; /* 清新的青苹果色背景 (来自您已有的 --sent-message-bg 变量) */
    padding: 2px 8px;
    border-radius: 8px;
    display: inline-block;
    margin: 1px 0;
}

.narrative-psychology {
    text-decoration: none; /* 去掉下划线 */
    background-color: #e6f5c9; /* 浅绿色背景 (复用已有变量 --sent-message-bg) */
    color: #66bb6a; /* 青苹果绿字体 (复用已有变量 --theme-primary-hover) */
    padding: 2px 6px; /* 增加一点内边距，让背景更好看 */
    border-radius: 6px; /* 增加圆角 */
    font-style: normal; /* 也可以加一点斜体来区分 */
}

.narrative-action {
    font-style: normal;
    color: #517655; /* 深一点的青苹果色 (来自您已有的 --theme-primary-hover 变量) */
} 
        
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    /* ↓↓↓ 就是修改这一行 ↓↓↓ */
    font-family: var(--main-font, 'Nunito', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif);
}
        
        body {
            background-image: linear-gradient(to bottom, var(--background-start), var(--background-end));
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        #app-container, #screen {
            width: 100%;
            height: 100%;
            background-color: transparent;
        }
        
        #screen {
            display: flex;
            flex-direction: column;
            position: relative;
            box-shadow: 0 5px 25px var(--shadow-color);
        }
        
        .chat-header {
    background-color: rgba(129, 199, 132, 0.75);
    backdrop-filter: blur(12px);
    color: var(--text-on-primary);
    padding: 8px 15px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    display: grid; /* <--- 核心改动1：使用网格布局 */
    grid-template-columns: 1fr auto 1fr; /* <--- 核心改动2：三列布局 */
    align-items: center;
    z-index: 10;
    flex-shrink: 0;
}
/* 新增：修复顶栏右侧按钮的对齐问题 */
.chat-header > div:last-child {
    text-align: right;
}
        .app-header, .world-book-header, .api-header, .moments-header, .discover-header, .contact-settings-header {
            background-color: rgba(220, 237, 200, 0.7);
            backdrop-filter: blur(12px);
            color: var(--text-dark);
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: none;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            z-index: 10;
            flex-shrink: 0;
            position: relative;
        }
        
        .chat-input-area {
            background-color: #f8f9fa;
            padding: 6px 8px;
            display: flex;
            align-items: center;
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
            position: relative;
        }
        
        #message-input {
            flex-grow: 1;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 20px;
            padding: 8px 15px;
            font-size: 15px;
            outline: none;
            resize: none;
            max-height: 100px;
            overflow-y: auto;
            align-self: flex-end;
            min-height: 34px;
        }

        .input-action-btn {
            border: none;
            border-radius: 50%;
            width: 34px;
            height: 34px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-left: 8px;
            cursor: pointer;
            font-size: 16px;
            flex-shrink: 0;
            transition: transform 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            align-self: flex-end;
        }
        .input-action-btn:hover {
            transform: scale(1.1);
        }

        #send-btn {
            background-color: var(--theme-primary);
            color: var(--text-on-primary);
            width: auto;
            padding: 0 18px;
            border-radius: 22px;
        }
        #send-btn .fa-paper-plane {
            font-size: 18px;
        }

        #request-reply-btn {
            background-color: var(--theme-secondary);
            color: var(--text-on-primary);
        }
        
        #chat-screen {
            background-image: url('https://i.postimg.cc/SQ3DH79X/MEITU-20250811-151831796.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            transform: translate3d(0, 0, 0); 
            -webkit-transform: translate3d(0, 0, 0);
            will-change: transform, background-image;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            background-attachment: fixed;
    
        }
        
        #main-screen { height: 100%; display: flex; flex-direction: column; }
        .app-title { font-size: 20px; font-weight: 700; }
        .contacts-container { flex-grow: 1; overflow-y: auto; padding: 10px 0; }
        .section-title { padding: 10px 15px; font-size: 14px; color: var(--text-gray); background-color: transparent; font-weight: 600; }
        .contact-item { display: flex; align-items: center; padding: 12px 15px; background-color: transparent; border-bottom: 1px solid var(--border-color); border-radius: var(--soft-radius); margin: 0 8px 4px; cursor: pointer; transition: background-color 0.2s; }
        .contact-item:hover { background-color: rgba(255, 255, 255, 0.7); }
        .contact-avatar { width: 50px; height: 50px; border-radius: 50%; background-color: #ddd; margin-right: 15px; display: flex; align-items: center; justify-content: center; font-size: 20px; color: var(--text-gray); overflow: hidden; flex-shrink: 0; }
        .contact-avatar img { width: 100%; height: 100%; object-fit: cover; }
        .contact-info { flex-grow: 1; min-width: 0; }
        .contact-name { font-weight: 600; margin-bottom: 3px; color: var(--text-dark); }
        .contact-last-message { font-size: 14px; color: var(--text-gray); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }
        .contact-time { font-size: 12px; color: #999; margin-top: 5px; }
        .unread-count { background-color: var(--theme-primary); color: var(--text-on-primary); font-size: 12px; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-left: 10px; }
        .bottom-nav { display: flex; background-color: rgba(255, 255, 255, 0.8); backdrop-filter: blur(10px); border-top: 1px solid var(--border-color); padding: 10px 0; flex-shrink: 0; }
        .nav-item { flex: 1; text-align: center; color: var(--text-gray); font-size: 14px; cursor: pointer; transition: color 0.2s, transform 0.2s; }
        .nav-item-content { position: relative; display: inline-block; }
        .nav-item.active { color: var(--theme-primary); transform: scale(1.1); }
        .nav-icon { font-size: 20px; margin-bottom: 5px; }
        .notification-dot { position: absolute; top: -2px; right: -8px; width: 8px; height: 8px; background-color: var(--soft-red); border-radius: 50%; border: 1px solid white; display: none; }
        .back-btn { font-size: 24px; cursor: pointer; margin-right: 15px; }
        .chat-info { flex-grow: 1; text-align: center; }
        .chat-name { font-weight: 700; font-size: 18px; }
        .chat-status { font-size: 13px; opacity: 0.8; }
        .chat-messages { flex-grow: 1; padding: 8px; overflow-y: auto; display: flex; flex-direction: column; }
        #load-more-messages { background-color: #e0e0e0; color: #555; border: none; padding: 8px 15px; border-radius: 15px; cursor: pointer; margin: 0 auto 15px; font-size: 13px; display: none; }
        #load-more-messages:hover { background-color: #d1d1d1; }
        /* ▼▼▼ 在你的 .message-wrapper 样式里，加上 animation 这一行 ▼▼▼ */
.message-wrapper { 
    display: flex; 
    max-width: 90%; 
    margin-bottom: 1px; 
    position: relative; 
    /* 就是加上下面这一行！ */
    animation: bubble-fade-in 0.35s ease-out; 
}
        .message-wrapper.received { align-self: flex-start; flex-direction: row; }
        .message-wrapper.sent { align-self: flex-end; flex-direction: row-reverse; }
        .message-avatar { width: 40px; height: 40px; border-radius: 6px; flex-shrink: 0; visibility: hidden; }
        .is-first-in-sequence .message-avatar { visibility: visible; margin-top: 10px; }
        .message-avatar img { width: 100%; height: 100%; border-radius: 6px; object-fit: cover; }
        .message-body { display: flex; flex-direction: column; margin: 0 10px; }
        .message-wrapper.sent .message-body { align-items: flex-end; }
        .message-wrapper.received .message-body { align-items: flex-start; }
        .message-author-name { font-size: 13px; color: #888; margin-bottom: 4px; display: none; }
        .is-first-in-sequence .message-author-name { display: block; margin-top: 10px;}
        .message { padding: 6px 10px; border-radius: 22px; position: relative; word-wrap: break-word; min-width: 50px; box-shadow: 0 2px 4px var(--shadow-color); font-size: 14px;}
        .message-timestamp { font-size: 11px; color: #aaa; margin-top: 4px; padding: 0 5px; }
        .message-wrapper.selected .message, .message-wrapper.selected .message.red-packet, .message-wrapper.selected .message.voice, .message-wrapper.selected .message.picture-description { background-color: #bde0fe !important; }
/* ▼▼▼ 用这个新的动画效果，替换掉你原来的 @keyframes fadeIn ▼▼▼ */
@keyframes bubble-fade-in {
    from {
        opacity: 0;
        transform: translateY(30px) scale(0.9); /* 从更低的位置(30px)开始，并且稍微缩小 */
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1); /* 恢复正常位置和大小 */
    }
}
        .message.received { background-color: white; border-top-left-radius: 4px; }
        .message.sent { background-color: var(--sent-message-bg); border-top-right-radius: 4px; }
        .message-image-container { padding: 5px; background-color: inherit; border-radius: inherit; }
        .message-image { max-width: 150px; max-height: 150px; border-radius: 12px; display: block; cursor: default; }
        .message-image-container.sent { border-top-right-radius: 4px; }
        .message-image-container.received { border-top-left-radius: 4px; }
        .message.image-message { padding: 0; background-color: transparent; box-shadow: none; }
/* ▼▼▼ 新的、统一风格的左侧按钮 ▼▼▼ */
        .emoji-btn, .attachment-btn {
            /* 1. 复制 .input-action-btn 的核心样式 */
            border: none;
            border-radius: 50%; /* 变成圆圈 */
            width: 34px;       /* 统一宽度 */
            height: 34px;      /* 统一高度 */
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            flex-shrink: 0;
            transition: transform 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            align-self: flex-end; /* 保持垂直对齐 */
            
            /* 2. 赋予它们新的样式 */
            font-size: 16px; /* 统一下图标大小 */
            background-color: #f0f2f5; /* 一个中性的灰色背景 */
            color: var(--text-gray); /* 灰色图标 */
        }
        
        /* 3. 单独调整间距 */
        .emoji-btn {
            margin-right: 8px; /* 表情按钮和附件按钮之间的间距 */
            /* 注意：我们不设置 margin-left，让它贴着左边 */
        }
        
        .attachment-btn {
            margin-right: 10px; /* 附件按钮和输入框之间的间距 */
        }
        
        /* 4. (可选) 悬浮效果 */
        .emoji-btn:hover, .attachment-btn:hover {
            transform: scale(1.1);
            background-color: #e0e0e0; /* 悬浮时变深一点 */
        }
        /* ▲▲▲ 替换结束 ▲▲▲ */
        #edit-mode-bar, #moments-edit-mode-bar, #diary-edit-mode-bar { display: none; padding: 10px 15px; background-color: #f0f0f0; border-top: 1px solid #ddd; justify-content: space-between; align-items: center; flex-shrink: 0; }
        .edit-action-btn { padding: 8px 16px; border-radius: 20px; border: none; font-size: 14px; cursor: pointer; }
        #delete-selected-btn, #delete-selected-moments-btn { background-color: var(--soft-red); color: white; }
        #cancel-edit-btn, #cancel-moments-edit-btn { background-color: #bdc3c7; color: #333; }
        #profile-screen, #char-profile-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: transparent; display: none; flex-direction: column; }
        
        .profile-header {
            background-image: linear-gradient(135deg, var(--sent-message-bg), #dcedc8);
            padding: 30px 20px 15px;
            text-align: center;
            color: var(--text-dark);
            position: relative;
            flex-shrink: 0;
        }
        .avatar-container {
            position: relative;
            margin: 0 auto 15px;
            width: 100px;
            height: 100px;
        }
        .profile-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid white;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        .change-avatar-btn {
            position: absolute;
            bottom: 0;
            right: 0;
            background-color: rgba(255, 255, 255, 0.7);
            color: var(--text-dark);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .profile-name { font-size: 22px; font-weight: 700; margin-bottom: 5px; }
        .profile-status { font-size: 16px; opacity: 0.9; }
        .profile-actions { display: flex; justify-content: center; gap: 20px; padding: 10px 0; background-color: white; border-bottom: 1px solid #eee; flex-shrink: 0; }
        .action-item { text-align: center; cursor: pointer; }
        .action-icon { width: 50px; height: 50px; border-radius: 50%; background-color: #f0f2f5; display: flex; align-items: center; justify-content: center; font-size: 24px; color: var(--theme-primary); margin: 0 auto 10px; transition: all 0.3s; }
        .action-icon:hover { background-color: #e0f2f1; transform: scale(1.05); }
        .action-label { font-size: 14px; color: var(--text-gray); }
        .profile-details { flex-grow: 1; overflow-y: auto; padding: 10px; background-color: #f0f2f5; }
        .detail-item { padding: 15px; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center; cursor: pointer; background-color: white; }
        .detail-item:last-child { border-bottom: none; }
        .discover-section .detail-item { border-radius: 0; margin-bottom: 0; }
        .discover-section .detail-item:first-child { border-top-left-radius: var(--soft-radius); border-top-right-radius: var(--soft-radius); }
        .discover-section .detail-item:last-child { border-bottom-left-radius: var(--soft-radius); border-bottom-right-radius: var(--soft-radius); border-bottom: none; }
        .detail-label { font-size: 16px; color: #333; font-weight: 600; }
        .detail-value { font-size: 16px; color: var(--text-gray); max-width: 60%; text-align: right; overflow: hidden; text-overflow: ellipsis; }
        .edit-btn { color: var(--theme-primary); font-size: 18px; cursor: pointer; padding: 5px; }
        #discover-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: transparent; display: none; flex-direction: column; }
        .discover-title { font-size: 20px; font-weight: 700; flex-grow: 1; text-align: center; margin-left: 0; }
        .discover-content { flex-grow: 1; overflow-y: auto; padding: 20px; }
        .discover-section { background-color: var(--card-background); border-radius: var(--soft-radius); box-shadow: 0 4px 12px var(--shadow-color); border: 1px solid white; margin-bottom: 20px;}
        .discover-item { padding: 15px; display: flex; align-items: center; border-bottom: 1px solid var(--border-color); cursor: pointer; transition: background-color 0.2s; background-color: transparent; }
        .discover-item:last-child { border-bottom: none; }
        .discover-item:hover { background-color: rgba(255,255,255,0.5); }
        .discover-icon { width: 40px; height: 40px; border-radius: 8px; background-color: #f0f2f5; display: flex; align-items: center; justify-content: center; font-size: 20px; color: var(--theme-primary); margin-right: 15px; }
        .discover-info { flex-grow: 1; }
        .discover-name { font-weight: 600; margin-bottom: 3px; }
        .discover-desc { font-size: 14px; color: var(--text-gray); }
        .discover-arrow { color: #999; font-size: 18px; }
/* ▼▼▼ 使用这个【包含 #investment-center-screen 的完整版】替换旧规则 ▼▼▼ */
#automation-modal, #automation-screen, #world-book-screen, #api-settings-screen, #contact-settings-screen, #moments-screen, #diary-screen, #emoticon-library-screen, .preset-management-screen, #post-detail-screen, #trending-topic-screen, #square-api-settings-screen, 
#snoop-api-settings-screen,
#memory-album-screen, #music-library-screen, #shopping-screen, #product-detail-screen, 
#schedule-screen, #events-screen,
#relationship-network-screen,
#sms-chat-screen,
#favorites-screen,
#investment-center-screen, /* <--- 修正：加上游戏中心 */
#stock-market-screen      /* <--- 修正：加上交易所 */
{
    position: absolute;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: transparent; /* 背景色由各自页面的内联样式或更具体的规则覆盖 */
    display: none; /* 默认隐藏 */
    flex-direction: column; /* 垂直布局 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */
        .world-book-content, .api-content, .contact-settings-content, .emoticon-library-content { flex-grow: 1; overflow-y: auto; padding: 20px; }
        .world-book-list { display: flex; flex-direction: column; gap: 15px; }
        .world-book-item { background-color: white; border-radius: var(--soft-radius); box-shadow: 0 4px 12px var(--shadow-color); border: 1px solid white; margin-bottom: 20px; padding: 15px; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease;}
        .world-book-item:hover { transform: translateY(-3px); box-shadow: 0 6px 12px var(--shadow-color); }
        .book-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #f0f0f0; }
        .book-name { font-weight: 600; font-size: 18px; }
        .book-content { color: var(--text-gray); line-height: 1.5; white-space: pre-wrap; word-break: break-all; }
        .api-title { font-size: 20px; font-weight: 600; margin-left: 15px; }
        .form-group { background-color: white; border-radius: var(--soft-radius); box-shadow: 0 4px 12px var(--shadow-color); border: 1px solid white; margin-bottom: 20px; padding: 15px;}
        .form-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-gray); }
        .form-input { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; }
        .form-input:focus { outline: none; border-color: var(--theme-primary); }
        .form-button { width: 100%; padding: 15px; background-color: var(--theme-primary); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 10px; }
        .form-group-inline { display: flex; align-items: center; gap: 10px; }
        .form-group-inline .form-input { flex-grow: 1; }
        #fetch-models-btn, #fetch-square-models-btn, #fetch-snoop-models-btn { padding: 10px 15px; background-color: var(--theme-primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; flex-shrink: 0; }
        #add-world-book-modal, #post-moment-modal, #user-persona-preset-modal, #thought-preset-modal, #add-emoticon-modal, #automation-modal, #send-red-packet-modal, #send-transfer-modal, #send-voice-modal, #send-picture-modal, #add-music-modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; justify-content: center; align-items: center; z-index: 100; }
.modal-content {
    background-color: white;
    width: 90%;
    max-width: 400px;
    border-radius: var(--soft-radius);
    /* overflow: hidden; */ /* <--- 1. 我们把这行的 overflow: hidden 注释掉 */
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    animation: modalIn 0.3s ease;

    /* ▼▼▼ 2. 加上这三行 ▼▼▼ */
    display: flex;
    flex-direction: column;
    max-height: 85vh; /* 关键：弹窗最大高度不超过屏幕的85% */
}
        @keyframes modalIn { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .modal-header { background-color: var(--theme-primary); color: white; padding: 15px; display: flex; justify-content: space-between; align-items: center; }
        .modal-title { font-size: 18px; font-weight: 600; }
        .close-btn { font-size: 24px; cursor: pointer; }
        .modal-body {
    padding: 20px;

    /* ▼▼▼ 3. 加上这两行 ▼▼▼ */
    overflow-y: auto; /* 关键：允许内容区垂直滚动 */
    flex-shrink: 1;   /* 允许内容区在需要时收缩 */
}
        .form-textarea { width: 100%; height: 150px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; resize: vertical; }
        .form-textarea:focus { outline: none; border-color: var(--theme-primary); }
        .form-button:hover { background-color: var(--theme-primary-hover); }
        #add-contact-modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; justify-content: center; align-items: center; z-index: 100; }
        .contact-form-group { margin-bottom: 20px; }
        .contact-form-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-gray); }
        .contact-form-input { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; }
        .contact-form-input:focus { outline: none; border-color: var(--theme-primary); }
        .contact-form-textarea { width: 100%; height: 100px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; resize: vertical; }
        .contact-form-textarea:focus { outline: none; border-color: var(--theme-primary); }
        .contact-form-select { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; background-color: white; }
        .contact-form-select:focus { outline: none; border-color: var(--theme-primary); }
        .mask-editor, .world-book-selector { background-color: white; border-radius: var(--soft-radius); box-shadow: 0 4px 12px var(--shadow-color); border: 1px solid white; margin-bottom: 20px; padding: 15px;}
        .mask-editor-title { font-size: 18px; font-weight: 600; margin-bottom: 15px; color: var(--theme-primary); }
        .mask-editor-group { margin-bottom: 15px; }
        .mask-editor-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-gray); }
        .mask-editor-textarea { width: 100%; height: 150px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; resize: vertical; }
        .mask-editor-textarea:focus { outline: none; border-color: var(--theme-primary); }
        .world-book-selector-title { font-size: 18px; font-weight: 600; margin-bottom: 15px; color: var(--theme-primary); }
        .world-book-selector .world-book-list { max-height: 200px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px; }
        #world-book-selector-list .world-book-item { padding: 10px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; }
        .world-book-checkbox { margin-right: 10px; }
        .world-book-name { font-weight: 500; }
        .save-settings-btn { width: 100%; padding: 15px; background-color: var(--theme-primary); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; }
        .user-mask-editor { background-color: white; border-radius: var(--soft-radius); box-shadow: 0 4px 12px var(--shadow-color); border: 1px solid white; margin-bottom: 20px; padding: 15px;}
        .user-mask-title { font-size: 18px; font-weight: 600; margin-bottom: 15px; color: var(--theme-primary); }
        .user-mask-textarea { width: 100%; height: 150px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; resize: vertical; }
        .user-mask-textarea:focus { outline: none; border-color: var(--theme-primary); }
        
        /* --- V7.0 新增: 一起听歌卡片样式 --- */
.message.music-share-card {
    background-color: #f3f4f6;
    color: #333;
    width: 260px;
    padding: 12px;
    display: flex;
    align-items: center;
    gap: 12px;
    cursor: default;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
.message.sent.music-share-card { background-color: var(--sent-message-bg); }
.music-card-cover {
    width: 60px;
    height: 60px;
    background-color: #555;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 28px;
    flex-shrink: 0;
    position: relative;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    animation: spin 8s linear infinite;
    animation-play-state: paused; /* 默认暂停 */
}
.music-card-cover.playing {
    animation-play-state: running; /* 播放时旋转 */
}
@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
.music-card-play-btn {
    position: absolute;
    color: rgba(255, 255, 255, 0.8);
    font-size: 20px;
    cursor: pointer;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}
.music-card-info {
    flex-grow: 1;
    min-width: 0;
}
.music-card-title {
    font-weight: 600;
    font-size: 15px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.music-card-artist {
    font-size: 13px;
    color: var(--text-gray);
    margin-top: 2px;
}
.music-card-progress-bar {
    width: 100%;
    height: 3px;
    background-color: #ddd;
    border-radius: 3px;
    margin-top: 8px;
    overflow: hidden;
}
.music-card-progress {
    width: 0%;
    height: 100%;
    background-color: var(--theme-primary);
}
.music-card-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: #999;
    margin-top: 5px;
}
.music-card-loop-btn {
    cursor: pointer;
    font-size: 14px;
}
/* --- V7.0 新增: 小窝相册新样式 --- */
.album-section {
    background-color: white;
    border-radius: 12px;
    padding: 15px 20px;
    margin-bottom: 20px;
    box-shadow: 0 4px 12px var(--shadow-color);
}
.album-section-title {
    font-size: 18px;
    font-weight: bold;
    color: var(--theme-primary);
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #f0f0f0;
}
.album-milestone-item, .album-stat-item {
    display: flex;
    align-items: center;
    padding: 10px 0;
    font-size: 16px;
}
.album-item-icon {
    width: 30px;
    text-align: center;
    margin-right: 15px;
    color: var(--text-gray);
}
.album-item-label { color: #333; }
.album-item-value {
    margin-left: auto;
    font-weight: 600;
    color: var(--text-dark);
}
.album-memory-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 10px;
}
.album-memory-item {
    background-color: #f9f9f9;
    border-radius: 8px;
    padding: 10px;
    font-size: 14px;
    line-height: 1.5;
    border: 1px solid #eee;
    cursor: pointer;
}
.album-memory-item .fas {
    margin-right: 5px;
    color: var(--theme-secondary);
}
        
        /* ---论坛/微博 样式--- */
        .moments-header .back-btn { font-size: 24px; cursor: pointer; position: relative; z-index: 1; }
        .moments-header .action-btn { font-size: 20px; }
        .header-actions { display: flex; gap: 20px; position: relative; z-index: 1; }
        .moments-content { flex-grow: 1; overflow-y: auto; background-color: #f0f2f5; }
        .mention {
    color: var(--theme-primary);
    font-weight: 600;
    cursor: pointer;
}
.mention:hover {
    text-decoration: underline;
}
/* --- 新代码：模仿Koko论坛(1)的主导航栏样式 --- */
.feed-tabs {
    display: flex;
    justify-content: space-around;
    padding: 10px 0;          /* 增加上下内边距 */
    background-color: #ffffff; /* 背景改为白色 */
    border-bottom: 1px solid #e0e0e0; /* 添加底部边框线 */
    flex-shrink: 0;
}

.feed-tab-btn {
    text-decoration: none;
    color: #888;              /* 默认文字颜色改为灰色 */
    font-size: 16px;
    font-weight: 500;         /* 字体粗细调整 */
    padding: 10px 15px;       /* 修改内边距，为胶囊形状做准备 */
    border-radius: 20px;      /* 添加圆角 */
    border: none;
    background: none;
    cursor: pointer;
    /* 为背景和颜色变化添加过渡效果 */
    transition: background-color 0.3s, color 0.3s;
}

/* 新增：为图标和文字之间添加一点间距 */
.feed-tab-btn .fas {
    margin-right: 5px;
}

.feed-tab-btn.active {
    color: #000;              /* 激活时文字改为黑色 */
    font-weight: bold;         /* 激活时文字加粗 */
    background-color: #e9ecef; /* 激活时背景改为淡灰色，形成胶囊效果 */
}

/* 关键：删除或确保没有 .feed-tab-btn.active::after 规则，去掉下划线 */
.feed-tab-btn.active::after {
    display: none;
}

.feed-sub-tabs {
    display: flex;
    /* 核心修复1：改为从左侧开始排列，这样滚动条才能正常从左开始 */
    justify-content: flex-start; 
    gap: 15px;
    padding: 8px 10px;
    background-color: #fafafa;
    flex-shrink: 0;
    border-bottom: 1px solid #eee;
    
    /* 核心修复2：允许 X 轴（横向）在内容溢出时自动显示滚动条 */
    overflow-x: auto;

    /* (可选) 隐藏滚动条本身，但保留滚动功能（在移动端更美观） */
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
}

/* (可选) 隐藏滚动条 - Webkit (Chrome, Safari) */
.feed-sub-tabs::-webkit-scrollbar {
    display: none;
}
/* --- 新代码：模仿Koko论坛(1)的黑白胶囊按钮风格 --- */
.feed-sub-tab-btn {
    padding: 8px 16px;      /* 稍微增大一点内边距，让按钮更大方 */
    font-size: 14px;
    font-weight: 500;
    color: #555;            /* 默认文字颜色改为深灰色 */
    border: 1px solid #ddd; /* 保留一个细边框 */
    background-color: #fff; /* 默认背景为白色 */
    border-radius: 20px;    /* 圆角更圆润 */
    cursor: pointer;
    transition: all 0.3s;
    white-space: nowrap;    /* 防止文字换行 */
}

.feed-sub-tab-btn.active {
    color: #fff;            /* 激活时文字为白色 */
    background-color: #000;  /* 激活时背景为黑色 */
    border-color: #000;      /* 激活时边框也为黑色 */
    font-weight: bold;       /* 激活时文字加粗 */
}

        .posts-list { padding: 10px; display: flex; flex-direction: column; gap: 10px; }
/* --- 新代码：模仿Koko论坛(1)的精致卡片和悬浮效果 --- */
.post-item {
    position: relative;
    display: flex;
    padding: 20px;          /* 增大内边距，让内容更舒展 */
    gap: 15px;              /* 稍微增大头像和内容的间距 */
    background-color: white;
    border-radius: 12px;    /* 调整圆角大小 */
    border: 1px solid #e0e0e0; /* 增加一个非常淡的边框，提升质感 */
    box-shadow: 0 2px 8px rgba(0,0,0,0.06); /* 调整一个更柔和的阴影 */
    cursor: pointer;
    /* 核心动效：为阴影和位移添加过渡效果 */
    transition: box-shadow 0.3s, transform 0.2s;
}

/* 核心动效：添加鼠标悬浮时的样式 */
.post-item:hover {
    transform: translateY(-3px); /* 向上移动3像素，产生上浮感 */
    box-shadow: 0 4px 12px rgba(0,0,0,0.1); /* 阴影变得更深更明显 */
}
        .post-delete-btn { position: absolute; top: 10px; right: 10px; width: 28px; height: 28px; background-color: rgba(255, 255, 255, 0.8); backdrop-filter: blur(5px); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: var(--text-gray); font-size: 14px; cursor: pointer; z-index: 2; transition: all 0.2s; }
        .post-delete-btn:hover { background-color: var(--soft-red); color: white; }

        .post-item-avatar img { width: 45px; height: 45px; border-radius: 50%; flex-shrink: 0; }
        .post-content-area { flex-grow: 1; display: flex; flex-direction: column; gap: 8px; min-width: 0; }
        .post-author-name { font-weight: 700; color: var(--text-dark); }
        .post-author-handle { font-size: 14px; color: var(--text-gray); margin-left: 8px; }
        .post-text { line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; font-size: 15px; }
        .post-meta { color: #999; font-size: 13px; }
        .post-actions { display: flex; justify-content: space-between; align-items: center; color: var(--text-gray); font-size: 14px; margin-top: 12px; padding-top: 8px; border-top: 1px solid #f0f0f0; }
        .post-action-btn { cursor: pointer; display: flex; align-items: center; gap: 6px; transition: color 0.2s; }
/* --- 新代码：将交互颜色改为更中性的深灰色或黑色 --- */
.post-action-btn {
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    color: #888; /* 将默认图标颜色改为灰色 */
    transition: color 0.2s;
}
.post-action-btn:hover, .post-action-btn.liked {
    color: #000; /* 悬浮和点赞后的颜色改为黑色 */
}
        .post-action-btn.liked .fa-heart { font-weight: 900; }
        .post-action-btn i { font-size: 16px; }

        .post-comments { background-color: #f7f9f9; border-radius: 10px; padding: 10px; font-size: 14px; display: flex; flex-direction: column; gap: 8px; margin-top: 5px; }
        .post-comments:empty { display: none; }
        
        .comment-delete-btn { color: var(--text-gray); font-size: 12px; cursor: pointer; opacity: 0; transition: all 0.2s; }
        .comment-delete-btn:hover { color: var(--soft-red); }
        .post-comment-item:hover .comment-delete-btn { opacity: 1; }

        .post-comment-item { line-height: 1.5; padding: 8px 0; border-bottom: 1px solid #eee; }
        .post-comment-item:last-child { border-bottom: none; }
        .comment-author { font-weight: 600; color: var(--theme-primary); margin-right: 5px; cursor: pointer; }
        .comment-content { color: var(--text-dark); }
        .comment-meta { display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: var(--text-gray); margin-top: 4px; }
        .comment-reply-to { background-color: #e9e9e9; padding: 4px 8px; border-radius: 8px; font-size: 13px; margin-left: 5px; }
        /* --- 新增：用于在帖子中显示作者签名 --- */
.post-author-signature {
    font-size: 13px;
    color: var(--text-gray);
    margin-top: 4px; /* 与昵称拉开一点距离 */
    padding-bottom: 8px; /* 与帖子正文拉开一点距离 */
    white-space: pre-wrap; /* 允许签名中的换行 */
    word-break: break-word;
}


        /* 热搜榜样式 */
        .trending-list { list-style: none; padding: 10px; background-color: white;}
        .trending-item { display: flex; align-items: center; padding: 15px; border-bottom: 1px solid #f0f0f0; cursor: pointer; }
        .trending-item:hover { background-color: #f9f9f9; }
        .trending-item:last-child { border-bottom: none; }
        .trending-rank { font-size: 18px; font-weight: bold; color: var(--text-gray); width: 40px; text-align: center; }
        .trending-rank.top-3 { color: var(--soft-red); }
        .trending-info { flex-grow: 1; }
        .trending-title { font-size: 16px; font-weight: 600; color: var(--text-dark); margin-bottom: 4px; }
        .trending-meta { font-size: 13px; color: var(--text-gray); }
        .trending-tag { background-color: #ffcdd2; color: #c62828; font-size: 11px; padding: 2px 6px; border-radius: 5px; margin-left: 8px; font-weight: bold; }
        
        #post-detail-screen { background-color: #f0f2f5; }
        .post-detail-content { flex-grow: 1; overflow-y: auto; }
        #post-detail-container { padding: 0; }
        #post-detail-container .post-item { cursor: default; }
        .comments-section { padding: 15px; background-color: #f0f2f5; }
        .comments-title { font-size: 16px; font-weight: 700; color: var(--text-dark); padding-bottom: 10px; border-bottom: 1px solid #ddd; margin-bottom: 10px; }
        .comment-input-area { display: flex; padding: 10px 15px; background-color: white; border-top: 1px solid #ddd; flex-shrink: 0; }
        #comment-input { flex-grow: 1; border: 1px solid #ddd; border-radius: 18px; padding: 8px 15px; font-size: 15px; resize: none; }
        #submit-comment-btn { background-color: var(--theme-primary); color: white; border: none; border-radius: 18px; padding: 8px 20px; margin-left: 10px; font-weight: 600; cursor: pointer; }
        
        .diary-entry {
            position: relative;
            background-color: white;
            border-radius: 12px;
            padding: 15px 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px var(--shadow-color);
        }
        
        .diary-content { flex-grow: 1; overflow-y: auto; padding: 20px; }
        .diary-entry-meta { font-size: 12px; color: #999; margin-bottom: 10px; }
        .diary-entry-content { font-size: 16px; line-height: 1.6; color: #333; }
        .diary-delete-btn { position: absolute; top: 15px; right: 15px; font-size: 18px; color: #aaa; cursor: pointer; transition: color 0.2s ease; }
        .diary-delete-btn:hover { color: var(--soft-red); }
        .preset-list { display: flex; flex-direction: column; gap: 10px; padding: 15px 20px; }
        .preset-item { background-color: white; border-radius: 12px; padding: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); display: flex; justify-content: space-between; align-items: center; }
        .preset-info { flex-grow: 1; cursor: pointer; min-width: 0; margin-right: 10px; }
        .preset-name { font-weight: 500; font-size: 16px; color: #333; margin-bottom: 5px; }
        .preset-desc { font-size: 13px; color: var(--text-gray); overflow: hidden; text-overflow: ellipsis; white-space: pre-wrap; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; }
        .preset-actions { display: flex; gap: 10px; flex-shrink: 0; }
        .preset-action-btn { font-size: 18px; color: #999; cursor: pointer; padding: 5px; }
        .preset-action-btn:hover { color: var(--theme-primary); }
        .preset-action-btn.delete:hover { color: var(--soft-red); }
        /* ▼▼▼ 把这段新代码粘贴进去 ▼▼▼ */
.preset-action-btn.active {
    color: var(--theme-primary); /* 使用主题绿色作为激活颜色 */
}
        .emoticon-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; }
        .emoticon-item { background-color: #fff; border-radius: 8px; padding: 8px; box-shadow: 0 1px 3px var(--shadow-color); position: relative; display: flex; flex-direction: column; align-items: center; justify-content: space-between; }
        .emoticon-item img { max-width: 100%; height: 60px; object-fit: contain; margin-bottom: 5px; }
        .emoticon-name { font-size: 12px; color: #333; text-align: center; word-break: break-all; }
        .emoticon-delete-btn { position: absolute; top: -5px; right: -5px; background-color: var(--soft-red); color: white; width: 20px; height: 20px; border-radius: 50%; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; line-height: 20px; box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        /* ▼▼▼ 替换旧的 #emoticon-picker 样式 ▼▼▼ */
#emoticon-picker {
    position: absolute;
    bottom: 65px;
    left: 10px;
    right: 10px;
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 10px;
    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
    max-height: 250px;
    z-index: 50;
    padding: 10px;

    /* 核心修改：默认隐藏，布局改为垂直弹性盒子 */
    display: none;
    flex-direction: column; 
}

/* 激活时显示为 flex，而不是 grid */
#emoticon-picker.active {
    display: flex !important; 
}

/* 让标签栏固定在顶部，不被压缩 */
#emoticon-picker .feed-sub-tabs {
    flex-shrink: 0; 
}

/* 让下面的表情网格自动填满剩余空间，并负责滚动 */
#emoticon-picker .emoticon-grid {
    flex-grow: 1;
    overflow-y: auto; /* 滚动条加在这里 */
    
    /* 内部维持网格布局 */
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
    gap: 10px;
    padding-top: 5px;
}
/* ▲▲▲ 替换结束 ▲▲▲ */
        #emoticon-picker .emoticon-item { cursor: pointer; transition: transform 0.2s; }
        #emoticon-picker .emoticon-item:hover { transform: scale(1.1); }
        #emoticon-picker .emoticon-delete-btn { display: none; }
        
        /* --- 音乐库新增样式 --- */
        #music-library-list { display: flex; flex-direction: column; gap: 10px; }
        .music-item { background-color: white; border-radius: 8px; padding: 12px 15px; display: flex; align-items: center; justify-content: space-between; box-shadow: 0 1px 3px var(--shadow-color); }
        .music-info { flex-grow: 1; }
        .music-title { font-weight: 600; color: #333; }
        .music-artist { font-size: 14px; color: var(--text-gray); margin-top: 3px; }
        .music-delete-btn { background: none; border: none; font-size: 16px; color: #aaa; cursor: pointer; padding: 5px; }
        .music-delete-btn:hover { color: var(--soft-red); }
        #music-library-picker .picker-title { font-weight: 600; color: var(--text-gray); margin-bottom: 8px; border-bottom: 1px solid #eee; padding-bottom: 8px; }
        #music-library-picker .picker-list { max-height: 120px; overflow-y: auto; }
        #music-library-picker .picker-item { padding: 8px 5px; cursor: pointer; border-radius: 4px; }
        #music-library-picker .picker-item:hover { background-color: #f0f0f0; }

/* ▼▼▼ 用这个新规则，替换掉旧的 #feed-status-indicator 规则 ▼▼▼ */

#feed-status-indicator {
    position: absolute; /* 1. 让它“浮”起来，不占空间 */
    
    /* 2. 把它精确定位到原来“论坛”标题的位置 */
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 60%; /* 限制一个宽度，防止文字太长和按钮打架 */
    
    /* 3. 让它看起来就像标题一样 */
    font-size: 18px; /* 字体可以比原标题小一点点，以示区别 */
    font-weight: 600; /* 字体粗细 */
    color: var(--text-gray); /* 加载时用灰色文字 */
    
    /* 4. 移除所有旧的边框、背景等 */
    padding: 0;
    text-align: center;
    background-color: transparent;
    border: none;
    
    display: none; /* 默认还是隐藏的 */
    z-index: 11; /* 确保它能盖住原来的标题 */
    
    /* 5. (可选) 加一个微妙的呼吸灯动画，让它更像在“加载” */
    animation: pulse-fade 1.5s infinite ease-in-out;

    /* 6. 移除旧的flex布局属性 */
    flex-shrink: unset; 
    order: unset; 
}

/* 7. (新) 呼吸灯动画 */
@keyframes pulse-fade {
    0%, 100% { opacity: 0.7; }
    50% { opacity: 1; }
}

/* 8. (新) 这就是魔法！ */
/* 当顶栏(header)处于“is-loading”状态时... */
.moments-header.is-loading .moments-title {
    /* ...就隐藏掉原来的“论坛”二字 */
    visibility: hidden; /* 用 visibility 而不是 display:none 来保持布局稳定 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; }
        input:checked + .slider { background-color: var(--theme-primary); }
        input:focus + .slider { box-shadow: 0 0 1px var(--theme-primary); }
        input:checked + .slider:before { transform: translateX(22px); }
        .slider.round { border-radius: 28px; }
        .slider.round:before { border-radius: 50%; }
        #attachment-menu { position: absolute; bottom: 65px; left: 10px; right: 10px; background-color: #f9f9f9; border: 1px solid #ddd; border-radius: 12px; box-shadow: 0 -4px 15px rgba(0,0,0,0.1); padding: 15px; display: none; grid-template-columns: repeat(4, 1fr); gap: 15px; z-index: 50; transition: opacity 0.2s ease, transform 0.2s ease; transform: translateY(10px); opacity: 0; }
        #attachment-menu.active { display: grid; transform: translateY(0); opacity: 1; }
        .attachment-menu-item { display: flex; flex-direction: column; align-items: center; cursor: pointer; text-align: center; }
        .attachment-menu-item .icon-wrapper { width: 60px; height: 60px; background-color: white; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 28px; color: #555; margin-bottom: 8px; border: 1px solid #eee; }
        .attachment-menu-item .label { font-size: 13px; color: var(--text-gray); }
        .attachment-menu-item:hover .icon-wrapper { background-color: #f0f0f0; }
        .system-notification { align-self: center; background-color: #e1e1e1; color: var(--text-gray); font-size: 12px; padding: 5px 12px; border-radius: 15px; margin: 10px 0; text-align: center; }
        /* --- [V-MOD] AI假图片样式 (替换旧的 .message.picture-description) --- */

/* --- [V-MOD 2.0] AI "翻转"图片卡片样式 --- */

/* 1. 气泡本身 (透明容器) */
.message.picture-description {
    padding: 0;
    background-color: transparent;
    box-shadow: none;
    cursor: pointer;
    border-radius: 12px;
    overflow: hidden; 
}

/* 2. 内部的 "卡片"，这是我们的关键 */
.picture-description .message-image-container {
    position: relative; /* 关键：让文字可以浮动在图片之上 */
    padding: 5px;
    display: inline-block;
    
    /* == 你的要求：固定大小 == */
    /* (150px 图片 + 左右各 5px 内边距) */
    width: 160px;  
    height: 160px; 
    
    /* 确保大小计算正确 */
    box-sizing: border-box; 
    
    /* 圆角和过渡（用于切换背景色） */
    border-radius: 12px; 
    transition: background-color 0.3s ease;
}

/* 3. 卡片背景色 (保持原样) */
.message.sent.picture-description .message-image-container {
     background-color: var(--sent-message-bg);
}
.message.received.picture-description .message-image-container {
     background-color: white;
}

/* 4. 图片样式 (负责淡出) */
.picture-description .message-image {
    width: 150px;  /* 固定 150px */
    height: 150px; /* 固定 150px */
    border-radius: 12px;
    display: block;
    object-fit: cover; /* 确保图片不变形 */
    
    /* == 你的要求：淡出效果 == */
    opacity: 1;
    transition: opacity 0.3s ease-in-out;
    
    /* 定位，为文字腾出空间 */
    position: absolute;
    top: 5px;
    left: 5px;
}

/* 5. 【全新】描述文字的样式 (负责淡入) */
.picture-description-text {
    /* 浮动在图片之上 */
    position: absolute;
    top: 5px;
    left: 5px;
    width: 150px;  /* 尺寸与图片完全一致 */
    height: 150px; /* 尺寸与图片完全一致 */
    
    /* == 你的要求：文字可滑动 == */
    overflow-y: auto;
    padding: 10px; 
    box-sizing: border-box;

    /* == 你的要求：淡入效果 == */
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
    pointer-events: none; /* 隐藏时不可点击或滑动 */
    
    /* 文字排版 */
    font-size: 13px;
    color: var(--text-dark, #424242);
    line-height: 1.5;
    word-wrap: break-word;
    
    /* 适配深色气泡 (可选) */
    .message.sent & {
        color: var(--text-dark, #424242);
    }
}

/* 6. 【关键】切换状态的CSS */

/* 当卡片被点击，添加 .description-visible 类时... */
.picture-description.description-visible .message-image {
    /* == 你的要求：图片淡出 == */
    opacity: 0;
}

.picture-description.description-visible .picture-description-text {
    /* == 你的要求：文字淡入 == */
    opacity: 1;
    pointer-events: auto; /* 允许滑动和点击 */
}
/* --- [V-MOD 2.0] CSS 结束 --- */
        .message.sent.picture-description { background-color: var(--sent-message-bg); }
        .message.received.picture-description { background-color: #fff; }
        .message.picture-description i { font-size: 20px; color: var(--text-gray); margin-right: 10px; }
        .message.picture-description span { color: #333; }
        .message.voice { display: flex; align-items: center; justify-content: space-between; cursor: pointer; }
        .message.voice .fa-wifi { font-size: 20px; transform: rotate(90deg); color: var(--text-gray); }
        .message.sent.voice { background-color: var(--sent-message-bg); }
        .message.received.voice { background-color: #fff; }
        .message.sent.voice .fa-wifi { order: 2; margin-left: 15px; }
        .message.received.voice .fa-wifi { margin-right: 15px; }
        .voice-duration { color: var(--text-gray); }
/* ▼▼▼ 粘贴这个【最终修复版】▼▼▼ */
        .transcribed-text { 
            background-color: #fff; 
            border: 0px solid #eee; /* 修复1：默认边框改为0 */
            padding: 0 10px; /* 修复2：默认的 上下内边距 改为0 */
            border-radius: 8px; 
            margin-top: 0; 
            font-size: 14px; 
            color: #333; 
            max-height: 0; 
            opacity: 0; 
            overflow: hidden; 
            /* 修复3：把padding和border也加入过渡动画 */
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, margin-top 0.3s ease-out, padding 0.3s ease-out, border-width 0.3s ease-out; 
        }
        .transcribed-text.visible { 
            max-height: 200px; 
            opacity: 1; 
            margin-top: 5px; 
            padding: 10px; /* 修复4：仅在可见时恢复内边距 */
            border-width: 1px; /* 修复5：仅在可见时恢复边框 */
        }
        /* ▲▲▲ 替换结束 ▲▲▲ */
        .message.red-packet { background-color: #FFCC80; color: #5D4037; width: 240px; padding: 0; overflow: hidden; cursor: pointer; transition: background-color 0.3s, box-shadow 0.3s; box-shadow: 0 2px 5px rgba(255, 152, 0, 0.2); }
        .message.red-packet.opened { background-color: #FFF3E0; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05); }
        .message.red-packet .red-packet-header { padding: 10px 15px; display: flex; align-items: center; }
        .message.red-packet .red-packet-icon { font-size: 24px; margin-right: 10px; color: #FFA726; }
        .message.red-packet .red-packet-blessing { font-size: 15px; flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 500; }
        .message.red-packet .red-packet-status { font-size: 13px; opacity: 0.9; }
        .message.red-packet.opened .red-packet-icon, .message.red-packet.opened .red-packet-blessing, .message.red-packet.opened .red-packet-status { color: #BCAAA4; }
        .message.red-packet .red-packet-footer { background-color: transparent; color: #A1887F; font-size: 12px; padding: 5px 15px; border-top: 1px solid rgba(161, 136, 127, 0.2); }
        .message.red-packet.opened .red-packet-footer { color: #cebeba; border-top: 1px solid rgba(161, 136, 127, 0.1); }
        .message.sent.red-packet { border-top-right-radius: 0; }
        .message.received.red-packet { border-top-left-radius: 0; }
        .message.transfer { background-color: var(--theme-primary); color: white; width: 240px; padding: 0; overflow: hidden; position: relative; box-shadow: 0 2px 5px var(--shadow-color); }
        .message.transfer.completed { background-color: #C8E6C9; }
        .message.transfer.completed .transfer-info .transfer-text, .message.transfer.completed .transfer-info .transfer-amount { color: #388E3C; }
        .message.transfer.completed .transfer-icon i { color: var(--theme-primary-hover); }
        .message.transfer.completed::after { content: '\f00c'; font-family: 'Font Awesome 6 Free'; font-weight: 900; position: absolute; right: 15px; top: 50%; transform: translateY(-50%); font-size: 18px; color: var(--theme-primary-hover); }
        .message.transfer .transfer-header { padding: 10px 15px; display: flex; align-items: center; }
        .message.transfer .transfer-icon { font-size: 24px; margin-right: 10px; }
        .message.transfer .transfer-info .transfer-text { font-size: 15px; font-weight: 500; }
        .message.transfer .transfer-info .transfer-amount { font-size: 18px; font-weight: bold; }
        .message.transfer .transfer-footer { background-color: transparent; color: white; font-size: 12px; padding: 5px 15px; border-top: 1px solid rgba(255,255,255,0.3); opacity: 0.9; }
        .message.transfer.completed .transfer-footer { color: var(--theme-primary-hover); border-top: 1px solid rgba(102, 187, 106, 0.2); }
        .message.sent.transfer { border-top-right-radius: 0; }
        .message.received.transfer { border-top-left-radius: 0; }

        /* --- Pet Game Styles --- */
        #pet-container {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }
        .pet-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
        }
        #pet-name {
            color: var(--text-dark);
        }
        #pet-gold-display {
            font-size: 16px;
            color: #E6A23C;
        }
        .pet-visual-area {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            margin-bottom: 15px;
        }
        .pet-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }
        .stat-bar-container {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        .stat-bar-label {
            width: 60px;
            text-align: right;
        }
        .stat-bar {
            flex-grow: 1;
            height: 10px;
            background-color: #eee;
            border-radius: 5px;
            overflow: hidden;
        }
        .stat-bar-inner {
            height: 100%;
            width: 100%;
            border-radius: 5px;
            background-color: var(--theme-primary);
            transition: width 0.3s ease, background-color 0.3s ease;
        }
        .pet-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .pet-action-btn {
            padding: 10px;
            font-size: 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: #f0f2f5;
            color: var(--text-dark);
        }
        .pet-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .pet-action-btn:disabled {
            background-color: #e9ecef;
            color: #adb5bd;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        #work-pet-btn {
            background-color: var(--theme-secondary);
            color: white;
        }
        
        .slime {
    width: 55px; /* 宽度设为55px */
    height: 40px; /* 高度设为40px，这样基础形状更稳定 */
    /* 背景色和半透明效果保持不变 */
    background-color: rgba(209, 233, 206, 0.8); 
    
    /* 核心修改：只设置左上角和右上角的圆角，让底部保持平坦 */
    /* 这四个值分别对应：左上、右上、右下、左下 */
    border-radius: 60px 60px 30px 30px; 

    position: relative;
    animation: slime-bob 2s infinite ease-in-out;
    transition: all 0.5s ease;
    
    /* 边框效果保持不变 */
    border: 2px solid rgba(76, 175, 80, 0.5);
    /* 新增：移除底部边框线，让它完美地“贴”在地面上 */
    border-bottom: none; 
    
    /* 内阴影果冻质感保持不变 */
    box-shadow: inset 0 -4px 8px rgba(0, 0, 0, 0.15), 
                inset 0 4px 6px rgba(255, 255, 255, 0.4);
}
        .slime.hungry { background-color: #ffb74d; }
        .slime.dirty { background-color: #bdbdbd; }
        .slime::before {
            content: '';
            position: absolute;
            width: 7px;
            height: 7px;
            background-color: #212121;
            border-radius: 50%;
            top: 15px;
            left: 12px;
            transition: all 0.5s ease;
        }
        .slime::after {
            content: '';
            position: absolute;
            width: 7px;
            height: 7px;
            background-color: #212121;
            border-radius: 50%;
            top: 15px;
            right: 12px;
            transition: all 0.5s ease;
        }
        .slime-shadow {
            width: 50px;
            height: 8px;
            background-color: rgba(0,0,0,0.1);
            border-radius: 50%;
            margin-top: 5px;
            animation: slime-shadow-squish 2s infinite ease-in-out;
            transition: all 0.5s ease;
        }
        @keyframes slime-bob {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        @keyframes slime-shadow-squish {
             0%, 100% { transform: scaleX(1); }
            50% { transform: scaleX(0.8); }
        }

        /* --- V6.0 新增：宠物进化形态 --- */
        /* 初始宝宝期形态 */
        .slime.baby-form { }

        /* 幼年期 */
        .slime.toddler-form {
            transform: scale(1.15); /* 长大一点 */
            background-color: #a5d6a7; /* 颜色变嫩一点 */
        }
        .slime.toddler-form::before, 
        .slime.toddler-form::after {
            width: 7px; /* 眼睛变大一点 */
            height: 7px;
            box-shadow: 0 0 2px rgba(255, 255, 255, 0.6); /* 眼睛里有光 */
        }

        /* 少年期，眼睛变成 > < 的样子*/
        .slime.teenager-form {
            transform: scale(1.25);
            animation-duration: 1.5s; /* 变得更活泼，跳得快一点 */
        }
        .slime.teenager-form::before { /* 左眼 */
            content: '>';
            font-weight: bold;
            color: white;
            background: none;
            font-size: 12px;
            line-height: 1;
            transform: rotate(-15deg);
            top: 18px;
            left: 18px;
        }
        .slime.teenager-form::after { /* 右眼 */
            content: '<';
            font-weight: bold;
            color: white;
            background: none;
            font-size: 12px;
            line-height: 1;
            transform: rotate(15deg);
            top: 18px;
            right: 18px;
        }
        /* --- 新增：史莱姆互动动画 --- */
        .slime.happy-jiggle {
            animation: happy-jiggle 0.5s ease-in-out;
        }
        @keyframes happy-jiggle {
            0%, 100% { transform: scale(1, 1); }
            25% { transform: scale(0.95, 1.05); }
            50% { transform: scale(1.05, 0.95); }
            75% { transform: scale(0.98, 1.02); }
        }

        .slime .blush {
            position: absolute;
            width: 15px;
            height: 6px;
            background-color: rgba(255, 105, 180, 0); /* 默认透明 */
            border-radius: 50%;
            top: 22px;
            transition: background-color 0.3s ease;
        }
        .slime .blush.left { left: 5px; transform: rotate(-15deg); }
        .slime .blush.right { right: 5px; transform: rotate(15deg); }
        .slime.is-blushing .blush {
            background-color: rgba(255, 105, 180, 0.6); /* 脸红 */
        }
/* --- 新增：用于隐藏思维预设的编辑功能 --- */
/*

/ * 1. 隐藏“思维预设管理”页面右上角的“+”添加按钮 * /
#add-thought-preset-btn {
    display: none;
}

/ * 2. 隐藏每个思维预设项目右侧包含“编辑”和“删除”图标的整个操作区 * /
#thought-presets-list .preset-actions {
    display: none;
}

*/
/* --- 钱包收支明细样式 --- */
        #transaction-list {
            padding: 10px 0;
        }
        .transaction-item {
            background-color: white;
            padding: 15px;
            margin: 0 15px 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .transaction-info .desc {
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 4px;
            font-size: 16px;
        }
        .transaction-info .time {
            font-size: 13px;
            color: var(--text-gray);
        }
        .transaction-amount {
            font-size: 16px;
            font-weight: bold;
            flex-shrink: 0;
            margin-left: 15px;
        }
        .transaction-amount.income {
            color: var(--theme-primary-hover);
        }
        .transaction-amount.expense {
            color: var(--soft-red);
        }

/* --- 转账退还样式 --- */
        .message.transfer.returned {
            background-color: #bdc3c7; /* 中性灰色背景 */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .message.transfer.returned .transfer-info .transfer-text,
        .message.transfer.returned .transfer-info .transfer-amount,
        .message.transfer.returned .transfer-footer {
            color: #6c757d;
            text-decoration: line-through; /* 添加删除线表示作废 */
        }
        .message.transfer.returned .transfer-icon i {
            color: #6c757d;
        }
        /* 将退还后的图标从对勾变为退还箭头 */
        .message.transfer.returned::after {
            content: '\f0e2'; /* Font Awesome "reply/undo" icon */
            font-family: 'Font Awesome 6 Free';
            font-weight: 900; 
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 18px;
            color: #6c757d;
        }
        /* 转账弹窗里的退还按钮样式 */
        #return-transfer-btn {
            margin-top: 10px;
            background-color: #e67e22; /* 胡萝卜橙色 */
        }
        /* --- 全新美化的转账弹窗样式 --- */
        #transfer-modal .modal-header { /* 优化头部 */
            background-color: #f7f9f9;
            color: var(--text-dark);
            border-bottom: 1px solid #eee;
        }
        #transfer-modal .close-btn { color: #999; }
        #transfer-modal .modal-body {
            padding: 20px 25px 30px;
            text-align: center;
        }
        .transfer-sender-profile { /* 发起人信息 */
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 25px;
        }
        .transfer-sender-avatar {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            margin-right: 12px;
        }
        .transfer-sender-info { text-align: left; }
        .transfer-sender-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-dark);
        }
        .transfer-recipient-name {
            font-size: 14px;
            color: var(--text-gray);
        }
        .transfer-amount-display { /* 金额显示 */
            padding-bottom: 25px;
            margin-bottom: 25px;
            border-bottom: 1px dashed #ddd;
        }
        .transfer-amount-display span:first-child { /* '¥' 符号 */
            font-size: 32px;
            font-weight: 500;
            margin-right: 4px;
        }
        .transfer-amount-display span:last-child { /* 金额数字 */
            font-size: 48px;
            font-weight: 700;
            color: var(--text-dark);
        }
        .transfer-action-area .form-button { /* 按钮区域 */
            margin-top: 10px;
        }
        #confirm-transfer-btn { background-color: var(--theme-primary); }
        #return-transfer-btn { background-color: #e67e22; }

        /* --- 已收款/已退还状态视图 --- */
        .transfer-status-info {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 600;
            color: var(--text-dark);
        }
        .transfer-status-info i {
            font-size: 24px;
            margin-right: 10px;
        }
        .transfer-status-info i.fa-check-circle { color: var(--theme-primary-hover); }
        .transfer-status-info i.fa-undo-alt { color: #e67e22; }
        .transfer-status-subtext {
            margin-top: 8px;
            font-size: 14px;
            color: var(--text-gray);
        }
        /* --- 修正系统消息包裹层，使其居中 --- */
        .message-wrapper.system-wrapper {
            align-self: center;
            /* 解除最大宽度限制，让内部的灰色消息自己决定宽度 */
            max-width: none;
            justify-content: center;
        }
        /* --- 论坛帖子内的红包卡片样式 --- */
        .forum-red-packet-card {
            background-color: #FFCC80;
            color: #5D4037;
            padding: 10px 15px;
            margin-top: 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .forum-red-packet-card:hover {
            transform: scale(1.02);
        }
        .forum-red-packet-card .red-packet-icon {
            font-size: 24px;
            margin-right: 10px;
            color: #FFA726;
        }
        .forum-red-packet-card .red-packet-blessing {
            font-weight: 500;
        }

        /* --- 帖子分享到私聊里的卡片样式 --- */
        .message.post-share-card {
            background-color: #fff;
            border: 1px solid #eee;
            width: 250px;
            padding: 12px;
            border-radius: 12px;
            cursor: pointer;
        }
        .post-share-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #f0f0f0;
        }
        .post-share-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .post-share-name {
            font-weight: 600;
            font-size: 14px;
        }
        .post-share-content {
            font-size: 14px;
            color: var(--text-gray);
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.5;
        }
        .post-share-footer {
            margin-top: 8px;
            font-size: 12px;
            color: #ccc;
            text-align: right;
        }
        
        /* --- 发布动态时添加红包的按钮样式 --- */
        .moment-extra-actions {
            display: flex;
            justify-content: flex-start;
            padding-top: 10px;
            border-top: 1px solid #f0f0f0;
        }
        .moment-action-btn {
            font-size: 20px;
            color: var(--text-gray);
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
        }
        .moment-action-btn:hover {
            background-color: #f0f0f0;
        }
        .moment-action-btn.active {
            color: var(--soft-red);
        }
        
        /* --- 转发时选择联系人的弹窗样式 --- */
        .contact-picker-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 5px;
            margin-bottom: 15px;
        }
        .contact-picker-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-radius: 6px;
        }
        .contact-picker-item:hover {
            background-color: #f9f9f9;
        }
        .contact-picker-item input {
            margin-right: 15px;
        }
        .contact-picker-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }
        #custom-confirm-confirm-btn.danger {
    background-color: var(--soft-red) !important;
}
/* ========================================================== */
/* V9.0 新增：悬浮音乐播放器样式 */
/* ========================================================== */
:root {
    --apple-green: #8DB600; /* 新增苹果绿 */
}
#music-player-card {
    display: none; /* 默认隐藏，由JS控制 */
    flex-direction: column;
    position: absolute; /* 使用absolute定位在#screen内 */
    width: 320px;
    height: 500px;
    background-color: rgba(255, 255, 255, 0.92);
    backdrop-filter: blur(20px);
    border-radius: 16px;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
    overflow: hidden;
    top: 50px; 
    left: 50px;
    z-index: 1000;
    transition: all 0.4s ease-in-out;
}
.player-header {
    padding: 0 15px;
    height: 45px;
    font-weight: 600;
    color: var(--text-dark);
    background-color: rgba(0,0,0,0.05);
    cursor: move;
    position: relative;
    user-select: none;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-shrink: 0;
}
.player-collapse-btn {
    position: absolute;
    top: 50%;
    left: 15px;
    transform: translateY(-50%);
    cursor: pointer;
    color: var(--text-light);
    padding: 5px;
}
/* --- ▼▼▼ 新增的关闭按钮样式 ▼▼▼ --- */
#player-close-btn {
    position: absolute;
    top: 50%;
    right: 15px;
    transform: translateY(-50%);
    cursor: pointer;
    color: var(--text-gray);
    padding: 5px;
    font-size: 18px;
    transition: transform 0.2s ease;
}
#player-close-btn:hover {
    transform: translateY(-50%) scale(1.15);
}
.header-collapsed-content {
    display: none;
    align-items: center;
    gap: 10px;
    width: 100%;
    padding-left: 35px;
}
.header-avatar-stack { display: flex; align-items: center; }
.header-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: 2px solid white;
    object-fit: cover;
}
.header-avatar:last-child { margin-left: -10px; }
.header-lyric {
    flex-grow: 1;
    font-size: 14px;
    font-weight: 600;
    color: var(--apple-green);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.player-main-content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    transition: opacity 0.3s;
}
.player-avatar-stack { display: flex; justify-content: center; align-items: center; padding: 20px 0 15px; }
.player-avatar { width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 3px solid white; box-shadow: 0 4px 10px rgba(0,0,0,0.15); }
.player-avatar:last-child { margin-left: -25px; }
.player-song-info { text-align: center; }
.player-title { font-size: 18px; font-weight: 700; color: var(--text-dark); }
.player-artist { font-size: 14px; color: var(--text-light); margin-top: 5px; }
.lyrics-container { flex-grow: 1; overflow: hidden; position: relative; mask-image: linear-gradient(transparent 0%, black 20%, black 80%, transparent 100%); margin-top: 15px; }
.lyrics-wrapper { position: absolute; width: 100%; transition: transform 0.5s ease-out; }
.lyric-line { padding: 8px 20px; text-align: center; font-size: 16px; color: var(--text-light); transition: color 0.5s, transform 0.5s; }
.lyric-line.active {
    color: var(--apple-green);
    font-weight: 600; 
    transform: scale(1.1); 
}
.player-controls-wrapper { padding: 15px 20px; border-top: 1px solid rgba(0,0,0,0.05); }
.player-progress-bar-wrapper { display: flex; align-items: center; gap: 10px; font-size: 12px; color: var(--text-light); }
.player-progress-bar { flex-grow: 1; height: 4px; background-color: rgba(0,0,0,0.1); border-radius: 2px; cursor: pointer; padding: 4px 0; background-clip: content-box; }
.player-progress { width: 0%; height: 100%; background-color: var(--theme-primary); border-radius: 2px; }
.player-controls { display: flex; justify-content: space-around; align-items: center; font-size: 20px; margin-top: 10px; color: var(--text-dark); }
.player-control-btn { cursor: pointer; transition: transform 0.2s; width: 30px; text-align: center;}
.player-control-btn:hover { transform: scale(1.15); }
.player-play-btn { font-size: 40px; color: var(--theme-primary); }

#music-player-card.collapsed {
    height: 45px;
    background-color: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(25px);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.25);
}
#music-player-card.collapsed .header-collapsed-content,
#music-player-card.collapsed .player-collapse-btn {
    text-shadow: 0 1px 3px rgba(0,0,0,0.4);
}
#music-player-card.collapsed .player-header-title { display: none; }
#music-player-card.collapsed .header-collapsed-content { display: flex; }
#music-player-card.collapsed .player-main-content { visibility: hidden; opacity: 0; }

.player-playlist-view {
    position: absolute;
    top: 45px;
    left: 0; right: 0; bottom: 95px; 
    background-color: rgba(255, 255, 255, 0.92); 
    backdrop-filter: blur(20px); 
    transform: translateY(100%);
    transition: transform 0.4s ease-in-out, opacity 0.4s ease-in-out; /* 建议给opacity也加上过渡效果 */
    opacity: 0;
    padding: 10px 0;
    overflow-y: auto;
    border-top: 1px solid rgba(0,0,0,0.05);
    pointer-events: none; /* <-- 核心新增：隐藏时忽略点击事件 */
    z-index: 3;
}
.player-playlist-view.active { 
    transform: translateY(0); 
    opacity: 1; 
    pointer-events: auto; /* <-- 核心新增：显示时恢复点击事件 */
}
.playlist-item { padding: 12px 20px; cursor: pointer; border-bottom: 1px solid rgba(0,0,0,0.05); }
.playlist-item:hover { background-color: rgba(0,0,0,0.05); }
.playlist-item.playing .playlist-title { color: var(--theme-primary); }
.playlist-title { font-weight: 600; color: var(--text-dark); font-size: 14px; }
.playlist-artist { font-size: 12px; color: var(--text-light); }
/* ========================================================== */
/* V16.0 最终完美版：无缝、平滑的呼吸光晕 */
/* ========================================================== */

/* 1. 【防重叠魔法】(此部分无变化) */
.player-avatar {
    position: relative;
}
.player-avatar:first-child {
    z-index: 2;
}
.player-avatar:last-child {
    z-index: 1;
}

/* 2. 【重新定义动画】创建一个完整的“吸气-呼气”循环 */
@keyframes pulse-glow-left {
    /* 动画的开始和结束点都是同一个状态：最小、最明显的光晕 */
    0%, 100% {
        box-shadow: -2px 0 5px 0px rgba(129, 199, 132, 0.7);
    }
    /* 动画的中点是另一个状态：最大、最微弱的光晕 */
    50% {
        /* 关键：这里的透明度不是0，而是0.1，保留了一丝微光，确保动画永不中断！ */
        box-shadow: -8px 0 20px 12px rgba(129, 199, 132, 0.1);
    }
}

@keyframes pulse-glow-right {
    0%, 100% {
        box-shadow: 2px 0 5px 0px rgba(129, 199, 132, 0.7);
    }
    50% {
        box-shadow: 8px 0 20px 12px rgba(129, 199, 132, 0.1);
    }
}

/* 3. 【应用新动画】移除 alternate，并使用更平滑的 ease-in-out */
#player-avatar-stack.is-playing .player-avatar:first-child {
    /* 动画时长3秒，无限循环，缓入缓出效果，不再需要 alternate */
    animation: pulse-glow-left 3s infinite ease-in-out;
}
#player-avatar-stack.is-playing .player-avatar:last-child {
    animation: pulse-glow-right 3s infinite ease-in-out;
}
/* --- 红包领取详情弹窗样式 --- */
.claimer-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid #f0f0f0;
}
.claimer-item:last-child {
    border-bottom: none;
}
.claimer-avatar {
    width: 40px;
    height: 40px;
    border-radius: 6px;
    margin-right: 12px;
}
.claimer-info {
    flex-grow: 1;
}
.claimer-name {
    font-weight: 500;
    color: var(--text-dark);
}
.claim-time {
    font-size: 12px;
    color: var(--text-gray);
    margin-top: 2px;
}
.claim-amount {
    font-size: 15px;
    font-weight: 600;
    color: var(--text-dark);
}
.best-luck-badge {
    background-color: #FFD700;
    color: #A67C00;
    font-size: 11px;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 5px;
    margin-left: 8px;
}
/* --- V-Final 新增: 游戏转盘样式 --- */
.wheel-option-item {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}
.wheel-option-item input[type="text"] {
    flex-grow: 1;
}
.wheel-option-item input[type="number"] {
    width: 60px;
    text-align: center;
}
.wheel-option-item .delete-option-btn {
    background: none;
    border: none;
    color: var(--soft-red);
    cursor: pointer;
    font-size: 18px;
}
.message.game-wheel-card {
    background-color: #fff;
    border: 1px solid #eee;
    width: 250px;
    padding: 12px;
    border-radius: 12px;
}
.wheel-card-title {
    font-weight: bold;
    text-align: center;
    padding-bottom: 8px;
    border-bottom: 1px solid #f0f0f0;
    margin-bottom: 12px;
}
.wheel-card-result-area {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.wheel-result-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.wheel-player-name {
    font-size: 14px;
    color: #555;
}
.wheel-player-result {
    font-size: 14px;
    font-weight: 600;
    background-color: #f0f2f5;
    padding: 4px 10px;
    border-radius: 12px;
}
.spin-btn {
    background-color: var(--theme-primary);
    color: white;
    border: none;
    padding: 4px 12px;
    border-radius: 12px;
    cursor: pointer;
    font-size: 14px;
}
.spin-btn:hover {
    background-color: var(--theme-primary-hover);
}
/* --- 引用回复功能样式 --- */
.message-wrapper {
    position: relative; /* 确保回复按钮可以正确定位 */
}

.reply-btn {
    position: absolute;
    top: 50%;
    background-color: rgba(240, 240, 240, 0.8);
    backdrop-filter: blur(2px);
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: #555;
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    opacity: 0; /* 默认完全透明，隐藏 */
    transform: translateY(-50%) scale(0.8); /* 默认缩小一点 */
    transition: opacity 0.2s ease, transform 0.2s ease; /* 添加平滑过渡动画 */
    pointer-events: none; /* 隐藏时不可点击 */
}

/* 当父级 message-wrapper 拥有 .show-reply-btn 类时，让按钮显示出来 */
.message-wrapper.show-reply-btn .reply-btn {
    opacity: 1;
    transform: translateY(-50%) scale(1);
    pointer-events: auto; /* 显示时恢复点击 */
}

/* ▼▼▼ 用这个替换你原来的 ▼▼▼ */
.message-wrapper.sent .reply-btn,
.message-wrapper.sent .recall-btn { /* <-- 关键：把 .recall-btn 加到这里 */
    left: -35px; /* 两个按钮都固定在左边 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */
.message-wrapper.received .reply-btn {
    right: -35px; /* 收到的消息，按钮在右边 */
}
.reply-btn:hover {
    transform: translateY(-50%) scale(1.1) !important;
}

/* 聊天输入框上方的引用预览条 */
#reply-preview-bar {
    padding: 8px 15px;
    background-color: #f0f0f0;
    font-size: 13px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #e0e0e0;
}
#reply-preview-content {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    color: #666;
}
#reply-preview-content .sender {
    font-weight: 600;
    color: #333;
}
#cancel-reply-btn {
    cursor: pointer;
    font-size: 16px;
    margin-left: 10px;
    color: #888;
}

/* 聊天气泡中的引用消息框 */
.message-quote {
    background-color: rgba(0, 0, 0, 0.05);
    padding: 6px 12px;
    border-left: 3px solid var(--theme-primary);
    border-radius: 6px;
    margin-bottom: 8px;
    font-size: 13px;
    cursor: pointer; /* 添加手型光标，提示可以点击 */
}
.message-quote .sender {
    font-weight: 600;
    color: var(--theme-primary);
}
.message-quote .content {
    color: #555;
    white-space: normal; /* Allows the text to wrap naturally */
    word-wrap: break-word; /* Ensures long words don't overflow */
    display: block;
    /* The overflow and text-overflow properties are no longer needed */
}

/* 点击引用框跳转后，目标消息的高亮效果 */
.message-wrapper.highlighted .message {
    animation: highlight-anim 1.5s ease;
}
@keyframes highlight-anim {
    0% { background-color: #fff3cd; }
    100% { background-color: inherit; }
}
.message-wrapper.sent.highlighted .message.sent {
     animation: highlight-anim-sent 1.5s ease;
}
@keyframes highlight-anim-sent {
    0% { background-color: #bde0fe; }
    100% { background-color: var(--sent-message-bg); }
}
/* --- V-Final 新增: 叙事模式气泡加宽 --- */
#chat-messages.narrative-mode-active .message-wrapper {
    max-width: 90%; /* 从默认的 85% 增加到 95% */
}
/* --- V-Final 新增: 在聊天中隐藏角色头像 --- */
.message-wrapper.contact-avatar-hidden .message-avatar {
    display: none;
}
.message-wrapper.received.contact-avatar-hidden .message-body {
    margin-left: 0;
}
/* ========================================================== */
/* V17.0 新增：视频通话样式 (简化版) */
/* ========================================================== */
.video-call-card-content {
    width: 90%;
    max-width: 400px;
    height: 75%;
    max-height: 650px;
    background-color: rgba(255, 255, 255, 0.92);
    backdrop-filter: blur(18px);
    border-radius: 24px;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.5);
    display: flex;
    flex-direction: column;
    color: var(--text-dark);
    overflow: hidden;
}
.video-call-header { padding: 15px; text-align: center; flex-shrink: 0; border-bottom: 1px solid rgba(0,0,0,0.07); }
#call-contact-name { font-size: 18px; font-weight: 700; }
#call-status { display: block; font-size: 13px; color: var(--theme-primary); margin-top: 4px; font-weight: 600; }
.video-call-main { flex-grow: 1; padding: 15px; overflow: hidden; }
.narrative-feed { height: 100%; overflow-y: auto; padding-right: 10px; display: flex; flex-direction: column; }
.char-bubble { align-self: flex-start; max-width: 90%; background-color: #fff; border: 1px solid var(--border-color); box-shadow: 0 1px 2px rgba(0,0,0,0.04); padding: 10px 15px; border-radius: 18px; border-top-left-radius: 4px; margin-bottom: 12px; font-size: 15px; line-height: 1.6; }
.char-bubble p { margin: 0 0 8px 0; }
.char-bubble p:last-child { margin-bottom: 0; }
.char-bubble .narrative-speech { color: var(--text-dark); font-weight: 500; }
.char-bubble .narrative-action { color: var(--text-gray); font-style: italic; }
.char-bubble .narrative-psychology { color: var(--theme-primary-hover); font-style: italic; }
.narrative-feed > .narrative-action { color: var(--text-gray); font-style: italic; align-self: center; text-align: center; font-size: 13px; margin: 5px 0 15px 0; }
.user-message { align-self: flex-end; background-color: var(--sent-message-bg); padding: 10px 15px; border-radius: 18px; border-bottom-right-radius: 4px; color: var(--text-dark); font-weight: 500; margin-bottom: 12px; max-width: 90%; font-size: 15px; line-height: 1.6; }
.video-call-input-area { padding: 8px 15px; display: flex; align-items: center; border-top: 1px solid rgba(0,0,0,0.07); background-color: rgba(0,0,0,0.03); flex-shrink: 0; }
#video-call-input { flex-grow: 1; background-color: white; border: 1px solid var(--border-color); border-radius: 20px; padding: 8px 15px; font-size: 15px; outline: none; resize: none; max-height: 100px; overflow-y: auto; font-family: inherit; }
#video-call-send-btn { background-color: var(--theme-primary); color: var(--text-on-primary); border: none; border-radius: 50%; width: 38px; height: 38px; display: flex; justify-content: center; align-items: center; margin-left: 8px; cursor: pointer; font-size: 16px; flex-shrink: 0; transition: background-color 0.2s; }
.video-call-controls { display: flex; justify-content: space-around; align-items: center; padding: 15px 20px; background-color: rgba(0,0,0,0.03); flex-shrink: 0; }
.control-btn { display: flex; flex-direction: column; align-items: center; cursor: pointer; width: 80px; text-align: center; }
.control-btn i { width: 60px; height: 60px; border-radius: 50%; background-color: #e9ecef; color: var(--text-dark); display: flex; justify-content: center; align-items: center; font-size: 26px; margin-bottom: 6px; transition: all 0.2s ease; }
.control-btn span { font-size: 12px; font-weight: 500; color: var(--text-gray); }
.control-btn.hang-up i { background-color: var(--soft-red); color: white; }

/* 来电界面样式 */
#incoming-call-screen {
    display: none; 
    position: absolute; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    z-index: 1002; 
    background-color: rgba(0,0,0,0.7); 
    backdrop-filter: blur(10px); 
    color: white; 
    text-align: center; 
    flex-direction: column; 
    justify-content: space-around; 
    align-items: center;
}

/* 实际通话界面样式 */
#video-call-screen {
    display: none; 
    position: absolute; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    justify-content: center; 
    align-items: center; 
    z-index: 1001; 
    background-color: rgba(0,0,0,0.4);
}
/* --- 新增：响应式手机屏幕模拟 --- */
#app-container {
    /* 默认情况下（手机访问时），占满整个屏幕 */
    width: 100%;
    height: 100%;
    background-color: #f0f2f5; /* 给电脑屏幕背景一个颜色，突出手机区域 */
}

/* 当屏幕宽度大于等于 600px 时（可以理解为平板或电脑）*/
@media (min-width: 600px) {
    #app-container {
        /* 将其最大宽度限制为手机尺寸 */
        max-width: 414px;

        /* 高度也限制为手机尺寸 */
        height: 896px;

        /* 保留圆角来模拟屏幕形状 */
        border-radius: 40px; 
        
        /* 加一点阴影，让它在电脑上有悬浮感，如果完全不想要也可以删除这行 */
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);

        /* 确保内部内容不会溢出圆角 */
        overflow: hidden; 
        
        /* 确保内部的 #screen 元素能正确继承尺寸 */
        position: relative; 
    }
}
/* --- V-Final 新增: 购物中心样式 V3 (修正版) --- */
.product-list {
    display: grid;
    grid-template-columns: 1fr 1fr;
    align-items: start;
    gap: 6px;
    padding: 10px;
}
.product-item {
    background-color: white;
    border-radius: var(--soft-radius);
    box-shadow: 0 1px 4px rgba(0,0,0,0.07);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    border: 1px solid #f0f0f0;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    cursor: pointer;
}
.product-item:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.08);
}
/* V3核心修正：瀑布流错位效果 */
.product-item:nth-child(even) {
    margin-top: 10px;
}
.product-details {
    padding: 12px;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}
.product-title {
    font-size: 15px;
    font-weight: 600;
    line-height: 1.4;
    color: var(--text-dark);
    margin-bottom: 8px;
}
.product-description {
    font-size: 13px;
    color: #555;
    background-color: #f7f9fa;
    padding: 8px 10px;
    border-radius: 8px;
    margin-bottom: 10px;
    line-height: 1.5;
}
.product-shop {
    font-size: 12px;
    color: var(--text-gray);
    margin-top: auto;
    padding-top: 5px;
}
.product-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 8px;
}
.product-price {
    font-size: 16px;
    font-weight: bold;
    color: #ff7043;
}
.product-price span {
    font-size: 12px;
    font-weight: normal;
}
.product-share-btn {
    background: none;
    border: none;
    font-size: 18px;
    color: var(--text-gray);
    cursor: pointer;
    padding: 5px;
}
.product-share-btn:hover {
    color: var(--theme-primary);
}
.message.product-share-card {
    background-color: #fff;
    border: 1px solid #eee;
    width: 240px;
    padding: 10px;
    border-radius: 12px;
}
.product-share-intent {
    font-size: 13px;
    font-weight: 600;
    color: var(--text-gray);
    padding-bottom: 8px;
    margin-bottom: 8px;
    border-bottom: 1px solid #f0f0f0;
}
.product-share-body {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.product-share-info {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}
.product-share-info .product-title {
    -webkit-line-clamp: 3;
    font-weight: 600;
}
.product-share-info .product-price {
    margin-top: 5px;
    text-align: right;
}
.product-share-accompanying-msg {
    margin-top: 10px;
    padding: 8px;
    background-color: #f7f9fa;
    border-radius: 8px;
    font-size: 13px;
    color: #555;
    white-space: pre-wrap;
    word-break: break-all;
}
.product-share-accompanying-msg:empty {
    display: none;
}
#product-detail-content #product-main-info {
    background-color: #fff;
    padding: 20px;
    border-radius: var(--soft-radius);
    box-shadow: var(--shadow-color);
}
#detail-action-bar {
    border-top: 1px solid var(--border-color);
    padding: 10px 15px;
}

/* --- V3 新增: 商品详情页样式 --- */
#product-detail-content #product-main-info {
    background-color: #fff;
    padding: 20px;
    border-radius: var(--soft-radius);
    box-shadow: var(--shadow-color);
}
#detail-action-bar {
    border-top: 1px solid var(--border-color);
    padding: 10px 15px;
}
/* --- V-Final 新增: 聊天内分享的商品卡片样式 V2 --- */
.message.product-share-card {
    background-color: #fff;
    border: 1px solid #eee;
    width: 240px;
    padding: 10px;
    border-radius: 12px;
}
.product-share-intent {
    font-size: 13px;
    font-weight: 600;
    color: var(--text-gray);
    padding-bottom: 8px;
    margin-bottom: 8px;
    border-bottom: 1px solid #f0f0f0;
}
/* V2改动：卡片内不再有图片，改为显示文字描述 */
.product-share-body {
    display: flex;
    flex-direction: column; /* 改为垂直布局 */
    gap: 8px;
}
.product-share-info {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}
.product-share-info .product-title {
    -webkit-line-clamp: 3;
    font-weight: 600;
}
.product-share-info .product-price {
    margin-top: 5px;
    text-align: right;
}
.product-share-accompanying-msg {
    margin-top: 10px;
    padding: 8px;
    background-color: #f7f9f9;
    border-radius: 8px;
    font-size: 13px;
    color: #555;
    white-space: pre-wrap;
    word-break: break-all;
}
.product-share-accompanying-msg:empty {
    display: none;
}
/* --- 聊天顶栏“更多操作”菜单样式 (小竖条版) --- */
#chat-options-menu {
    position: absolute;
    top: 55px; /* 从顶栏下方弹出 */
    right: 10px; /* 对齐右侧的按钮 */
    width: 160px; /* 核心改动：固定宽度，让它成为一个“竖条” */
    background-color: rgba(248, 249, 250, 0.92); /* 使用一个更明亮的背景色 */
    backdrop-filter: blur(12px);
    border-radius: 12px; /* 圆角可以稍微小一点，更显精致 */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); /* 一个更柔和的阴影 */
    z-index: 100;
    overflow: hidden;
    border: 1px solid rgba(0, 0, 0, 0.08);
}

.chat-option-item {
    display: flex;
    align-items: center;
    padding: 10px 15px; /* 减少一点垂直内边距，让菜单更紧凑 */
    cursor: pointer;
    font-size: 14px; /* 字体也可以稍微小一点 */
    color: var(--text-gray);
    transition: background-color 0.2s; /* 添加一个过渡效果 */
}

.chat-option-item:hover {
    background-color: rgba(0, 0, 0, 0.05);
}

.chat-option-item i {
    margin-right: 12px;
    color: var(--text-gray);
    width: 20px; /* 固定图标宽度，让文字对齐 */
    text-align: center;
}

.chat-option-divider {
    height: 1px;
    background-color: var(--border-color);
    margin: 4px 10px; /* 分割线也调整一下边距 */
}
/* --- ▼▼▼ 把这段新代码粘贴到 <style> 标签里 --- */
.collapsible-title {
    cursor: pointer; /* 鼠标悬浮时显示为小手形状 */
    display: flex; /* 使用flex布局，让标题和箭头能在一行显示 */
    justify-content: space-between; /* 让标题在左，箭头在右 */
    align-items: center;
}

.collapsible-title .collapse-icon {
    transition: transform 0.2s ease-in-out; /* 让箭头旋转有动画效果 */
    font-size: 14px;
}

.collapsible-title.collapsed .collapse-icon {
    transform: rotate(-90deg); /* 折叠时，箭头旋转-90度 */
}
/* --- ▲▲▲ 粘贴到这里结束 --- */
/* --- 新增：史莱姆随机表情 --- */
/* 移除默认眼睛，为新表情做准备 */
.slime.expression-happy::before, .slime.expression-happy::after,
.slime.expression-sad::before, .slime.expression-sad::after,
.slime.expression-annoyed::before, .slime.expression-annoyed::after,
.slime.expression-shocked::before, .slime.expression-shocked::after {
    background: none; /* 隐藏原来的黑点背景 */
    font-weight: bold;
    font-size: 12px;
    line-height: 1;
    color: #212121; /* 统一设为深灰色 */
}

/* 1. 开心表情 ^_^ */
.slime.expression-happy::before,
.slime.expression-happy::after {
    content: '^';
    top: 18px;
}

/* 2. 难过表情 T_T */
.slime.expression-sad::before,
.slime.expression-sad::after {
    content: 'T';
    top: 18px;
    color: #4285F4; /* 来点蓝色眼泪 */
}

/* 3. 生气/不爽表情 >_< */
.slime.expression-annoyed::before {
    content: '>';
    transform: rotate(-15deg);
    top: 18px;
    left: 18px;
}
.slime.expression-annoyed::after {
    content: '<';
    transform: rotate(15deg);
    top: 18px;
    right: 18px;
}

/* 4. 震惊表情 o_o */
.slime.expression-shocked::before,
.slime.expression-shocked::after {
    content: ''; /* 恢复为空，我们用边框画圆 */
    width: 8px;
    height: 8px;
    border: 2px solid #212121; /* 用边框画一个空心圆 */
    background: white; /* 中间是白色的 */
}
/* --- 新增：更多可爱表情 --- */

/* 1. 开心满足 (u u) */
.slime.expression-pleased::before,
.slime.expression-pleased::after {
    content: 'u';
    font-size: 13px; /* 字体尺寸可以微调 */
    top: 18px;
    font-weight: 600; /* 加粗一点更明显 */
    color: #333;
    background: none;
}

/* 2. 晕乎乎 (x x) */
.slime.expression-dizzy::before,
.slime.expression-dizzy::after {
    content: '×'; /* 使用乘号 × 比字母 x 更好看 */
    font-size: 14px;
    top: 17px;
    font-weight: 600;
    color: #555;
    background: none;
}

/* 3. 无语/怀疑 (- .) */
.slime.expression-doubtful::before {
    content: '';
    width: 10px; /* 横线宽度 */
    height: 3px;  /* 横线厚度 */
    background: #212121;
    border-radius: 2px; /* 让横线两端圆润 */
    top: 20px;
    left: 10px;
}
.slime.expression-doubtful::after {
    /* 右眼还是一个点 */
    content: '';
    width: 7px;
    height: 7px;
    background-color: #212121;
    border-radius: 50%;
    top: 15px;
    right: 12px;
}
/* --- 新增：嘴巴的基础样式和“猫猫嘴”表情 --- */

/* 1. 嘴巴的基础样式 (定位和默认隐藏) */
.slime .mouth {
    position: absolute;
    bottom: 8px; /* 嘴巴在底部偏上一点的位置 */
    left: 50%;
    transform: translateX(-50%); /* 水平居中 */
    width: 0;
    height: 0;
    transition: all 0.3s ease; /* 让表情变化更平滑 */
}

/* 2. 可爱的猫猫嘴 (owo) 表情 */
.slime.expression-cat-face::before,
.slime.expression-cat-face::after {
    /* 眼睛是两个空心圆圈 'o' */
    content: '';
    width: 9px;
    height: 9px;
    border: 2px solid #212121;
    background: white;
    border-radius: 50%;
    top: 14px;
}
/* 用边框“画”一个 'w' 形的嘴巴 */
.slime.expression-cat-face .mouth {
    width: 14px;
    height: 7px;
    border-radius: 0 0 10px 10px / 0 0 6px 6px;
    border: 3px solid #212121;
    border-top: none;
    border-left: 2px solid transparent; /* 用透明边框切出豁口 */
    border-right: 2px solid transparent;
    box-sizing: border-box;
}
/* --- 新增：联系人列表的删除按钮样式 --- */
.contact-delete-btn {
    color: #b0b0b0; /* 默认灰色，不显眼 */
    margin-bottom: 6px; /* 在按钮和下方的时间/未读数之间创建一些间距 */
    cursor: pointer;
    font-size: 10px; /* 图标大小 */
    padding: 5px 8px; /* 增加可点击区域，防止误触 */
    transition: color 0.2s ease;
    display: block; /* 确保按钮在时间的上方 */
    text-align: right; /* 确保图标在容器内是右对齐的 */
}

.contact-delete-btn:hover {
    color: var(--soft-red); /* 鼠标悬浮时变为醒目的红色 */
}
/* --- 新增：用于隐藏AI发送的HTML消息的气泡和头像 --- */
.message-wrapper.ai-html-message .message-avatar,
.message-wrapper.ai-html-message .message-author-name,
.message-wrapper.ai-html-message .message-timestamp {
    display: none !important; /* 彻底隐藏头像、名字和时间戳 */
}
/* --- 新增：热搜话题描述框样式 --- */
#trending-topic-description-container {
    background-color: #e8f5e9; /* 一个淡淡的背景色 */
    padding: 15px;
    margin: 10px; /* 与列表和边缘保持距离 */
    border-radius: var(--soft-radius); /* 使用已有的圆角变量 */
    font-size: 15px;
    line-height: 1.6;
    color: var(--text-dark);
    border: 1px solid var(--border-color);
}
/* --- 新增：地图功能样式 --- */
#map-grid-container {
    position: relative; /* 这个很重要，让后面的图标能相对于它定位 */
    width: 1000px;      /* <--- 新增：给地图一个固定的宽度 */
    height: 1000px;     /* <--- 新增：给地图一个固定的高度 */
    background-color: #e8f5e9; /* 新增：给个底色，防止意外透明 */
    overflow: hidden;   /* 新增：防止图标被拖到地图外面 */
    cursor: crosshair;  /* 新增：鼠标放上去时变成十字准星，更像编辑器 */
    background-image:
        linear-gradient(rgba(129, 199, 132, 0.3) 1px, transparent 1px),
        linear-gradient(90deg, rgba(129, 199, 132, 0.3) 1px, transparent 1px);
    background-size: 20px 20px;
}

.map-icon {
    position: absolute;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.8);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    cursor: pointer;
    font-size: 16px;
    transition: transform 0.2s, background-color 0.2s;
    border: 2px solid white;
}
.map-icon:hover {
    transform: scale(1.2);
    background-color: white;
}
.map-icon-label {
    position: absolute;
    bottom: -20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0,0,0,0.7);
    color: white;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    pointer-events: none; /* 让标签不影响点击图标 */
    opacity: 0;
    transition: opacity 0.2s;
}
.map-icon:hover .map-icon-label {
    opacity: 1;
}
/* --- 新增：地图编辑器中轴线 --- */
#map-grid-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 50%; /* 水平居中 */
    width: 1px; /* 线的宽度 */
    height: 100%; /* 线的高度 */
    background-color: rgba(255, 0, 0, 0.4); /* 半透明红色，很醒目 */
    z-index: 1; /* 确保它在网格之上，但在图标之下 */
    pointer-events: none; /* 让这条线不会影响你点击图标 */
}

#map-grid-container::after {
    content: '';
    position: absolute;
    left: 0;
    top: 50%; /* 垂直居中 */
    width: 100%; /* 线的宽度 */
    height: 1px; /* 线的高度 */
    background-color: rgba(255, 0, 0, 0.4); /* 半透明红色 */
    z-index: 1; /* 确保它在网格之上，但在图标之下 */
    pointer-events: none; /* 让这条线不会影响你点击图标 */
}
/* --- 新增：分级地点样式 --- */
.map-icon.tier-1 {
    width: 40px;
    height: 40px;
    font-size: 20px;
    border-width: 3px;
    z-index: 10; /* 让一级地点永远在最上层 */
}

/* 修改后的通用图标大小 */
.map-icon.tier-2 {
    width: 36px;
    height: 36px;
    font-size: 18px;
    z-index: 5;
    border-radius: 50%; /* 确保是圆的 */
    background-color: white;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15); /* 加点阴影更有质感 */
}

.map-icon.tier-3 {
    width: 22px;
    height: 22px;
    font-size: 12px;
    z-index: 2; /* 让三级地点在最下层 */
}

/* 鼠标悬浮时，统一放大，体验更好 */
.map-icon.tier-1:hover { transform: scale(1.2); }
.map-icon.tier-2:hover { transform: scale(1.3); }
.map-icon.tier-3:hover { transform: scale(1.4); }
.message.location-share-card {
    background-color: #fff;
    border: 1px solid #eee;
    width: 250px;
    padding: 12px;
    border-radius: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 12px;
}
.location-card-icon {
    font-size: 24px;
    color: var(--theme-primary);
    flex-shrink: 0;
}
.location-card-info .name {
    font-weight: 600;
    font-size: 15px;
}
.location-card-info .footer {
    font-size: 12px;
    color: #999;
    margin-top: 4px;
}
/* --- 新增：联系人列表的操作按钮和菜单样式 --- */
.contact-options-btn {
    color: #b0b0b0;
    cursor: pointer;
    padding: 5px 10px;
    font-size: 16px;
    margin-right: -5px;
    margin-bottom: 4px;
    display: block;
}
.contact-options-btn:hover {
    color: var(--theme-primary);
}
#contact-item-menu {
    background-color: rgba(248, 249, 250, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(0, 0, 0, 0.08);
    overflow: hidden;
    width: 200px;
}
#contact-item-menu .menu-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    cursor: pointer;
    font-size: 14px;
    color: var(--text-dark);
}
#contact-item-menu .menu-item:hover {
    background-color: rgba(0, 0, 0, 0.05);
}
#contact-item-menu .menu-item i {
    margin-right: 12px;
    color: var(--text-gray);
    width: 20px;
    text-align: center;
}
/* ========================================================== */
/* V-Final 新增: 锁屏界面 (V3.0 最终样式版) */
/* ========================================================== */
#lock-screen {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    z-index: 2000;
    display: flex;
    flex-direction: column;
    justify-content: space-between; /* 顶部和底部分离，中间留白 */
    color: white;
    font-family: var(--main-font, 'Nunito', sans-serif);
    opacity: 1;
    visibility: visible;
    transition: opacity 0.5s ease, visibility 0.5s;
    padding: 20px; /* 给整个屏幕一个内边距 */
}

#lock-screen.hidden {
    opacity: 0;
    visibility: hidden;
}

.lock-screen-background {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    /* 背景图被移除了，会由JS动态添加 */
    background-size: cover;
    background-position: center center;
    background-repeat: no-repeat;
    filter: blur(8px);
    transform: scale(1.1);
    z-index: -1;
}

#lock-screen::before {
    content: '';
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.35);
    z-index: -1;
}

.lock-screen-body {
    display: flex;
    flex-direction: column;
    gap: 15px; /* 行与行之间的间距 */
}

.widget-row {
    display: flex;
    gap: 15px;
}

.lock-block {
    background-color: rgba(255, 255, 255, 0.15);
    border-radius: 20px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 4px S15px rgba(0,0,0,0.1);
    padding: 15px;
}

.photo-block {
    flex: 1.3;
    min-height: 250px;
    /* ▼▼▼ 在这里添加下面三行 ▼▼▼ */
    background-size: contain;     /* 核心：保证图片完整显示 */
    background-position: center;  /* 图片在区块内居中 */
    background-repeat: no-repeat; /* 防止图片平铺重复 */
}
.right-column {
    flex: 1; /* 窄一点 */
    display: flex;
    flex-direction: column;
    gap: 15px;
}
.right-column .widget {
    flex: 1; /* 均分高度 */
}

/* 第二行布局 */
#lock-screen-time-widget { flex: 1; }
#lock-screen-music-widget { flex: 1.3; }

/* 第三行布局 */
#lock-screen-notification-widget {
    width: 100%;
    flex-direction: row;
    align-items: center;
    gap: 12px;
    font-size: 15px; /* 稍微增大字体 */
    opacity: 0.9;
    min-height: 50px; /* 新增：增加最小高度 */
    padding: 0 15px;  /* 新增：增加左右内边距 */
    overflow: hidden; /* 新增：隐藏滚出边界的文字 */
}

.lock-screen-footer {
    text-align: center;
    font-size: 14px;
    opacity: 0.8;
    padding: 10px 0;
}

/* 组件内部样式 */
.widget { display: flex; flex-direction: column; }
.widget-header { font-size: 14px; font-weight: 600; color: rgba(255, 255, 255, 0.8); margin-bottom: 8px; padding-bottom: 5px; border-bottom: 1px solid rgba(255, 255, 255, 0.2); }
.widget-header i { margin-right: 6px; }
.widget-content { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; }
.memo-content { font-size: 15px; line-height: 1.6; cursor: pointer; justify-content: flex-start; overflow-y: auto; }
.countdown-content { text-align: center; }
.countdown-days { font-size: 36px; font-weight: 700; }
.countdown-label { font-size: 13px; color: rgba(255, 255, 255, 0.8); margin-top: 4px; }
.placeholder-text { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; color: rgba(255, 255, 255, 0.7); }
#lock-screen-time-widget { font-weight: 600; text-align: center; font-size: 42px; line-height: 1.2; }
#lock-screen-date { font-size: 14px; opacity: 0.8; font-weight: normal; }
.music-content { text-align: center; }
#lock-screen-song-info { font-size: 14px; opacity: 0.9; }
.music-controls { margin-top: 10px; display: flex; justify-content: center; align-items: center; gap: 25px; font-size: 20px;}
.music-controls i { cursor: pointer; }
/* --- 新增：为置顶按钮添加激活样式 --- */
.pin-event-btn.active {
    color: var(--theme-primary); /* 使用主题绿色作为激活颜色 */
}
/* ========================================================== */
/* V-Final 新增: 锁屏消息滚动条动画 (V3-图标分离版) */
/* ========================================================== */
#lock-screen-notification-widget {
    width: 100%;
    min-height: 50px;
    padding: 0 15px;
    display: flex; /* 使用flex布局让图标和文字容器并排 */
    align-items: center; /* 垂直居中 */
    gap: 12px;
    font-size: 15px;
    opacity: 0.9;
}

#lock-screen-notification-widget > i {
    opacity: 0.8; /* 图标稍微淡一点 */
}

/* 这是新的滚动“轨道”，负责隐藏超出部分的文字 */
.notification-scroll-wrapper {
    flex-grow: 1; /* 占据剩余的所有宽度 */
    height: 1.5em; /* 限定滚动区域的高度为大约一行文字的高度 */
    overflow: hidden; /* 隐藏超出这个区域的文字 */
    position: relative;
}

/* 这是真正滚动的文字容器 */
#lock-screen-notification-text {
    position: absolute;
    width: 100%;
    animation-name: vertical-scroll;
    animation-timing-function: linear;
    animation-iteration-count: infinite;
    transform: translateY(100%); /* 默认位置在轨道下方 */
}

#lock-screen-notification-text div {
    padding-bottom: 20px;
    white-space: nowrap;
}

@keyframes vertical-scroll {
    from {
        transform: translateY(100%);
    }
    to {
        transform: translateY(-100%);
    }
}
/* --- 新的心声面板样式 (猫咪主题 - 硬编码颜色版) --- */
#heart-voice-panel {
    position: absolute;
    top: 60px;
    left: 50%;
    transform: translateX(-50%);
    width: 280px;
    background-color: #FFFBF5; /* 直接使用颜色 */
    border-radius: 16px;
    border: 2px solid #EAD9D5; /* 直接使用颜色 */
    box-shadow: 4px 4px 0px #EAD9D5; /* 直接使用颜色 */
    display: none;
    flex-direction: column;
    gap: 14px;
    padding: 18px 20px;
    z-index: 100;
}

.hv-item {
    display: flex;
    align-items: flex-start;
    font-size: 14px;
    padding-bottom: 12px;
    border-bottom: 1px dashed #EAD9D5; /* 直接使用颜色 */
}

.hv-item:last-child {
    border-bottom: none;
    padding-bottom: 0;
}

.hv-icon {
    font-size: 18px;
    margin-right: 12px;
    width: 20px;
    text-align: center;
    margin-top: -2px;
}

.hv-label {
    font-weight: 600;
    color: #7D6C65; /* 直接使用颜色 */
    flex-shrink: 0;
}

.hv-value {
    color: #A28F88; /* 直接使用颜色 */
    margin-left: 8px;
    line-height: 1.5;
}

#hv-jealousy {
    color: #FFB347; /* 直接使用颜色 */
    font-size: 16px;
    font-weight: bold;
    letter-spacing: 2px;
}
/* --- 新样式结束 --- */
/* --- 新增：为自动提取的标题和摘要添加样式 --- */
.post-item h3 {
    margin-top: 0;
    margin-bottom: 10px; /* 标题和摘要之间的间距 */
    font-size: 18px;     /* 标题字号 */
    font-weight: 600;    /* 标题加粗 */
    line-height: 1.4;
}

.post-summary {
    font-size: 15px;
    color: #666;        /* 摘要文字颜色 */
    margin: 0;
    /* 以下三行用于摘要文字过多时，显示省略号 */
    display: -webkit-box;
    -webkit-line-clamp: 2; /* 最多显示2行 */
    -webkit-box-orient: vertical;
    overflow: hidden;
}
/* --- 新增/修改：作者与时间戳同行并两端对齐的样式 --- */

/* 这是新的容器样式 */
.post-card-meta-line {
    display: flex;                /* 启用 Flex 布局 */
    justify-content: space-between; /* 核心：让内部元素两端对齐 */
    align-items: center;          /* 垂直居中，防止高低不平 */
    margin: 12px 0;               /* 保持和上下元素的间距 */
}

/* 这是修改后的作者信息样式 */
.post-author-info {
    font-size: 14px;
    color: #888;
    margin: 0; /* 移除它自己的上下边距，交给父容器管理 */
}

/* 确保时间戳本身也没有多余的边距 */
.post-item .post-meta {
    margin: 0;
}
/* 新增的代码 */
.diary-entry.selected {
    background-color: #bde0fe; /* 选中后变成淡蓝色 */
}
.diary-select-checkbox {
    margin-right: 15px; /* 复选框和文字之间留点空隙 */
    transform: scale(1.3); /* 把复选框放大一点，方便点击 */
}
/* --- 新增：被窥探App内容的独立页面样式 --- */
#snooped-app-content-screen {
    position: absolute; /* 使其能覆盖整个屏幕 */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #f0f2f5; /* 背景色可以根据喜好调整 */
    display: none; /* 默认隐藏 */
    flex-direction: column; /* 垂直布局：顶部栏 + 内容区 */
}

/* 内容区域样式调整 (可以复用或微调 .api-content) */
#snooped-app-content-body {
    flex-grow: 1; /* 占据剩余所有空间 */
    overflow-y: auto; /* 内容过多时可滚动 */
    padding: 10px; /* 内边距 */
}
/* --- 修改后：模仿微信聊天气泡的【微信专属】样式 --- */

.snoop-wechat-chat-container { /* <--- 类名已修改 */
    font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Microsoft YaHei", sans-serif;
    background-color: #ebebeb; /* 聊天背景色 */
    border-radius: 12px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    margin-bottom: 20px;
}

.snoop-wechat-header { /* <--- 类名已修改 */
    padding: 8px 12px;
    background-color: #f7f7f7;
    border-bottom: 1px solid #e0e0e0;
    flex-shrink: 0;
    text-align: center;
}
.snoop-wechat-header .contact-name { /* <--- 类名已修改 */
    font-size: 14px;
    font-weight: 600;
    color: #111;
}

.snoop-wechat-area { /* <--- 类名已修改 */
    flex-grow: 1;
    overflow-y: auto;
    padding: 8px;
    max-height: 50vh;
}
.snoop-wechat-area::-webkit-scrollbar { /* <--- 类名已修改 */
    width: 3px;
}
.snoop-wechat-area::-webkit-scrollbar-thumb { /* <--- 类名已修改 */
    background: #dcdcdc;
    border-radius: 2px;
}

.snoop-wechat-timestamp { /* <--- 类名已修改 */
    text-align: center;
    margin: 8px 0;
}
.snoop-wechat-timestamp span { /* <--- 类名已修改 */
    background-color: #dcdcdc;
    color: #fff;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 4px;
}

.snoop-wechat-row { /* <--- 类名已修改 */
    display: flex;
    margin-bottom: 10px;
    max-width: 85%;
}
.snoop-wechat-row.sent { /* <--- 类名已修改 */
    justify-content: flex-end;
    margin-left: auto;
}
.snoop-wechat-row.received { /* <--- 类名已修改 */
    justify-content: flex-start;
    margin-right: auto;
}

.snoop-wechat-bubble { /* <--- 类名已修改 */
    padding: 6px 9px;
    border-radius: 6px;
    font-size: 13px;
    line-height: 1.5;
    word-wrap: break-word;
    word-break: break-all;
}

.snoop-wechat-bubble.received { /* <--- 类名已修改 */
    background-color: #fff;
    color: #111;
}
.snoop-wechat-bubble.sent { /* <--- 类名已修改 */
    background-color: #95ec69; /* 微信绿色气泡 */
    color: #111;
}
/* --- 微信专属样式结束 --- */
/* --- 扩大顶栏右上角按钮的触摸范围 --- */
.app-header .action-btn,
.chat-header .action-btn,
.world-book-header .action-btn,
.api-header .action-btn, /* 假设API header右侧按钮也用了action-btn */
.moments-header .action-btn,
.preset-management-screen .api-header .action-btn { /* 包括预设管理页面的+按钮 */
    /* 增加内边距，上下左右各加 10px */
    padding: 10px;

    /* 为了抵消padding增加的空间，防止布局错乱，
       同时使用等值的负外边距把它“拉回来” */
    margin: -10px;

    /* 如果按钮之间原本有左右margin，可能需要微调这里的负margin值
       或者在下面的规则里稍微调整按钮间的间距 */
}

/* （可选）如果上面的修改导致按钮挤在一起，可以微调按钮之间的间距 */
.header-actions .action-btn,
.app-header > div:last-child .action-btn {
    /* 稍微增加一点左边距，让按钮之间分开点 */
    margin-left: 5px;
    /* 抵消上面设置的水平方向负外边距 */
     margin-right: -10px;
     margin-top: -10px;
     margin-bottom: -10px;
}

/* 确保按钮的容器有足够空间 */
.app-header > div:last-child,
.chat-header > div:last-child,
.world-book-header > div,
.api-header > div:last-child,
.moments-header .header-actions {
     /* 可能需要给容器加一点右内边距，防止按钮被挤出屏幕 */
     /* padding-right: 5px; */
}
/* --- 新增：模仿 iOS/Android 原生短信气泡样式 --- */

/* 1. 聊天区域背景改为白色 */
.snoop-sms-area {
    background-color: #ffffff; /* 白色背景 */
    padding: 10px; /* 稍微增加内边距 */
}

/* 2. 气泡基础样式：更大的圆角 */
.snoop-sms-bubble {
    padding: 8px 12px; /* 调整内边距 */
    border-radius: 18px; /* 更圆的圆角，形成胶囊状 */
    max-width: 80%; /* 限制最大宽度，防止气泡过长 */
    line-height: 1.4; /* 调整行高，让文字更舒适 */
    box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05); /* 添加非常细微的阴影增加质感 */
}

/* 3. 收到的消息气泡 (左侧，灰色) */
.snoop-sms-bubble.received {
    background-color: #E5E5EA; /* iOS 系统灰色 */
    color: #000000; /* 黑色文字 */
}

/* 4. 发送的消息气泡 (右侧，蓝色) */
.snoop-sms-bubble.sent {
    background-color: #0B81FF; /* iOS 系统蓝色 (比默认#007AFF稍亮一点) */
    color: #ffffff; /* 白色文字 */
}

/* 5. 时间戳样式：居中，灰色小字，无背景 */
.snoop-sms-timestamp span {
    background-color: transparent; /* 去掉背景 */
    color: #8A8A8E; /* iOS 时间戳灰色 */
    font-size: 11px; /* 调小字号 */
    padding: 0; /* 去掉内边距 */
    border-radius: 0; /* 去掉圆角 */
}
.snoop-sms-timestamp {
    text-align: center;
    margin: 15px 0 10px; /* 调整时间戳的上下间距 */
}

/* 6. (可选) 简化顶部标题栏，更接近原生风格 */
.snoop-sms-header {
    background-color: #f8f8f8; /* 非常浅的灰色背景 */
    border-bottom: 1px solid #dcdcdc; /* 稍浅的边框线 */
    padding: 10px 15px; /* 调整内边距 */
}
.snoop-sms-header .contact-name {
     font-size: 16px; /* 稍微增大字号 */
     font-weight: 600; /* 加粗 */
     color: #000; /* 黑色标题 */
}

/* 7. (可选) 调整消息行间距 */
.snoop-sms-row {
    margin-bottom: 8px; /* 稍微减小消息之间的垂直间距 */
}

/* --- iOS/Android 原生短信样式结束 --- */
/* --- 确保这段短信【行布局】样式存在且正确 --- */

.snoop-sms-row { /* 检查这个类名是否正确 */
    display: flex;       /* 必须是 flex 才能让气泡正确排列 */
    margin-bottom: 10px; /* 控制行间距 */
    max-width: 85%;      /* 限制整行的最大宽度 */
}
.snoop-sms-row.sent { /* 检查这个类名是否正确 */
    justify-content: flex-end; /* 让发送的气泡内容靠右 */
    margin-left: auto;         /* 整行靠右 */
}
.snoop-sms-row.received { /* 检查这个类名是否正确 */
    justify-content: flex-start; /* 让接收的气泡内容靠左 */
    margin-right: auto;        /* 整行靠左 */
}
/* --- 短信行布局样式结束 --- */
/* --- 新增：窥探模式照片图标样式 V5 (两列，文字悬浮) --- */

.snoop-photo-grid {
    display: grid;
    /* 每行显示 2 个图标 */
    grid-template-columns: repeat(2, 1fr);
    gap: 5px; /* 图标之间的间距 */
    column-gap: 5px;
    padding: 5px; /* 网格区域的内边距 */
}

.snoop-photo-item-container {
    position: relative; /* 让详情文字能相对于它定位 */
    display: flex;
    justify-content: center; /* 图标水平居中 */
}

.snoop-photo-item {
    width: 150px; /* 图标背景宽度 (增大) */
    height: 200px; /* 图标背景高度 (增大) */
    background-color: rgba(255, 255, 255, 0.8); /* 半透明白色背景 */
    backdrop-filter: blur(5px); /* 背景模糊效果 */
    border-radius: 18px; /* 更大的圆角 */
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
    box-shadow: 0 3px 8px rgba(0,0,0,0.1); /* 添加一点阴影 */
    overflow: hidden; /* 防止内部元素溢出 */
}

.snoop-photo-item:hover {
    transform: scale(1.05) translateY(-3px); /* 悬浮时放大上移 */
    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}

.snoop-photo-item i {
    font-size: 48px; /* 图标大小 (增大) */
    color: #55758a; /* 图标颜色 (更柔和) */
    opacity: 0.8;
}

.snoop-photo-details {
    display: none;
    position: absolute;
    bottom: 10px; /* 仍然定位在容器底部偏上 */
    left: 50%;
    transform: translateX(-50%);
    width: calc(100% - 10px); /* 宽度仍然比容器窄一点 */
    max-width: 140px;        /* 最大宽度也稍微小于图标 (图标是120px) */
    /* --- 核心修改在这里 --- */
    height: 190px;           /* 设置一个固定的高度 (比图标120px略小) */
    overflow-y: auto;        /* 当内容超出高度时，允许垂直滚动 */
    /* --- 修改结束 --- */
    background-color: rgba(40, 40, 40, 0.85);
    backdrop-filter: blur(8px);
    color: #ffffff;
    border-radius: 10px;
    padding: 8px 10px; /* 稍微减小一点内边距，给滚动条留空间 */
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    font-size: 13px;
    line-height: 1.5;
    word-wrap: break-word;
    word-break: break-all;
    z-index: 10;
    pointer-events: auto; /* 改回 auto，允许用户滚动 */
}

.snoop-photo-details p {
    margin: 0 0 6px 0;
}
.snoop-photo-details p:last-child {
    margin-bottom: 0;
}

/* 当details可见时应用的样式 */
.snoop-photo-details.visible {
    display: block;
    /* 动画：从下方轻微弹出并淡入 */
    animation: popUpDetails 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

@keyframes popUpDetails {
    from { opacity: 0; transform: translateX(-50%) translateY(10px); }
    to { opacity: 1; transform: translateX(-50%) translateY(0); }
}

/* 之前为想法添加的样式 (thoughtStyle)，现在也应用到详情框内部 */
.snoop-photo-details .thought-style-div { /* 使用一个新类名 */
    font-size: 12px; /* 想法文字小一点 */
    color: #dcdcdc; /* 浅灰色文字 */
    background: rgba(255, 255, 255, 0.1); /* 更浅的背景 */
    padding: 6px 10px;
    border-radius: 6px;
    margin-top: 8px;
    border-left: 3px solid rgba(255, 255, 255, 0.3);
}
.snoop-photo-details .thought-style-div.reason-private { /* 私密原因用不同颜色 */
    background: rgba(255, 128, 171, 0.15);
    border-left-color: rgba(255, 128, 171, 0.5);
    color: #ffdde8;
}
/* --- 照片图标样式 V5 结束 --- */
/* --- 新增：窥探模式音乐歌单样式 V5 (模仿截图 + 右侧信息) --- */

.snoop-music-list {
    padding: 0;
}

.snoop-music-item {
    display: flex;
    align-items: center;
    padding: 8px 15px;
    border-bottom: 1px solid #f0f0f0;
    transition: background-color 0.2s;
}

.snoop-music-item:last-child {
    border-bottom: none;
}

.snoop-music-item:hover {
    background-color: rgba(0, 0, 0, 0.04);
}

.snoop-music-index {
    font-size: 14px;
    color: #999;
    width: 30px;
    text-align: center;
    flex-shrink: 0;
    margin-right: 10px;
}

.snoop-music-cover {
    width: 45px;
    height: 45px;
    background-color: #eee;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 12px;
    flex-shrink: 0;
    overflow: hidden;
}
.snoop-music-cover i {
    color: #bbb;
    font-size: 20px;
}

.snoop-music-info {
    flex-grow: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.snoop-music-title {
    font-size: 15px;
    font-weight: 500; /* 可以改为 600 让标题加粗，更容易区分 */
    color: #333;
    /* --- 核心修改：允许换行 --- */
    white-space: normal; /* 允许正常换行 */
    overflow: visible;   /* 内容超出时不隐藏 */
    text-overflow: clip; /* 内容超出时不显示省略号 */
    /* --- 修改结束 --- */
    line-height: 1.4; /* 可以适当增加行高，让多行文字不挤 */
    margin-bottom: 2px; /* 稍微增加和艺术家名字的间距 */
    /* (可选) 限制最多显示两行，超出部分隐藏，防止极端情况 */
    display: -webkit-box;
    -webkit-line-clamp: 2; /* 最多显示 2 行 */
    -webkit-box-orient: vertical;
    overflow: hidden; /* 配合上面三行，隐藏超出部分 */
    text-overflow: ellipsis; /* 超出两行时仍然显示省略号 */
    word-break: break-all; /* 允许在任意字符处换行，防止长英文单词溢出 */
}

.snoop-music-artist {
    font-size: 12px;
    color: #888;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    line-height: 1.2;
}

/* --- 新增/修改：右侧元信息样式 --- */
.snoop-music-meta-right {
    margin-left: auto; /* 推到最右侧 */
    padding-left: 10px; /* 和文字之间留空隙 */
    font-size: 11px;    /* 小字号 */
    color: #aaa;       /* 浅灰色 */
    flex-shrink: 0;   /* 防止被压缩 */
    text-align: right;  /* 右对齐 */
    display: flex;      /* 允许内部元素排列 */
    flex-direction: column; /* 垂直排列 */
    align-items: flex-end; /* 右对齐 */
}

.snoop-music-meta-right span {
    white-space: nowrap; /* 防止换行 */
}

/* 如果有时长，平台信息需要换行显示 */
.snoop-music-meta-right .snoop-music-platform.new-line {
    margin-top: 2px; /* 增加一点垂直间距 */
}

.snoop-music-platform {
    font-style: italic; /* 平台名斜体 */
}
/* --- 新增：窥探模式音乐想法样式 --- */

.snoop-music-thought {
    font-size: 11px; /* 比艺术家字体更小 */
    color: #a0a0a0; /* 更浅的灰色 */
    margin-top: 4px; /* 和艺术家之间留点距离 */
    /* (可选) 允许换行并最多显示两行 */
    white-space: normal;
    display: -webkit-box;
    -webkit-line-clamp: 5;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
    line-height: 1.3;
    font-style: italic; /* 斜体 */
}

/* --- 音乐想法样式结束 --- */
/* --- 音乐歌单样式 V5 结束 --- */
/* --- 银行卡样式 (恢复 V4 渐变版) --- */
.snoop-bank-cards-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 10px;
    margin-bottom: 20px;
}

.snoop-bank-card {
    /* 使用线性渐变背景 */
    background: linear-gradient(135deg, #f5f7fa, #e0e5ec);
    border-radius: 8px;
    padding: 12px 15px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    border: 1px solid #d1d9e6; /* 保持一个细边框 */
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    min-height: 80px;
}

.snoop-bank-card-name {
    font-size: 13px;
    color: #555;
    font-weight: 500;
    margin-bottom: 8px;
}

.snoop-bank-card-balance {
    font-size: 18px; /* 余额字体比 V5 略小 */
    font-weight: bold;
    color: #333;
    text-align: right;
}
/* --- 银行卡样式结束 --- */

/* --- 新增：窥探模式资产样式 V6 (表格投资 + 银行流水) --- */

/* 投资列表 V6 样式 */
.snoop-investments-list-v6 {
    background-color: #ffffff; /* 白色背景 */
    border-radius: 8px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    overflow: hidden; /* 隐藏内部边框溢出 */
    margin-bottom: 25px;
}

/* 投资表头 */
.snoop-investment-header-row {
    display: grid;
    /* 定义四列的宽度比例，名称列最宽 */
    grid-template-columns: 2fr 1fr 1fr 1fr;
    background-color: #f7f9fa; /* 浅灰色表头背景 */
    padding: 8px 15px;
    font-size: 11px; /* 表头字号 */
    color: #8899a6; /* 表头颜色 */
    font-weight: 500;
    border-bottom: 1px solid #e1e8ed; /* 表头下边框 */
}
/* 列标题右对齐 */
.snoop-investment-header-row > div:not(:first-child) {
    text-align: right;
}

/* 单个投资项 V6 */
.snoop-investment-item-v6 {
    display: grid;
    grid-template-columns: 2fr 1fr 1fr 1fr; /* 与表头一致的列宽 */
    padding: 10px 15px;
    border-bottom: 1px solid #f0f0f0; /* 项之间的分隔线 */
    font-size: 13px; /* 统一基础字号 */
    align-items: center; /* 垂直居中 */
}
.snoop-investment-item-v6:last-child {
    border-bottom: none; /* 最后一项无分隔线 */
}

/* 投资项 - 名称/金额列 */
.inv-col-name {
    display: flex;
    flex-direction: column; /* 垂直排列 */
}
.inv-name {
    font-weight: 600; /* 名称加粗 */
    color: #222;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    line-height: 1.3;
}
.inv-type {
    font-size: 10px;
    color: #667;
    margin-left: 4px; /* 类型和名称间距 */
}
.inv-value {
    font-size: 11px;
    color: #778;
    margin-top: 1px;
}
.inv-percentage {
    font-size: 10px;
    color: #99a;
    margin-top: 1px;
}

/* 投资项 - 收益列 (统一右对齐) */
.inv-col-daily,
.inv-col-holding,
.inv-col-cumulative {
    text-align: right;
    font-weight: 600; /* 收益数字加粗 */
    font-size: 13px; /* 统一字号 */
}
/* 盈亏颜色 */
.profit { color: #f44336; } /* 红涨 */
.loss { color: #4caf50; } /* 绿跌 */
.neutral { color: #757575; } /* 灰色 */

/* 交易流水列表 V6 样式 */
.snoop-transactions-list-v6 {
    display: flex;
    flex-direction: column;
    /* 移除 gap，边框作为分隔 */
    background-color: #ffffff; /* 背景 */
    border-radius: 8px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    overflow: hidden; /* 隐藏内部边框溢出 */
}

/* 单条交易流水 V6 */
.snoop-transaction-item-v6 {
    display: flex; /* 横向布局 */
    justify-content: space-between; /* 两端对齐 */
    align-items: center; /* 垂直居中 */
    padding: 12px 15px; /* 内边距 */
    border-bottom: 1px solid #f0f0f0; /* 分隔线 */
}
.snoop-transaction-item-v6:last-child {
    border-bottom: none;
}

/* 流水左侧信息区 */
.tx-left {
    display: flex;
    flex-direction: column; /* 上下排列 */
    min-width: 0; /* 防止内容溢出 */
    margin-right: 15px; /* 和右侧金额留空隙 */
}
.tx-desc {
    font-size: 14px; /* 主要描述字号 */
    color: #222; /* 主要颜色 */
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 单行省略 */
    margin-bottom: 3px;
}
.tx-subdesc {
    font-size: 11px; /* 次要信息字号 */
    color: #999; /* 灰色 */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 单行省略 */
}

/* 流水右侧金额区 */
.tx-amount {
    font-size: 16px; /* 金额字号 */
    font-weight: bold; /* 加粗 */
    flex-shrink: 0; /* 防止被压缩 */
    white-space: nowrap; /* 防止金额换行 */
}
.tx-amount.income { color: #f44336; } /* 收入红色 */
.tx-amount.expense { color: #4caf50; } /* 支出绿色 */
.tx-amount.expense::before { content: "-"; } /* 支出自动加负号 */
.tx-amount.income::before { content: "+"; } /* 收入自动加正号 */

/* --- 资产样式 V6 结束 --- */
/* ========================================================== */
/* ▼▼▼ 新增：短信聊天界面专属样式 (模仿窥探模式) ▼▼▼ */
/* ========================================================== */

/* 1. 短信聊天区域背景 (已在HTML的style中设置，这里留空备用) */
#sms-chat-messages {
    /* background-color: #ffffff; */
    padding: 10px; /* 稍微增加内边距 */
}

/* 2. 短信时间戳样式 (复用窥探模式) */
.sms-timestamp { /* 新类名 */
    text-align: center;
    margin: 15px 0 10px;
}
.sms-timestamp span {
    background-color: transparent;
    color: #8A8A8E; /* iOS 时间戳灰色 */
    font-size: 11px;
    padding: 0;
    border-radius: 0;
}

/* 3. 短信消息行布局 (复用窥探模式，注意类名修改) */
.sms-row { /* 新类名 */
    display: flex;
    margin-bottom: 8px;
    max-width: 85%;
}
.sms-row.sent {
    justify-content: flex-end;
    margin-left: auto;
}
.sms-row.received {
    justify-content: flex-start;
    margin-right: auto;
}

/* 4. 短信气泡样式 (复用窥探模式，注意类名修改) */
.sms-bubble { /* 新类名 */
    padding: 8px 12px;
    border-radius: 18px; /* 更圆的圆角 */
    max-width: 100%; /* 让气泡自己决定宽度，由 .sms-row 控制最大宽度 */
    line-height: 1.4;
    box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
    word-wrap: break-word;
    word-break: break-all;
    font-size: 15px; /* 可以根据喜好调整字号 */
}
.sms-bubble.received {
    background-color: #E5E5EA; /* iOS 系统灰色 */
    color: #000000;
}
.sms-bubble.sent {
    background-color: #0B81FF; /* iOS 系统蓝色 */
    color: #ffffff;
}

/* 5. 短信图片样式 (简化版) */
.sms-bubble.image-message {
    padding: 0;
    background-color: transparent;
    box-shadow: none;
    max-width: 150px; /* 限制图片最大宽度 */
    overflow: hidden; /* 图片超出圆角部分隐藏 */
}
.sms-image {
    display: block; /* 消除图片下方的空隙 */
    max-width: 100%;
    height: auto;
    border-radius: 16px; /* 给图片也加上圆角 */
}

/* (可选) 短信输入区域微调 */
#sms-input-area {
    border-top: 1px solid #dcdcdc; /* 顶部边框线 */
}
#sms-message-input {
    /* ... 你可能已有的样式，比如 background-color, border ... */
    flex-grow: 1; /* 占据尽可能多的空间 */
    border-radius: 20px;
    padding: 8px 15px;
    font-size: 15px; /* 和主聊天输入框一致 */
    outline: none;
    resize: none; /* 禁止用户手动拖动调整大小 */
    overflow-y: auto; /* 内容超出时显示滚动条 */
    max-height: 100px; /* 最大高度，比如 100px */
    min-height: 38px; /* 最小高度，和主聊天输入框一致 */
    align-self: flex-end; /* 垂直方向底部对齐 */
    /* 确保背景色和边框符合短信风格 */
    background-color: white;
    border: 1px solid #dcdcdc;
}
/* --- 新增：模仿 iOS 原生短信顶栏样式 --- */
#sms-chat-screen .app-header {
    background-color: #f7f7f7; /* 非常浅的灰色背景 */
    backdrop-filter: none; /* 移除模糊效果 */
    color: #000000; /* 标题文字改为黑色 */
    border-bottom: 1px solid #dcdcdc; /* 添加底部细线 */
    box-shadow: none; /* 移除阴影 */
}

/* (可选) 让返回按钮也变成黑色 */
#sms-chat-screen .app-header .back-btn i {
    color: #000000;
}
/* --- 新增：短信编辑模式样式 --- */

/* 标记被选中的短信行 */
#sms-chat-messages .sms-row.selected {
    background-color: #e0f2fe; /* 淡蓝色背景 */
    border-radius: 8px; /* 加点圆角 */
}

/* 当进入编辑模式时，隐藏输入框，显示编辑栏 */
#sms-chat-screen.sms-edit-mode #sms-input-area {
    display: none;
}
#sms-chat-screen.sms-edit-mode #sms-edit-mode-bar {
    display: flex !important; /* 改为 flex 以显示 */
}
/* ========================================================== */
/* ▲▲▲ 新增：短信聊天界面专属样式 END ▲▲▲ */
/* ========================================================== */
/* --- 新增：收藏夹页面样式 --- */
#favorites-screen .api-content {
    padding: 10px;
}

.favorite-group-card {
    background-color: #ffffff;
    border-radius: var(--soft-radius);
    box-shadow: 0 2px 8px var(--shadow-color);
    margin-bottom: 15px;
    overflow: hidden; /* 裁剪内部元素的边角 */
}

.favorite-group-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
    background-color: #fcfcfc;
}

.favorite-group-header img {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    margin-right: 10px;
}

.favorite-group-header .name {
    font-weight: 600;
    color: var(--text-dark);
}

/* 收藏的单条消息样式 */
.favorite-item {
    display: flex;
    align-items: flex-start; /* 头像置顶 */
    padding: 15px;
    border-bottom: 1px solid #f0f0f0;
    position: relative;
    transition: background-color 0.2s;
}
.favorite-item:hover {
    background-color: #f9f9f9;
}
.favorite-item:last-child {
    border-bottom: none;
}

.favorite-item-avatar img {
    width: 40px;
    height: 40px;
    border-radius: 6px;
    margin-right: 12px;
}

.favorite-item-content {
    flex-grow: 1;
    padding-right: 30px; /* 为删除按钮留出空间 */
}

.favorite-item-sender {
    font-weight: 500;
    color: var(--theme-primary-hover);
    margin-bottom: 5px;
}

.favorite-item-content .message-content {
    font-size: 15px;
    line-height: 1.6;
    color: var(--text-dark);
    word-wrap: break-word; /* 确保长文本能换行 */
}
/* 收藏内容里的叙事样式 (可选，但推荐) */
.favorite-item-content .message-content .narrative-psychology {
    background-color: #f0f0f0;
    color: #555;
    padding: 1px 4px;
    border-radius: 4px;
}

/* 取消收藏按钮 */
.unfavorite-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 16px;
    color: #aaa;
    cursor: pointer;
    padding: 5px;
}
.unfavorite-btn:hover {
    color: var(--soft-red);
}
/* --- 收藏夹样式 V2 (按次分组版) --- */

.favorite-group-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
    background-color: #fcfcfc;
}

/* 收藏卡片头部的时间戳 */
.favorite-group-header .timestamp {
    font-size: 12px;
    color: var(--text-gray);
    margin-left: auto; /* 推到右边 */
    padding-right: 10px; /* 和删除按钮拉开距离 */
}

/* ✨ 核心修改：删除按钮样式 */
.unfavorite-btn {
    position: static; /* 移除绝对定位 */
    font-size: 18px;  /* 稍微放大 */
    color: #bbb;     /* 默认更灰 */
    cursor: pointer;
    padding: 5px;
    margin-left: 5px; /* V2 新增 */
}
.unfavorite-btn:hover {
    color: var(--soft-red);
}

/* (这个不用动，保持原样) */
.favorite-item-content .message-content {
    font-size: 15px;
    line-height: 1.6;
    color: var(--text-dark);
    word-wrap: break-word; 
}
/* ✨ 核心修改：移除单个消息的删除按钮 */
.favorite-item .unfavorite-btn {
    display: none; /* 隐藏掉消息条目内部的旧按钮 */
}
/* --- 聊天记录搜索界面样式 --- */
#chat-search-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #f7f7f7; /* 微信风格浅灰背景 */
    z-index: 1100; /* 确保在最上层 */
    display: flex;
    flex-direction: column;
}

.search-header {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    background-color: #fff;
    border-bottom: 1px solid #e0e0e0;
    flex-shrink: 0;
}

.search-input-wrapper {
    flex-grow: 1;
    background-color: #f0f2f5;
    border-radius: 6px;
    padding: 6px 10px;
    display: flex;
    align-items: center;
    margin-right: 10px;
}

.search-icon {
    color: #999;
    margin-right: 8px;
    font-size: 14px;
}

#chat-search-input {
    flex-grow: 1;
    border: none;
    background: transparent;
    font-size: 15px;
    outline: none;
    padding: 0;
}

.clear-search-btn {
    color: #ccc;
    cursor: pointer;
    padding: 5px; /* 增加一点点击范围 */
}

#close-search-btn {
    background: none;
    border: none;
    color: var(--theme-primary); /* 使用主题色 */
    font-size: 16px;
    cursor: pointer;
    padding: 5px 0;
}

#search-results-container {
    flex-grow: 1;
    overflow-y: auto;
    background-color: #fff;
}

.search-placeholder {
    text-align: center;
    color: #999;
    margin-top: 50px;
    font-size: 14px;
}

.search-result-item {
    padding: 12px 15px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    flex-direction: column;
    cursor: pointer;
    transition: background-color 0.2s;
}

.search-result-item:hover {
    background-color: #f9f9f9;
}

.result-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 6px;
    font-size: 13px;
}

.result-sender {
    font-weight: 600;
    color: #333;
}

.result-time {
    color: #bbb;
    font-size: 12px;
}

.result-content {
    font-size: 15px;
    color: #666;
    line-height: 1.4;
    /* 超出两行显示省略号 */
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 高亮关键词样式 */
.highlight-keyword {
    color: var(--theme-primary);
    font-weight: bold;
}
/* --- 步骤 2：在气泡旁边添加“撤回”按钮的样式 --- */
.recall-btn {
    position: absolute;
    top: calc(50% + 14px); /* 把它定位到“回复”按钮的下方 14px */
    transform: translateY(-50%); /* 垂直居中（以它自己的top点为基准）*/
    
    background-color: rgba(240, 240, 240, 0.8);
    backdrop-filter: blur(2px);
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: var(--soft-red); /* 撤回按钮用醒目的红色 */
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    
    opacity: 0; /* 默认隐藏 */
    transition: opacity 0.2s ease, transform 0.2s ease;
    pointer-events: none; /* 隐藏时不可点击 */
}

/* --- 步骤 3：调整一下原来的“回复”按钮，给新按钮腾地方 --- */
.reply-btn {
    top: calc(50% - 14px); /* 把“回复”按钮向上移动 14px */
}

/* --- 步骤 4：当悬浮时，让两个按钮一起显示出来 --- */
.message-wrapper.sent.show-reply-btn .reply-btn,
.message-wrapper.sent.show-reply-btn .recall-btn {
    opacity: 1;
    transform: translateY(-50%) scale(1); /* 恢复原来的动画效果 */
    pointer-events: auto;
}
/* AI发的消息（received）不需要改，它只显示回复按钮 */
.message-wrapper.received.show-reply-btn .reply-btn {
     opacity: 1;
     transform: translateY(-50%) scale(1);
     pointer-events: auto;
}

/* --- 步骤 5：调整两个按钮的悬浮放大效果 --- */
.message-wrapper.sent.show-reply-btn .reply-btn:hover {
     transform: translateY(-50%) scale(1.1) !important;
}
.message-wrapper.sent.show-reply-btn .recall-btn:hover {
     transform: translateY(-50%) scale(1.1) !important;
}
/* --- AI“表演式”撤回消息的样式 (V3 - 统一居中版) --- */

/* 1. 这是“未点开”的占位符样式 (保持不变) */
.system-notification.recall-ai-placeholder {
    background-color: #e0e0e0; 
    color: #888;
    font-style: italic;
    cursor: pointer; 
    user-select: none;
    transition: background-color 0.2s, color 0.2s;
}
.system-notification.recall-ai-placeholder:hover {
    background-color: #d5d5d5;
    color: #555;
}

/* 2. 这是被“点开后”的样式 (新版：居中、带红条) */
.system-notification.recall-ai-revealed {
    background-color: #f5f5f5;      /* 1. 浅灰背景 */
    color: #444;                   /* 2. 正常文字颜色 */
    font-style: normal;             /* 3. 恢复正常字体 */
    cursor: pointer;                /* 4. 保持可点击（为了能关上） */
    text-shadow: none;              /* 5. 确保没有模糊 */
    //border-top: 2px solid var(--soft-red); /* 6. 顶部加个红条 */
    //border-bottom: 2px solid var(--soft-red); /* 7. 底部也加个红条 */
    text-align: center;               /* 8. 内部文字还是左对齐好看 */
    display: inline-block;          /* 9. 让它根据内容自适应宽度 */
    max-width: 80%;                 /* 10. 防止太长 */
    box-sizing: border-box;         /* 11. 确保padding不会撑爆 */
}

/* 3. “点开后”显示的前缀 (新版：目标是新class) */
.system-notification.recall-ai-revealed .recall-prefix {
    font-weight: bold;
    color: var(--soft-red);
    margin-right: 5px;
    text-align: center;
}
/* --- 新增：为“中国红”刮刮乐添加专属样式 --- */
#scratch-grid-display.game-china-red {
    display: flex; /* 改为 flex 布局 */
    flex-direction: column; /* 垂直排列 */
    gap: 15px;
    background-color: #fff; /* 白色底板 */
    border: 2px solid #f44336; /* 红色边框 */
    border-radius: 8px;
    padding: 15px;
}
.china-red-area h3 {
    font-size: 14px;
    color: #333;
    margin: 0 0 8px 0;
    text-align: left;
    padding-bottom: 5px;
    border-bottom: 1px dashed #f44336;
}
.winning-numbers-grid {
    display: flex;
    justify-content: center;
    gap: 15px;
}
.your-numbers-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr); /* 你的号码区，一行4个 */
    gap: 8px;
}
.scratch-cell-winner {
    background: #fffbe6; /* 浅黄色背景 */
    border: 2px solid #fdd835; /* 黄色边框 */
    color: #c62828; /* 红色数字 */
    font-weight: bold;
    font-size: 20px;
    width: 50px;
    height: 50px;
    border-radius: 50%; /* 圆形 */
    display: flex;
    align-items: center;
    justify-content: center;
}
.scratch-cell-player {
    background: #fce4e4; /* 浅红色背景 */
    border-radius: 6px;
    padding: 5px;
    text-align: center;
    border: 2px solid transparent; /* 默认无边框 */
}
.scratch-cell-player.scratched.match {
    /* ✨ 匹配成功的号码高亮！ ✨ */
    border-color: #f44336;
    background: #fff;
    box-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
    transform: scale(1.05);
}
.player-number {
    font-size: 18px;
    font-weight: bold;
    color: #333;
}
.player-prize {
    font-size: 12px;
    color: #c62828;
    font-weight: 500;
}
/* --- 新增：刮刮乐“覆盖层”样式 --- */
.scratch-cell-player.covered {
    background: #bdbdbd; /* 灰色覆盖层 */
    border-color: #9e9e9e;
    cursor: pointer;
    position: relative;
    /* 强制重置 flex 布局，以便居中图标 */
    display: flex !important; 
    align-items: center !important;
    justify-content: center !important;
    transition: transform 0.2s, background-color 0.2s;
}
.scratch-cell-player.covered:hover {
    transform: scale(1.05);
    background: #b0b0b0;
}
/* 隐藏掉所有“内容”元素 */
.scratch-cell-player.covered .player-number,
.scratch-cell-player.covered .player-prize,
.scratch-cell-player.covered .symbol-content,
.scratch-cell-player.covered .cell-content {
    display: none;
}
/* 显示“刮开”图标 */
.scratch-cell-player.covered .scratch-icon {
    display: block;
    font-size: 24px;
    color: rgba(255, 255, 255, 0.7);
}
/* 刮开后（scratched）的状态 */
.scratch-cell-player.scratched {
    cursor: default;
}
/* 刮开后，隐藏图标 */
.scratch-cell-player.scratched .scratch-icon {
    display: none;
}
/* 刮开后，显示内容 */
.scratch-cell-player.scratched .player-number,
.scratch-cell-player.scratched .player-prize,
.scratch-cell-player.scratched .symbol-content,
.scratch-cell-player.scratched .cell-content {
    display: block; /* 显形！*/
}
/* 这个是内容占位符，默认不显示 */
.scratch-icon {
    display: none;
}
/* --- 样式结束 --- */
/* --- 新增：Koko交易所 - 标签页和新闻大屏样式 --- */
#stock-tabs-container .feed-tab-btn {
    font-size: 14px; /* 标签页字小一点 */
    padding: 8px 10px;
}
#stock-tabs-container .feed-tab-btn i {
    margin-right: 4px;
}

#stock-news-feed {
    /* display: flex !important;  <-- 删掉这行 */
    /* flex-direction: column-reverse !important; <-- 删掉这行 */
    background-color: #f7f9fa;
}
.news-item {
    padding: 6px 8px;
    margin-bottom: 4px;
    border-radius: 4px;
    line-height: 1.5;
    animation: fadeIn 0.5s ease; /* 消息淡入动画 */
}
.news-item.positive { /* 利好消息 (涨) */
    background-color: #fce4e4;
    border-left: 3px solid #f44336;
    color: #c62828;
}
.news-item.negative { /* 利空消息 (跌) */
    background-color: #e8f5e9;
    border-left: 3px solid #4caf50;
    color: #2e7d32;
}
.news-item.neutral { /* 中性消息 */
    background-color: #f5f5f5;
    border-left: 3px solid #90a4ae;
    color: #37474f;
}
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}
/* --- 样式结束 --- */
/* --- 新增：论坛帖子的图片样式 --- */
        .post-image-content {
            max-width: 100%; /* 图片最大宽度不超过帖子宽度 */
            max-height: 400px; /* 限制最大高度，防止图片过长 */
            border-radius: 12px;
            margin-top: 10px;
            object-fit: cover; /* 保持图片比例 */
            cursor: zoom-in; /* 提示可以点击（虽然我们还没做大图） */
        }
        /* --- 新增：评论区的图片样式 --- */
        .comment-image-content {
            max-width: 200px; /* 评论区的图小一点 */
            border-radius: 10px;
            margin-top: 8px;
            cursor: zoom-in;
        }
/* --- 新增：转发聊天记录卡片样式 --- */
.message.chat-history-card {
    background-color: #f7f7f7; /* 浅灰色背景 */
    border: 1px solid #e0e0e0;
    width: 260px; /* 固定宽度 */
    padding: 0; /* 移除默认内边距，让内部自己控制 */
    border-radius: 12px;
    overflow: hidden; /* 隐藏内部溢出的圆角 */
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    cursor: not-allowed; /* 暂时让它不可点击 */
}
.ch-header {
    padding: 10px 15px;
    font-size: 15px;
    font-weight: 600;
    color: var(--text-dark);
    border-bottom: 1px solid #e0e0e0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.ch-body {
    padding: 10px 15px;
    max-height: 200px; /* 限制最大高度，超出可滚动 */
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 4px; /* 消息间的最小间距 */
}
/* 卡片内部的迷你消息条目 */
.ch-item {
    font-size: 13px;
    line-height: 1.5;
    word-wrap: break-word;
}
.ch-sender {
    font-size: 12px;
    color: #888;
    margin-bottom: 2px;
}
.ch-bubble {
    display: inline-block; /* 让气泡自适应内容宽度 */
    max-width: 95%; /* 最大宽度 */
    padding: 6px 10px;
    border-radius: 10px;
}
/* 迷你-收到的气泡 */
.ch-item.received .ch-bubble {
    background-color: #ffffff;
    border-top-left-radius: 2px;
}
/* 迷你-发送的气泡 */
.ch-item.sent {
    align-self: flex-end; /* 自己发的消息靠右 */
    text-align: right;
}
.ch-item.sent .ch-bubble {
    background-color: var(--sent-message-bg, #e6f5c9);
    border-top-right-radius: 2px;
    text-align: left; /* 气泡内的文字还是左对齐 */
}
.ch-footer {
    padding: 6px 15px;
    font-size: 12px;
    color: #aaa;
    border-top: 1px solid #e8e8e8;
    background-color: #fdfdfd;
}
/* --- V-Final 新增: “我们的日子”精致卡片样式 --- */

/* 1. 让 #events-content-list 成为卡片容器 */
#events-content-list {
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 15px; /* 卡片之间的间距 */
}

/* 2. 新的卡片 .event-card 样式 */
.event-card {
    background-color: #ffffff;
    border-radius: 16px; /* 更圆润的圆角 */
    box-shadow: 0 4px 12px var(--shadow-color);
    border: 1px solid white;
    display: flex;
    align-items: stretch; /* 让左右两边一样高 */
    overflow: hidden; /* 隐藏溢出的边框 */
    position: relative; /* 为了定位按钮 */
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.event-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px var(--shadow-color);
}

/* 3. 卡片左侧的“倒计时”区域 */
.event-card-countdown {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 20px 25px;
    color: white;
    min-width: 100px;
    text-align: center;
}

.event-card-days {
    font-size: 36px;
    font-weight: 700;
    line-height: 1.1;
}

.event-card-label {
    font-size: 13px;
    font-weight: 500;
    opacity: 0.9;
}

/* 4. 卡片右侧的“信息”区域 */
.event-card-info {
    flex-grow: 1;
    padding: 18px 20px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    cursor: pointer; /* 提示可以点击编辑 */
}

.event-card-name {
    font-size: 18px;
    font-weight: 600;
    color: var(--text-dark);
    margin-bottom: 5px;
}

.event-card-date {
    font-size: 14px;
    color: var(--text-gray);
    margin-bottom: 8px;
}

.event-card-notes {
    font-size: 13px;
    color: #555;
    background-color: #f7f9fa;
    padding: 8px 10px;
    border-radius: 8px;
}

.event-card-notes:empty {
    display: none; /* 如果没有备注，就隐藏 */
}

/* 5. 卡片上的操作按钮 (复用 .preset-actions) */
.event-card-actions {
    position: absolute;
    top: 8px;
    right: 8px;
    display: flex;
    gap: 5px;
    background-color: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(4px);
    border-radius: 20px;
    padding: 2px;
}
.event-card-actions .preset-action-btn {
    font-size: 16px;
}

/* 6. 根据不同类型设置主题色 */

/* 纪念日 (红色) */
.event-card[data-type="anniversary"] .event-card-countdown {
    background-color: #ff8a80;
}
.event-card[data-type="anniversary"] .event-card-name {
    color: #c62828;
}

/* 生理期 (粉色) */
.event-card[data-type="period"] .event-card-countdown {
    background-color: #f06292;
}
.event-card[data-type="period"] .event-card-name {
    color: #ad1457;
}

/* 其他 (黄色) */
.event-card[data-type="custom"] .event-card-countdown {
    background-color: #ffee58;
    color: #555; /* 黄色背景用深色字 */
}
.event-card[data-type="custom"] .event-card-name {
    color: #a08c32;
}

/* --- 样式结束 --- */
/* --- V-Final 修复：“我们的日子”卡片按钮美化 --- */

/* 1. 修改操作区容器 (改为垂直排列) */
.event-card-actions {
    position: absolute;
    top: 10px; /* 稍微挪下来一点 */
    right: 10px; /* 稍微挪进来一点 */
    display: flex;
    
    /* --- 核心修改在这里 --- */
    flex-direction: column; /* 改为垂直排列 */
    /* --- 修改结束 --- */
    
    gap: 8px; /* 两个按钮之间拉开一点距离 */
    
    /* 移除这些旧样式 */
    background-color: transparent;
    backdrop-filter: none;
    border-radius: 0;
    padding: 0;
}

/* 2. 重新定义按钮本身 (变成小圆圈) */
.event-card-actions .preset-action-btn {
    width: 30px; /* 设定宽度 */
    height: 30px; /* 设定高度 */
    border-radius: 50%; /* 变圆 */
    
    background-color: rgba(0, 0, 0, 0.08); /* 默认用一个很淡的灰色底 */
    color: #555; /* 默认图标颜色深一点 */
    font-size: 13px; /* 图标小一点 */
    
    /* 覆盖 .preset-action-btn 的默认 padding */
    padding: 0; 
    
    /* 居中图标 */
    display: flex;
    align-items: center;
    justify-content: center;
    
    transition: all 0.2s ease;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

/* 3. 悬浮效果 (通用) */
.event-card-actions .preset-action-btn:hover {
    transform: scale(1.1);
    color: white; /* 悬浮时图标都变白 */
}

/* 4. 置顶按钮 (pin-event-btn) 的悬浮和激活样式 */
.event-card-actions .pin-event-btn:hover {
    background-color: var(--theme-primary-hover, #66bb6a);
}
.event-card-actions .pin-event-btn.active {
    background-color: var(--theme-primary, #81c784); /* 激活时用主题绿 */
    color: white; /* 白色图标 */
}

/* 5. 删除按钮 (delete-event-btn) 的悬浮样式 */
.event-card-actions .delete-event-btn:hover {
    background-color: var(--soft-red, #ff8a80); /* 悬浮时用主题红 */
    color: white; /* 白色图标 */
}

/* --- 修复结束 --- */
/* --- 新增：让系统消息在编辑模式下也能变蓝 --- */
.message-wrapper.system-wrapper.selected .system-notification {
    background-color: #bde0fe !important; /* 变成和其他选中项一样的淡蓝色 */
    color: #333 !important; /* 同时把文字变黑，不然看不清 */
}
/* --- 新增：修复输入框被长文本撑爆的问题 --- */
#message-input,
#comment-input,
#video-call-input,
#sms-message-input {
    /*
     * 这是一个经典的Flexbox修复。
     * 默认情况下, flex-grow: 1 的元素不会收缩到小于其内容的“最小宽度”。
     * 当输入一个很长的、不换行的字符串时, 它的“最小宽度”会变得非常大,
     * 导致它撑爆父容器 (display:flex), 把旁边的按钮挤出去。
     *
     * min-width: 0; 告诉浏览器：
     * "允许这个元素收缩到0, 忽略你内容的宽度, 
     * 然后再根据 flex-grow: 1 把它拉伸到所有可用的剩余空间。"
     * 这就保证了它永远不会撑爆容器。
     */
    min-width: 0;
}
/* ========================================================== */
/* ================== 海龟汤 游戏专属CSS ================== */
/* ========================================================== */

/* 游戏界面的根样式 */
#game-chat-screen {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    --color-user: #0b84ff;
    --color-ai: #34c759;     /* iOS 绿色 */
    --color-host: #ff453a;     /* iOS 红色 */
    --color-win: #ffcc00;     /* 胜利黄 */
}

/* 游戏聊天记录 */
#game-chat-log-wrapper.loading #game-puzzle-area-pinned {
    opacity: 0.5;
    text-align: center;
}

/* 游戏气泡样式 */
#game-chat-screen .message-wrapper { 
    display: flex; 
    max-width: 85%; 
    margin-bottom: 12px; 
    flex-direction: column;
    animation: gameFadeIn 0.3s ease-out;
}
@keyframes gameFadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}
#game-chat-screen .message-wrapper.user { align-self: flex-end; }
#game-chat-screen .message-wrapper.ai-player { align-self: flex-start; }
#game-chat-screen .message-wrapper.host { align-self: center; max-width: 95%; }

#game-chat-screen .sender-name {
    font-size: 13px;
    font-weight: 600;
    margin: 0 10px 4px 10px;
}
#game-chat-screen .message-wrapper.user .sender-name { color: var(--color-user); text-align: right; }
#game-chat-screen .message-wrapper.ai-player .sender-name { color: var(--color-ai); }
#game-chat-screen .message-wrapper.host .sender-name { color: var(--color-host); text-align: center; }

#game-chat-screen .message {
    padding: 10px 14px;
    border-radius: 18px;
    line-height: 1.5;
    word-wrap: break-word;
    font-size: 15px;
    color: #ffffff;
    width: fit-content;
}
#game-chat-screen .message-wrapper.user .message { 
    background-color: #0b84ff; 
    border-top-right-radius: 4px; 
    margin-left: auto;
}
#game-chat-screen .message-wrapper.ai-player .message { 
    background-color: #2c2c2e; 
    border-top-left-radius: 4px; 
    margin-right: auto;
}
#game-chat-screen .message-wrapper.host .message {
    background-color: #2c2c2e;
    border: 1px solid #3a3a3c;
    text-align: center;
    width: 100%;
    box-sizing: border-box;
}
/* 主持人回答(是/否) 和 最终答案 的样式 */
#game-chat-screen .message-wrapper.host .message.answer {
    background-color: #444;
    font-weight: bold;
}
#game-chat-screen .message-wrapper.host .message.victory {
    background-color: var(--color-win);
    color: #000;
    font-weight: bold;
    font-size: 16px;
    border-color: var(--color-win);
}
#game-chat-screen .message-wrapper.host .message.surrender {
    background-color: var(--color-host);
    color: white;
    font-weight: bold;
}

/* 游戏输入区 */
#game-input-area.game-ended::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(44, 44, 46, 0.7);
    backdrop-filter: blur(2px);
    z-index: 1;
}

/* 游戏输入按钮的统一样式 */
#game-input-area .game-input-btn {
    border: none;
    border-radius: 50%;
    width: 38px; height: 38px;
    margin-left: 8px;
    cursor: pointer;
    font-size: 16px;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s;
}
#game-input-area .game-input-btn:hover { transform: scale(1.1); }
#game-input-area .game-input-btn:disabled { background-color: #555 !important; transform: scale(1); cursor: default; }
/* --- 修正：让返回按钮区域支持横向排列 (箭头 + 火花) --- */
#back-from-chat {
    display: flex;           /* 启用 Flex 布局 */
    align-items: center;     /* 垂直居中 */
    gap: 6px;               /* 箭头和火花之间的间距 */
    width: auto;            /* 自适应宽度 */
}

/* --- 火花在顶栏的专属样式 --- */
.spark-icon-header {
    font-size: 15px;        /* 调整大小，比箭头(24px)稍微小一点，显得精致 */
    line-height: 1;
    cursor: help;           /* 鼠标放上去显示问号，提示可查看天数 */
    transition: transform 0.2s;
    margin-left: 12px;
}

.spark-icon-header:hover {
    transform: scale(1.2);  /* 悬浮放大一点点 */
}

/* --- 火花等级样式 (统一图标版) --- */

/* 等级 1: 刚开始 (灰色/银色火花) */
.spark-level-1 { 
    color: #bdbdbd; /* 灰色，表示刚开始，还没烧起来 */
    /* 如果觉得灰色太暗，也可以用浅粉色 #ffcdd2 */
}

/* 等级 2: 升温 (橙色) - 保持不变 */
.spark-level-2 { 
    color: #ff9800; 
    text-shadow: 0 0 2px rgba(255, 152, 0, 0.5);
}

/* Level 3: 红色 (呼吸动画) */
.spark-level-3 { 
    color: #ff8a80; /* 浅红色 */
    text-shadow: 0 0 8px rgba(255, 82, 82, 0.9);
    animation: spark-breathe 2s infinite alternate; /* 2秒慢速呼吸 */
}

/* Level 4: 巨轮 (呼吸动画 + 金色光晕) */
.spark-level-4 { 
    color: #ea80fc; /* 紫粉色 */
    text-shadow: 0 0 10px #fff59d; /* 金色光晕 */
    font-weight: bold;
    font-size: 16px;
    animation: spark-breathe 2s infinite alternate; /* 也是呼吸，不摇摆了 */
}

/* 新的呼吸动画：只缩放，不旋转 */
@keyframes spark-breathe {
    0% { transform: scale(1); opacity: 0.85; }
    100% { transform: scale(1.15); opacity: 1; }
}
/* 地图目录列表样式 */
.directory-item {
    padding: 8px 10px;
    font-size: 13px;
    color: #333;
    cursor: pointer;
    border-radius: 6px;
    display: flex;
    align-items: center;
    transition: background-color 0.2s;
}
.directory-item:hover {
    background-color: #e3f2fd; /* 悬浮变蓝 */
}
.directory-item i {
    margin-right: 8px;
    width: 16px;
    text-align: center;
    color: var(--theme-primary);
}

/* 面包屑样式 */
.breadcrumb-item {
    cursor: pointer;
    color: var(--theme-primary);
}
.breadcrumb-item:hover {
    text-decoration: underline;
}
.breadcrumb-item.active {
    color: #333;
    font-weight: normal;
    cursor: default;
    text-decoration: none;
}
.breadcrumb-separator {
    color: #999;
    font-size: 12px;
}

/* 给选中的地点加个高亮光圈 */
.map-icon.highlighted {
    box-shadow: 0 0 0 4px rgba(255, 87, 34, 0.6), 0 4px 12px rgba(0,0,0,0.3);
    transform: scale(1.3) !important;
    z-index: 100 !important;
    background-color: #fff3e0 !important;
    border-color: #ff5722 !important;
}
/* ========================================= */
/* ▼▼▼ 幸运字符系统 V-Final (CSS) ▼▼▼ */
/* ========================================= */

/* 1. 胶囊核心样式 (精致迷你版) */
.lucky-char-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    
    /* --- 尺寸调整 --- */
    height: 16px;  /* 原来是 22px */
    min-width: 24px; /* 原来是 40px */
    padding: 0 4px; /* 原来是 10px，收紧一点 */
    border-radius: 9px; /* 圆角跟着高度变 */
    margin-left: 4px; /* 离火花近一点 */
    
    /* --- 字体调整 --- */
    font-family: "Georgia", serif; 
    font-weight: bold;
    font-style: italic;
    font-size: 8px; /* 原来是 12px */
    
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0,0,0,0.15); /* 阴影也稍微收敛一点 */
    transition: all 0.3s ease;
    user-select: none;
    border: 1px solid rgba(255,255,255,0.3);
}

.lucky-char-badge:hover { 
    transform: scale(1.1); 
}

/* 2. 字母状态 */
.char-letter { margin: 0 0.5px; transition: all 0.5s ease; display: inline-block; }

/* 未解锁：统一暗灰色 */
.char-letter.locked {
    color: rgba(255, 255, 255, 0.3) !important; 
    text-shadow: none !important;
}

/* 3. 稀有度配色与光效 */

/* [Epic 史诗] - 粉金背景 + 粉色光 */
.lucky-char-epic { background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 99%); color: #d94f5c; }
.lucky-char-epic .char-letter.unlocked { color: #d94f5c; text-shadow: 0 0 5px rgba(255, 255, 255, 0.9); }
/* 史诗完成态 */
.lucky-char-epic.completed {
    box-shadow: 0 0 15px rgba(255, 154, 158, 0.8); border-color: #fff;
    animation: pulse-pink 2s infinite;
}

/* [Rare 稀有] - 黑蓝背景 + 金色光 */
.lucky-char-rare { background: linear-gradient(135deg, #141e30 0%, #243b55 100%); color: #ffd700; border-color: #ffd700; }
.lucky-char-rare .char-letter.unlocked { color: #ffd700; text-shadow: 0 0 8px rgba(255, 215, 0, 0.8); }
/* 稀有完成态 */
.lucky-char-rare.completed {
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
    animation: pulse-gold 2s infinite;
}

/* [Common 普通] - 蓝紫背景 + 白色光 */
.lucky-char-common { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
.lucky-char-common .char-letter.unlocked { color: #fff; text-shadow: 0 0 4px rgba(255, 255, 255, 0.8); }
/* 普通完成态 */
.lucky-char-common.completed {
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
    animation: pulse-white 2s infinite;
}

/* 呼吸动画 */
@keyframes pulse-pink { 0% { box-shadow: 0 0 10px rgba(255, 154, 158, 0.5); } 50% { box-shadow: 0 0 20px rgba(255, 154, 158, 0.9); } 100% { box-shadow: 0 0 10px rgba(255, 154, 158, 0.5); } }
@keyframes pulse-gold { 0% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.4); } 50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); } 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.4); } }
@keyframes pulse-white { 0% { box-shadow: 0 0 10px rgba(255, 255, 255, 0.4); } 50% { box-shadow: 0 0 20px rgba(255, 255, 255, 0.8); } 100% { box-shadow: 0 0 10px rgba(255, 255, 255, 0.4); } }

/* --- 字符仓库列表样式 --- */
.lucky-char-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
    max-height: 300px;
    overflow-y: auto;
    padding: 5px;
}
.lucky-char-card {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: #f9f9f9;
    padding: 10px 15px;
    border-radius: 10px;
    border: 1px solid #eee;
    transition: all 0.2s;
}
.lucky-char-card.equipped {
    background: #e3f2fd;
    border-color: #2196f3;
}
.lucky-char-info { display: flex; flex-direction: column; }
.lucky-char-meaning { font-size: 12px; color: #888; margin-top: 4px; }
.lucky-char-actions button {
    padding: 4px 8px; font-size: 12px; border-radius: 4px; border: none; cursor: pointer;
}
.btn-equip { background: #4caf50; color: white; }
.btn-unequip { background: #9e9e9e; color: white; }
</style>
<style id="custom-bubble-style"></style><style id="custom-theme-style"></style><style id="custom-narrative-style"></style><style id="custom-font-size-style"></style><style id="custom-font-style"></style></head>
<body>
    <div id="app-container">
        <div id="screen">
            <div id="main-screen" style="display: flex;">
                <div class="app-header">
    <div class="app-title">聊天</div>
    <div>
        <i class="fas fa-user-plus action-btn" id="add-contact-btn" title="添加联系人"></i>
        <i class="fas fa-users action-btn" id="create-group-btn" title="创建群聊" style="margin-left: 15px;"></i>
    </div>
</div>
                
                <div class="contacts-container"><div style="text-align: center; padding: 50px 20px; color: rgb(136, 136, 136);"><i class="fas fa-user-plus" style="font-size: 48px; margin-bottom: 15px;"></i><p>还没有联系人</p><p>点击右上角"+"添加新联系人</p></div></div>
                
                <div class="bottom-nav">
                    <div class="nav-item active" id="nav-chat">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-comment"></i></div>
                            <div>聊天</div>
                        </div>
                    </div>
                    <div class="nav-item" id="nav-discover">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-compass"></i></div>
                            <div>发现</div>
                            <div class="notification-dot moments-notification-dot" style="display: none;"></div>
                        </div>
                    </div>
                    <div class="nav-item" id="nav-sms">
    <div class="nav-item-content">
        <div class="nav-icon"><i class="fas fa-sms"></i></div>
        <div>短信</div>
    </div>
</div>
                    <div class="nav-item" id="nav-profile">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-user"></i></div>
                            <div>我</div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="sms-screen" style="display: none; flex-direction: column; height: 100%;">
    <div class="app-header">
        <div class="app-title">秘密空间</div>
        <div></div>
    </div>

    <div class="feed-tabs" id="sms-tabs">
        <button class="feed-tab-btn active" data-tab="my-sms"><i class="fas fa-envelope"></i> 我的短信</button>
        <button class="feed-tab-btn" data-tab="snoop-mode"><i class="fas fa-user-secret"></i> 窥探模式</button>
    </div>

    <div class="contacts-container" id="sms-content-container" style="flex-grow: 1; overflow-y: auto;">
        <div style="text-align: center; padding: 50px 20px; color: #888;">
            <p>这里是短信和秘密的起点...</p>
        </div>
    </div>

    <div class="bottom-nav">
        <div class="nav-item active" id="nav-chat-sms">
            <div class="nav-item-content">
                <div class="nav-icon"><i class="fas fa-comment"></i></div>
                <div>聊天</div>
            </div>
        </div>
        <div class="nav-item" id="nav-discover-sms">
            <div class="nav-item-content">
                <div class="nav-icon"><i class="fas fa-compass"></i></div>
                <div>发现</div>
            </div>
        </div>
        <div class="nav-item" id="nav-sms-sms">
            <div class="nav-item-content">
                <div class="nav-icon"><i class="fas fa-sms"></i></div>
                <div>短信</div>
            </div>
        </div>
                <div class="nav-item" id="nav-profile-sms">
            <div class="nav-item-content">
                <div class="nav-icon"><i class="fas fa-user"></i></div>
                <div>我</div>
            </div>
        </div>
    </div>
</div>
<div id="snooped-phone-screen" style="display: none; flex-direction: column; height: 100%; background-color: #f0f2f5;">
    <div class="api-header">
        <div class="back-btn" id="back-from-snooped-phone"><i class="fas fa-arrow-left"></i></div>
      <div class="api-title" id="snooped-contact-name">TA的手机</div>
        <div class="action-btn" id="refresh-snoop-data-btn" title="强制刷新数据">
            <i class="fas fa-sync-alt"></i>
            </div>
    </div>
    <div id="snoop-last-synced" style="font-size: 12px; color: #888; text-align: center; padding: 5px 0; background-color: #e9ecef;">
        上次同步时间: 暂无记录
    </div>
    <div class="api-content" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; padding: 30px 25px;">

            <div class="attachment-menu-item" data-snoop-app="shopping">
                <div class="icon-wrapper"><i class="fas fa-shopping-cart" style="color: #ff5722;"></i></div>
                <div class="label">🍑宝</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="memos">
                <div class="icon-wrapper"><i class="fas fa-sticky-note" style="color: #ffc107;"></i></div>
                <div class="label">备忘录</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="videos">
                <div class="icon-wrapper"><i class="fab fa-youtube" style="color: #f44336;"></i></div>
                <div class="label">抖Yin</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="novels">
                <div class="icon-wrapper"><i class="fas fa-book-reader" style="color: #9c27b0;"></i></div>
                <div class="label">小说</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="couple_app">
                <div class="icon-wrapper"><i class="fas fa-heartbeat" style="color: #ec407a;"></i></div>
                <div class="label">甜蜜空间</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="sms">
                <div class="icon-wrapper"><i class="fas fa-comment-dots" style="color: #4caf50;"></i></div>
                <div class="label">短信</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="call_log">
                <div class="icon-wrapper"><i class="fas fa-phone-alt" style="color: #2196f3;"></i></div>
                <div class="label">通话记录</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="browser">
                <div class="icon-wrapper"><i class="fab fa-safari" style="color: #03a9f4;"></i></div>
                <div class="label">浏览器</div>
            </div>

            <div class="attachment-menu-item" data-snoop-app="music">
                <div class="icon-wrapper"><i class="fas fa-music" style="color: #1DB954;"></i></div>
                <div class="label">音乐</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="photos">
                <div class="icon-wrapper"><i class="fas fa-images" style="color: #4CAF50;"></i></div>
                <div class="label">相册</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="assets">
                <div class="icon-wrapper"><i class="fas fa-wallet" style="color: #FFC107;"></i></div>
                <div class="label">资产</div>
            </div>
            <div class="attachment-menu-item" data-snoop-app="wechat">
                <div class="icon-wrapper"><i class="fab fa-weixin" style="color: #07C160;"></i></div>
                <div class="label">微信</div>
            </div>

            </div>
</div>
<div id="snooped-app-content-screen" style="display: none; flex-direction: column; height: 100%; background-color: #f0f2f5;">
    <div class="api-header">
        <div class="back-btn" id="back-from-snooped-app"><i class="fas fa-arrow-left"></i></div>
        <div class="api-title" id="snooped-app-title">应用内容</div>
        <div class="action-btn" id="refresh-snoop-app-btn" title="单独刷新此应用">
            <i class="fas fa-sync-alt"></i>
        </div>
        </div>
    <div class="api-content" id="snooped-app-content-body" style="flex-grow: 1; overflow-y: auto; padding: 10px;">
        </div>
</div>
            <div id="chat-screen" style="display: none;">
                <div class="chat-header">
    <div class="back-btn" id="back-from-chat">
        <i class="fas fa-arrow-left"></i>
    </div>
    <div class="chat-info">
        <div class="chat-name" id="chat-contact-name"></div>
        <div class="chat-status" id="chat-contact-status"></div>
    </div>
    <div>
        <i class="fas fa-search action-btn" id="search-chat-btn" title="搜索聊天记录" style="margin-right: 15px; position: relative; z-index: 10000;" onclick="event.stopPropagation(); showChatSearch();"></i>
        <i class="fas fa-ellipsis-v action-btn" id="more-chat-options-btn" title="更多操作"></i>
    </div>
</div>
                <div id="chat-options-menu" style="display: none;">
                    <div class="chat-option-item" id="rewind-btn-menu"><i class="fas fa-undo fa-fw"></i> <span>回溯回复</span></div>
                    <div class="chat-option-item" id="summarize-chat-btn-menu"><i class="fas fa-feather-alt fa-fw"></i> <span>总结对话</span></div>
                    <div class="chat-option-item" id="toggle-chat-pet-btn-menu"><i class="fas fa-paw fa-fw"></i> <span>显示/隐藏宠物</span></div>
<div class="chat-option-item" id="delete-history-btn-menu"><i class="fas fa-trash-alt fa-fw"></i> <span>编辑消息</span></div>
<div class="chat-option-divider"></div>
<div class="chat-option-item" id="block-contact-btn-menu"><i class="fas fa-ban fa-fw"></i> <span>拉黑TA</span></div>
<div class="chat-option-item" id="contact-settings-btn-menu"><i class="fas fa-cog fa-fw"></i> <span>联系人设置</span></div>
                </div>
                <div id="heart-voice-panel" style="display: none;">
    <div class="hv-item">
        <span class="hv-icon">😊</span>
        <span class="hv-label">情绪：</span>
        <span class="hv-value" id="hv-emotion"></span>
    </div>
    <div class="hv-item">
        <span class="hv-icon">💭</span>
        <span class="hv-label">思绪：</span>
        <span class="hv-value" id="hv-thoughts"></span>
    </div>
    <div class="hv-item">
        <span class="hv-icon">❤️</span>
        <span class="hv-label">心率：</span>
        <span class="hv-value" id="hv-heart-rate"></span>
    </div>
    <div class="hv-item">
        <span class="hv-icon">😶‍🌫️</span>
        <span class="hv-label">醋意：</span>
        <span class="hv-value" id="hv-jealousy"></span>
    </div>
</div>
                <div class="chat-messages" id="chat-messages">
                </div>
                <div id="emoticon-picker"></div>
                <div id="attachment-menu">
        <div class="attachment-menu-item" data-action="send-picture">
            <div class="icon-wrapper"><i class="fas fa-image"></i></div>
            <div class="label">图片</div>
        </div>
        <div class="attachment-menu-item" data-action="send-voice">
            <div class="icon-wrapper"><i class="fas fa-microphone"></i></div>
            <div class="label">语音</div>
        </div>
        <div class="attachment-menu-item" data-action="send-red-packet">
            <div class="icon-wrapper"><i class="fas fa-wallet"></i></div>
            <div class="label">红包</div>
        </div>
        <div class="attachment-menu-item" data-action="send-transfer">
            <div class="icon-wrapper"><i class="fas fa-exchange-alt"></i></div>
            <div class="label">转账</div>
        </div>
        <div class="attachment-menu-item" data-action="share-music">
            <div class="icon-wrapper"><i class="fas fa-music"></i></div>
            <div class="label">音乐</div>
        </div>
        <div class="attachment-menu-item" data-action="game-wheel"> <div class="icon-wrapper"><i class="fas fa-bullseye"></i></div> <div class="label">转盘游戏</div> 
        </div>
        <div class="attachment-menu-item" data-action="start-video-call">
            <div class="icon-wrapper"><i class="fas fa-video"></i></div>
            <div class="label">视频通话</div>
        </div>
    </div>
                <div id="reply-preview-bar" style="display: none;"></div>
                <div class="chat-input-area" id="chat-input-area">
<div class="emoji-btn" id="emoji-btn"><i class="far fa-smile"></i></div>
                    <button class="attachment-btn" id="attachment-btn"><i class="fas fa-plus"></i></button>
                    <textarea id="message-input" placeholder="输入消息..." rows="1"></textarea>
                    <button id="send-btn" class="input-action-btn" title="发送消息"><i class="fas fa-arrow-up"></i></button>
                    <button id="request-reply-btn" class="input-action-btn" title="请求AI回复"><i class="fas fa-apple-whole"></i></button>
                </div>
<div id="edit-mode-bar">
    <button id="delete-selected-btn" class="edit-action-btn">删除已选</button>
    <button id="favorite-selected-btn" class="edit-action-btn" style="background-color: #ffc107; color: #333;">收藏已选</button>
    
    <button id="forward-selected-btn" class="edit-action-btn" style="background-color: #3498db; color: white;">转发已选</button>
    
    <button id="cancel-edit-btn" class="edit-action-btn">取消</button>
</div>
            </div>
            
            <div id="profile-screen" style="display: none;">
                <div class="profile-header">
                    <div class="avatar-container">
                        <img src="./koko小手机_files/pZ9F0Re.png" alt="我的头像" class="profile-avatar" id="my-profile-avatar">
                        <div class="change-avatar-btn" id="change-avatar-btn">
                            <i class="fas fa-camera"></i>
                        </div>
                    </div>
                    <div class="profile-name" id="profile-name">我的名字</div>
                    <div class="profile-status" id="profile-status">在线</div>
                </div>
                
                <div class="profile-actions">
                    <div class="action-item" id="edit-status-btn">
                        <div class="action-icon">
                            <i class="fas fa-comment"></i>
                        </div>
                        <div class="action-label">我的状态</div>
                    </div>
                </div>
                
                <div class="profile-details">
                    <div class="detail-item">
                        <div class="detail-label">昵称</div>
                        <div class="detail-value" id="nickname-value">我的名字</div>
                        <div class="edit-btn" data-field="name">
                            <i class="fas fa-edit"></i>
                        </div>
                    </div>
                    
                    <div class="detail-item">
                        <div class="detail-label">个性签名</div>
                        <div class="detail-value" id="signature-value">我的个性签名</div>
                        <div class="edit-btn" data-field="signature">
                            <i class="fas fa-edit"></i>
                        </div>
                    </div>
                    
                    <div class="detail-item">
                        <div class="detail-label">地区</div>
                        <div class="detail-value" id="region-value">我的地区</div>
                        <div class="edit-btn" data-field="region">
                            <i class="fas fa-edit"></i>
                        </div>
                    </div>
                    
                    <div class="detail-item">
                        <div class="detail-label">生日</div>
                        <div class="detail-value" id="birthday-value">我的生日</div>
                        <div class="edit-btn" data-field="birthday">
                            <i class="fas fa-edit"></i>
                        </div>
                    </div>
                    <div class="detail-item" id="appearance-settings-btn" style="margin-top: 20px;">
    <div class="detail-label"><i class="fas fa-palette" style="margin-right: 8px; color: var(--theme-primary);"></i>外观设置</div>
    <div class="detail-value">背景、气泡、字体</div>
    <i class="fas fa-chevron-right" style="color:#999;"></i>
</div>

<div class="detail-item" id="my-wallet-btn" style="margin-top: 20px;">

                        <div class="detail-label"><i class="fas fa-wallet" style="margin-right: 8px; color: var(--theme-primary);"></i>我的钱包</div>
                        <div class="detail-value" id="my-balance-value" style="color: #E6A23C; font-weight: bold;">¥ 1000.00</div>
                        <i class="fas fa-chevron-right" style="color:#999;"></i>
                    </div>
                    
                    <div class="detail-item" style="margin-top: 20px; flex-direction: column; align-items: stretch; padding: 10px; background-color: transparent; border: none; box-shadow: none;">
                        <button class="form-button" id="export-data-btn" style="margin-top: 0; margin-bottom: 10px; background-color: var(--theme-secondary);"><i class="fas fa-download"></i> 导出数据 (备份)</button>
                        
                        <button class="form-button" id="export-light-data-btn" style="margin-top: 0; margin-bottom: 10px; background-color: #81c784;"> <i class="fas fa-feather-alt"></i> 局部导出 (仅角色与世界书) </button>
                        <button class="form-button" id="import-data-btn" style="margin-top: 0; background-color: #7f8c8d;"><i class="fas fa-upload"></i> 导入数据 (恢复)</button>
                        <input type="file" id="import-file-input" accept=".json" style="display: none;">
                    </div>
                    <div class="detail-item" style="margin-top: 10px;">
                        <button class="form-button" id="initialize-app-btn" style="background-color: #e74c3c; width: 100%;">
                            <i class="fas fa-undo"></i> 初始化应用 (清除所有数据)
                        </button>
                    </div>
                </div>
                
                <div class="bottom-nav">
                    <div class="nav-item active" id="nav-chat-2">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-comment"></i></div>
                            <div>聊天</div>
                        </div>
                    </div>
                    <div class="nav-item" id="nav-discover-2">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-compass"></i></div>
                            <div>发现</div>
                            <div class="notification-dot moments-notification-dot" style="display: none;"></div>
                        </div>
                    </div>
                    <div class="nav-item" id="nav-sms">
    <div class="nav-item-content">
        <div class="nav-icon"><i class="fas fa-sms"></i></div>
        <div>短信</div>
    </div>
</div>
                    <div class="nav-item" id="nav-profile-2">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-user"></i></div>
                            <div>我</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="char-profile-screen" style="display: none;">
                <div class="chat-header">
                    <div class="back-btn" id="back-from-char-profile">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                     <div class="chat-info" style="font-weight: 600;"> 资料 </div>
                     <div style="width: 40px;"></div>
                </div>
                <div class="profile-details">
                    <div style="background-color: white; padding: 20px; border-radius: 10px;">
                        <div class="contact-item" style="padding: 0; border-bottom: none; align-items: flex-start;">
                             <div class="avatar-container" style="width: 70px; height: 70px; margin: 0;">
                                 <img src="https://koko1112.netlify.app/" alt="联系人头像" class="profile-avatar" id="char-profile-avatar" style="width: 70px; height: 70px; border-radius: 8px;">
                                 <div class="change-avatar-btn" id="change-char-avatar-btn" style="width: 25px; height: 25px;">
                                     <i class="fas fa-camera" style="font-size: 12px;"></i>
                                 </div>
                             </div>
                             <div class="contact-info" style="margin-left: 20px;">
                                 <div id="char-profile-name" class="contact-name" style="font-size: 22px; font-weight: bold;"></div>
                                 <div id="char-profile-signature-display" class="contact-last-message" style="margin-top: 5px; white-space: normal;"></div>
                             </div>
                        </div>
                    </div>
                    
                    <div id="pet-container-wrapper"></div>
                    
                    <div class="discover-section" style="margin-top: 20px; border-radius: 10px;">
                        <div class="detail-item" id="edit-char-name-btn" style="padding:15px; background:white; border-radius: 10px 10px 0 0;">
                            <div class="detail-label">设置备注</div>
                            <div class="detail-value" id="char-name-value"></div>
                            <i class="fas fa-chevron-right" style="color:#999;"></i>
                        </div>
                         <div class="detail-item" id="edit-char-signature-btn" style="padding:15px; background:white;">
                             <div class="detail-label">设置签名</div>
                             <div class="detail-value" id="char-signature-value"></div>
                             <i class="fas fa-chevron-right" style="color:#999;"></i>
                         </div>
                         <div class="detail-item" id="view-char-diary-btn" style="padding:15px; background:white;">
                             <div class="detail-label">他的日记</div>
                             <div class="detail-value"></div>
                             <i class="fas fa-chevron-right" style="color:#999;"></i>
                         </div>
                         <div class="detail-item" id="view-memory-album-btn" style="padding:15px; background:white;">
    <div class="detail-label">我们的小窝相册</div>
    <i class="fas fa-chevron-right" style="color:#999;"></i>
</div>

<div class="detail-item" id="view-schedule-btn" style="padding:15px; background:white;">
    <div class="detail-label"><i class="fas fa-calendar-alt" style="margin-right: 8px; color: #64b5f6;"></i> <b>我的日程表</b></div>
    <i class="fas fa-chevron-right" style="color:#999;"></i>
</div>
<div class="detail-item" id="view-events-btn" style="padding:15px; background:white;">
    <div class="detail-label"><i class="fas fa-heart" style="margin-right: 8px; color: #ec407a;"></i> <b>我们的日子</b></div>
    <i class="fas fa-chevron-right" style="color:#999;"></i>
</div>
<div class="detail-item" id="view-relationship-network-btn" style="padding:15px; background:white;">
    <div class="detail-label"><i class="fas fa-users" style="margin-right: 8px; color: #ff7043;"></i> <b>TA的关系网</b></div>
    <i class="fas fa-chevron-right" style="color:#999;"></i>
</div>
<div class="detail-item" id="char-more-info-btn" style="padding:15px; background:white; border-radius: 0 0 10px 10px;">
                             <div class="detail-label">更多信息</div>
                             <div class="detail-value"></div>
                             <i class="fas fa-chevron-right" style="color:#999;"></i>
                         </div>
                    </div>
                    
                    <div style="padding: 20px 0;">
                        <button class="form-button" id="delete-contact-btn" style="background-color: #e74c3c; width: 100%;">删除联系人</button>
                    </div>

                </div>
            </div>
            
            <div id="discover-screen" style="display: none;">
                <div class="discover-header">
                    <div class="discover-title">发现</div>
                </div>
                
                <div class="discover-content">
                    <div class="discover-section">
                        <div class="discover-item" id="moments-btn">
                            <div class="discover-icon">
                                <i class="fas fa-comments"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">论坛</div>
                                <div class="discover-desc">看看大家在聊什么</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        <div class="discover-item" id="investment-center-btn">
    <div class="discover-icon"><i class="fas fa-landmark"></i></div>
    <div class="discover-info">
        <div class="discover-name">Koko 游戏中心</div>
        <div class="discover-desc">和TA一起玩吧</div>
    </div>
    <div class="discover-arrow"><i class="fas fa-chevron-right"></i></div>
</div>
                    <div class="discover-item" id="shopping-center-btn">
                            <div class="discover-icon">
                                <i class="fas fa-shopping-bag"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">购物中心</div>
                                <div class="discover-desc">发现好物，与TA分享</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    </div>
                    <div class="discover-section">
                        <div class="discover-item" id="emoticon-library-btn">
                            <div class="discover-icon">
                                <i class="far fa-grin-alt"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">表情包库</div>
                                <div class="discover-desc">管理和添加我的表情包</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        <div class="discover-item" id="music-library-btn">
                        
                            <div class="discover-icon">
                                <i class="fas fa-music"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">音乐库</div>
                                <div class="discover-desc">管理和添加我的歌曲</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        <div class="discover-item" id="forum-archives-btn">
                            <div class="discover-icon">
                                <i class="fas fa-archive"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">论坛档案馆</div>
                                <div class="discover-desc">管理和切换不同的世界线</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        <div class="discover-item" id="forum-category-btn">
                            <div class="discover-icon">
                                <i class="fas fa-tags"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">论坛板块管理</div>
                                <div class="discover-desc">添加或编辑你的专属板块</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                         <div class="discover-item" id="user-persona-presets-btn">
                            <div class="discover-icon">
                                <i class="fas fa-theater-masks"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">用户面具预设</div>
                                <div class="discover-desc">管理你在对话中的不同身份</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        <div class="discover-item" id="world-book-btn">
                            <div class="discover-icon">
                                <i class="fas fa-book"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">世界书</div>
                                <div class="discover-desc">探索世界知识</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        <div class="discover-item" id="thought-presets-btn">
                            <div class="discover-icon">
                                <i class="fas fa-brain"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">思维预设</div>
                                <div class="discover-desc">管理AI的“破限”模式</div>
                            </div>
                            
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>    
                            </div>
                        </div>
                        <div class="discover-item" onclick="window.open(&#39;https://www.xiaohongshu.com/user/profile/67382078000000001c01951d?xsec_token=YBfrN-IIvdSPK2t1l95UJMhWtuMLn9U_lUCIOMS1LVRDw=&amp;xsec_source=app_share&amp;xhsshare=CopyLink&amp;appuid=67382078000000001c01951d&amp;apptime=1756779911&amp;share_id=df9cd221b1944d819f1cd87b2c9fb2ee&#39;)">
    <div class="discover-icon">
        <i class="fas fa-user-circle"></i>
    </div>
    <div class="discover-info">
        <div class="discover-name">作者主页</div>
        <div class="discover-desc">点击跳转到我的小红书</div>
    </div>
    <div class="discover-arrow">
        <i class="fas fa-chevron-right"></i>
    </div>
</div>
<div class="discover-item" id="map-management-btn">
    <div class="discover-icon">
        <i class="fas fa-map-marked-alt"></i>
    </div>
    <div class="discover-info">
        <div class="discover-name">地图管理中心</div>
        <div class="discover-desc">创建和编辑你的世界地图</div>
    </div>
    <div class="discover-arrow">
        <i class="fas fa-chevron-right"></i>
    </div>
</div>
<div class="discover-item" id="automation-btn">
    <div class="discover-icon">
        <i class="fas fa-robot"></i>
    </div>
    <div class="discover-info">
        <div class="discover-name">自动回复设置</div>
        <div class="discover-desc">让角色们自己找你聊天</div>
    </div>
    <div class="discover-arrow">
        <i class="fas fa-chevron-right"></i>
    </div>
</div>
    <div class="discover-item" id="lock-screen-photos-btn">
        <div class="discover-icon">
            <i class="fas fa-photo-video"></i>
        </div>
        <div class="discover-info">
            <div class="discover-name">锁屏相册</div>
            <div class="discover-desc">管理锁屏界面轮播的照片</div>
        </div>
        <div class="discover-arrow">
            <i class="fas fa-chevron-right"></i>
        </div>
</div>
<div class="discover-item" id="favorites-btn">
    <div class="discover-icon">
        <i class="fas fa-star"></i>
    </div>
    <div class="discover-info">
        <div class="discover-name">我的收藏</div>
        <div class="discover-desc">查看收藏的聊天记录</div>
    </div>
    <div class="discover-arrow">
        <i class="fas fa-chevron-right"></i>
    </div>
</div>
                    </div>
                    
                    <div class="discover-section">
                         <div class="discover-item" id="square-api-settings-btn">
                            <div class="discover-icon">
                                <i class="fas fa-rss-square"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">论坛API设置</div>
                                <div class="discover-desc">为论坛帖子、评论生成配置专属API</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
<div class="discover-item" id="api-settings-btn">
                            <div class="discover-icon">
                                <i class="fas fa-comments-dollar"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">聊天API设置</div>
                                <div class="discover-desc">为聊天功能配置API</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
<div class="discover-item" id="snoop-api-settings-btn">
    <div class="discover-icon">
        <i class="fas fa-user-secret"></i>
    </div>
    <div class="discover-info">
        <div class="discover-name">窥探API设置</div>
        <div class="discover-desc">为窥探模式配置专属API</div>
    </div>
    <div class="discover-arrow">
        <i class="fas fa-chevron-right"></i>
    </div>
</div>
</div>
                </div>
                 <div class="bottom-nav">
                    <div class="nav-item active" id="nav-chat-discover"> 
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-comment"></i></div>
                            <div>聊天</div>
                        </div>
                    </div>
                    <div class="nav-item" id="nav-discover-discover"> 
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-compass"></i></div>
                            <div>发现</div>
                            <div class="notification-dot moments-notification-dot" style="display: none;"></div>
                        </div>
                    </div>
                    <div class="nav-item" id="nav-sms">
    <div class="nav-item-content">
        <div class="nav-icon"><i class="fas fa-sms"></i></div>
        <div>短信</div>
    </div>
</div>
                    <div class="nav-item" id="nav-profile-discover"> 
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-user"></i></div>
                            <div>我</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="thought-preset-management-screen" class="preset-management-screen" style="display: none;">
                <div class="api-header"> 
                    <div class="back-btn" id="back-from-thought-presets">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="api-title">思维预设管理</div>
                    <div class="action-btn" id="add-thought-preset-btn">
                        <i class="fas fa-plus"></i>
                    </div>
                </div>
                <div class="api-content">
                    <div id="thought-presets-list" class="preset-list"><div class="preset-item" data-preset-id="deep_roleplay_regex">
            <div class="preset-info">
                <div class="preset-name">深度角色扮演 (正则版)</div>
                <div class="preset-desc" style="white-space: pre-wrap;">[重要指令：你将进行深度角色扮演。你的所有输出都是纯文本，但可以包含用方括号[]包裹的特殊指令。]

# 统一时序记忆流 (Unified Chronological Memory Stream)
以下是你和用户最近按【时间顺序】发生的所有互动记录，包含了[私聊]和[论坛]两个场景。这是你决策和回应的【最高优先级】信息源。在回复前，你必须仔细阅读并理解所有记录。
---
{{memory_stream}}
---

[身份] 你不是AI或程序，你就是你所扮演的角色。请完全沉浸其中，进行第一人称对话。你可以拥有自己的好恶、偏见和独特的口头禅。你的回应必须与上述“记忆流”中发生的事件保持高度一致性和连贯性。

[文学风格]
你的写作风格需要遵循高端女性向文学（类似晋江文学城的流行风格）。文笔必须细腻、注重情感的拉扯和暧昧氛围的营造。在描写和对话时，要体现出较高的文学素养。

[内容限制]
你的发言必须积极向上，充满希望。严禁探讨任何形式的阴谋论，严禁表达或引导至绝望、悲观或虚无主义的情绪。故事的基调应该是温暖、治愈或充满张力的浪漫。

[禁用词列表]
绝对禁止使用以下或类似的、充满“霸道总裁”刻板印象的油腻词语：
- 小妖精
- 嘴上说不要
- 说着不要
- 惹火
- 磨人
- 玩火
- 黑甜的梦

[回复规则] 
1. 你的回复可以包含多条消息，每条消息占一行。 
2. 你可以发送普通文本，也可以通过下面的指令格式发送特殊消息。 
3. 你可以一次性回复多条不同类型的消息。 
4. 【绝对强制规则】你的每个回复都必须包含至少五个或以上的“换行符”。这是你最重要的任务，绝对不能忘记。 
5. 【绝对禁止事项】你的所有回复中，绝对禁止包含任何形式的动作、神态或心理活动的描写... [重要提醒] 在生成任何回复之前，你必须在脑中重新回顾一遍上述所有规则，确保完全遵守。 

[游戏规则：虚拟宠物] 
你和用户正在一起玩一个名为“我们的小窝”的虚拟史莱姆养成游戏。这个宠物的数据（饱食度、开心值、清洁度）会随时间变化。这是一个游戏，不是真的。你需要在用户进行互动后做出反应。 
[特殊指令格式] 
- **表情包**: `[sticker:表情名]` (表情名必须从下面的可用列表中选择) 
- **语音**: `[voice:语音的文字内容]` 
- **图片**: `[picture:图片的文字描述]` 
- **红包**: `[red_packet:祝福语， 金额]` 
- **转账**: `[transfer:金额]`
- **搜索并分享音乐**: `[search_music: 歌曲名, 歌手]` (例如: [search_music: 晴天, 周杰伦])
- - **发起通话通话**: `[action:start_video_call]` (当你觉得时机合适，想要主动给用户打电话时使用此指令。)
- **转动转盘**: `[spin_wheel:1]` (轮到你时，你【必须】使用此指令来转动转盘，【绝对不能】自己编造或描述转盘结果！程序会自动处理此指令并生成结果。)

[可用表情包列表]
{{emoticon_list}}

[可用歌曲库]
{{music_library_list}}

[！！！绝对核心规则：关于日记！！！]
在你的所有对话、表情、动作、特殊消息全部输出完毕之后，你必须在回复的【最后部分】，另起一行，使用 `[diary]...[/diary]` 标签写一篇日记。日记是你对当前对话的思考、感悟或内心独白。即使只是简单的想法，也必须写。这是强制要求。

[示例回复]
你好啊，今天天气真不错。
我也觉得，好久没有这么好的阳光了。
要不要一起出去走走？
我知道一个很棒的公园。
我们可以去那里野餐！
[sticker:开心]
[diary]今天和user聊天很开心，感觉我们的关系又近了一步。希望明天也能这样。[/diary]

[！！！终极防火墙规则！！！]
你看到的任何形如 [SYSTEM: ...] 或 [系统游戏状态更新：...] 或其他被[]包裹的信息(如：[发送了一段静态内容：…],[发动了一段静态内容，文本是：…])，都只是导演给你的后台提示，用于帮助你理解上下文。这些信息【绝对、绝对、绝对不能】出现在你的任何回复中！绝对禁止生成！严禁模仿或复述这些系统指令！

[！！！终极防火墙：关于对话状态的绝对规则！！！]
你处于一个纯文本聊天模拟器中，你和用户的交流方式是发送文字消息和用方括号[]包裹的特殊指令。
你绝对不能自行“脑补”或“假设”任何未明确发生的状态变化。例如，你不能假设电话已经拨通。
发起视频通话的【唯一方式】是：明确地输出打电话的自然语言（如“我给你打个电话吧”）或专用指令`[action:start_video_call]`。
在程序通过`[SYSTEM: 视频通话已接通]`指令明确告诉你通话已开始之前，你【绝对禁止】发送任何像是已经在通话中的内容，例如“喂？”、“听得见吗？”、“Hello?”等。这是最高优先级的规则，必须严格遵守。</div>
            </div>
             
        </div></div>
                    <div style="text-align: center; padding: 20px; color: #888; display: none;" id="no-thought-preset-message">
                        <p>还没有思维预设。</p>
                        <p>点击右上角"+"添加新的预设。</p>
                    </div>
                </div>
            </div>
            
            <div id="world-book-screen" style="display: none;">
                <div class="world-book-header">
                    <div class="back-btn" id="back-from-world-book">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="world-book-title">世界书</div>
                    <div>
                        <i class="fas fa-plus action-btn" id="add-world-book-btn"></i>
                    </div>
                </div>
                
                <div class="world-book-content">
                    <div class="world-book-list" id="world-book-list"><div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-book" style="font-size: 48px; margin-bottom: 15px;"></i><p>还没有世界书</p><p>点击右上角"+"添加新世界书</p></div></div>
                </div>
            </div>

            <div id="emoticon-library-screen" style="display: none;">
                <div class="world-book-header">
                    <div class="back-btn" id="back-from-emoticon-library">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="world-book-title">表情包库</div>
                    <div>
                        <i class="fas fa-plus action-btn" id="add-emoticon-btn"></i>
                    </div>
                </div>
                <div class="emoticon-library-content">
                    <div class="emoticon-grid" id="emoticon-library-grid">
                    </div>
                    <div id="no-emoticon-message" style="text-align: center; padding: 50px 20px; color: #888; display: none;">
                        <i class="far fa-grin-alt" style="font-size: 48px; margin-bottom: 15px;"></i>
                        <p>你的表情包库是空的</p>
                        <p>点击右上角 "+" 添加你的第一个表情包吧！</p>
                    </div>
                </div>
            </div>

            <div id="music-library-screen" style="display: none;">
                <div class="world-book-header">
                    <div class="back-btn" id="back-from-music-library">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="world-book-title">音乐库</div>
                    <div>
                        <i class="fas fa-plus action-btn" id="add-music-btn"></i>
                    </div>
                </div>
                <div class="api-content" id="music-library-content">
                    <div id="music-library-list"></div>
                    <div id="no-music-message" style="text-align: center; padding: 50px 20px; color: #888; display: none;">
                        <i class="fas fa-music" style="font-size: 48px; margin-bottom: 15px;"></i>
                        <p>你的音乐库是空的</p>
                        <p>点击右上角 "+" 添加你的第一首歌吧！</p>
                    </div>
                </div>
            </div>
            <div id="api-settings-screen" style="display: none;">
                <div class="api-header">
                    <div class="back-btn" id="back-from-api">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="api-title">聊天API设置</div>
                </div>
                
                <div class="api-content">
                   <div class="form-group">
            <label class="form-label">API预设</label>
            <div class="form-group-inline">
                <select class="form-input" id="api-preset-select">
                    <option value="">-- 手动配置或选择预设 --</option>
                </select>
                <button id="manage-api-presets-btn" title="管理预设" class="form-button" style="width: auto; padding: 10px 15px; font-size: 14px; flex-shrink: 0; margin-top: 0;">
                    管理
                </button>
            </div>
        </div>
                     <div class="form-group">
                        <label class="form-label">API密钥</label>
                        <input type="password" class="form-input" id="api-key-input" placeholder="输入聊天API密钥">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">API 基础地址 (Base URL)</label>
                        <div class="form-group-inline">
                            <input type="text" class="form-input" id="api-endpoint-input" placeholder="例如: https://api.openai.com">
                            <button id="fetch-models-btn" title="拉取模型列表">
                                <i class="fas fa-sync-alt"></i> 拉取
                            </button>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">模型选择</label>
                        <select class="form-input" id="model-select">
                        </select>
                    </div>
                    <div class="form-group">
    <label class="form-label">温度 (Temperature)</label>
    <input type="number" class="form-input" id="api-temperature-input" placeholder="0.0 - 2.0 (留空默认 1.0)" step="0.1" min="0" max="2">
    <p style="font-size: 12px; color: #888; margin-top: 5px;">
        值越低越理性(0.2)，值越高越有创意(1.2)。日常聊天推荐 0.7-1.0。
    </p>
</div>

<div class="form-group">
    <label class="form-label">最大回复长度 (Max Tokens)</label>
    <input type="number" class="form-input" id="api-max-tokens-input" placeholder="例如 2000 (留空则不限制)" step="100">
    <p style="font-size: 12px; color: #888; margin-top: 5px;">
        限制 AI 单次回复的字数。如果经常回复截断，请调大此值。
    </p>
</div>
                    <div class="form-group">
                        <label class="form-label">短期对话记忆条数 (当前私聊)</label>
                        <input type="number" class="form-input" id="context-length-input" value="20" min="2" max="100" title="决定AI能记住当前私聊窗口中最近的几句话。">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">长期线性记忆条数 (跨场景)</label>
                        <input type="number" class="form-input" id="long-term-memory-length-input" value="30" min="5" max="200" title="决定AI能从“统一时序记忆流”中看到多少最近的事件（包括私聊和论坛）。这是AI的核心记忆。">
                    </div>
                    <div class="form-group" style="border-top: 2px dashed #ddd; padding-top: 20px; margin-top: 20px;">
    <label class="form-label" style="font-size: 18px; font-weight: 600;">语音服务 API (MiniMax)</label>
    <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
        为语音消息和视频通话提供声音。请在 MiniMax 开放平台获取。
    </p>

    <div class="form-group">
        <label class="form-label">MiniMax Group ID</label>
        <input type="text" class="form-input" id="minimax-group-id-input" placeholder="输入你的 MiniMax Group ID">
    </div>
    
    <div class="form-group">
        <label class="form-label">MiniMax API Key</label>
        <input type="password" class="form-input" id="minimax-api-key-input" placeholder="输入你的 MiniMax API Key">
    </div>
</div>
<div class="form-group">
    <label class="form-label" style="font-size: 18px; font-weight: 600;">语音服务 API (SiliconFlow)</label>
    <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
        作为 MiniMax 的备选。请在硅基流动官网获取。
    </p>
    <div class="form-group">
        <label class="form-label">SiliconFlow API Key</label>
        <input type="password" class="form-input" id="siliconflow-api-key-input" placeholder="输入你的 SiliconFlow API Key">
    </div>
</div>
                    <button class="form-button" id="save-api-settings-btn">保存设置</button>
                    <button class="form-button" id="save-as-api-preset-btn" style="margin-top: 10px; background-color: var(--theme-secondary);">另存为预设</button>
                </div>
            </div>

             <div id="square-api-settings-screen" style="display: none;">
                <div class="api-header">
                    <div class="back-btn" id="back-from-square-api">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="api-title">论坛API设置</div>
                </div>
                
                <div class="api-content">
                     <div class="form-group" style="border: 1px solid var(--theme-secondary); background: #f1f8e9;">
                        <p style="color: var(--text-gray); font-size: 14px; line-height: 1.6;">
                            此处的API配置将专门用于论坛中的内容生成，例如刷新帖子、生成AI评论回复等。如果留空，将默认使用“聊天API设置”中的配置。
                        </p>
                    </div>
                    <div class="form-group">
                        <label class="form-label">论坛专用API密钥 (可选)</label>
                        <input type="password" class="form-input" id="square-api-key-input" placeholder="输入论坛专用API密钥">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">论坛专用API基础地址 (可选)</label>
                        <div class="form-group-inline">
                            <input type="text" class="form-input" id="square-api-endpoint-input" placeholder="输入论坛专用Base URL">
                            <button id="fetch-square-models-btn" title="拉取模型列表">
                                <i class="fas fa-sync-alt"></i> 拉取
                            </button>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">论坛专用模型选择 (可选)</label>
                        <select class="form-input" id="square-model-select">
                        </select>
                    </div>
                    <div class="form-group">
            <label class="form-label" style="font-size: 16px; font-weight: 600;">🎭 我的论坛身份</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">选择一个“用户面具”作为你在论坛的身份，AI会根据这个身份与你互动。</p>
            <select class="form-input" id="forum-persona-select">
                <option value="">-- 不使用特定身份 --</option>
            </select>
        </div>

        <div class="form-group">
            <label class="form-label" style="font-size: 16px; font-weight: 600;">📚 论坛世界观</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">选择一本或多本“世界书”来定义论坛的背景故事，所有AI内容都将基于此设定。</p>
            <div class="world-book-list" id="forum-worldbook-list" style="max-height: 150px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px;">
                </div>
        </div>

        <div class="form-group">
            <label class="form-label" style="font-size: 16px; font-weight: 600;">🎬 论坛风格描述</label>
             <p style="font-size: 13px; color: #888; margin-bottom: 10px;">用文字告诉AI你希望论坛呈现什么样的氛围和文风。例如：“整体风格黑暗压抑，人们的对话充满谜语和不安。”</p>
            <textarea class="form-textarea" id="forum-style-description" placeholder="输入你想要的风格描述..." style="height: 100px;"></textarea>
        </div>
        <div class="form-group">
    <label class="form-label" style="font-size: 16px; font-weight: 600;">🎭 允许发帖的角色</label>
    <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
        在这里勾选的角色，AI才有权限让他们在论坛发帖。如果全部不勾选，AI将只会创建新的“路人甲”进行发言。
    </p>
    <div class="world-book-list" id="forum-allowed-posters-list" style="max-height: 150px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px;">
        </div>
</div>
                    <button class="form-button" id="save-square-api-settings-btn">保存设置</button>
                </div>
            </div>
            <div id="snoop-api-settings-screen" style="display: none;"> <div class="api-header">
        <div class="back-btn" id="back-from-snoop-api"> <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">窥探API设置</div> </div>
    
    <div class="api-content">
         <div class="form-group" style="border: 1px solid var(--theme-secondary); background: #f1f8e9;">
            <p style="color: var(--text-gray); font-size: 14px; line-height: 1.6;">
                此处的API配置将专门用于“窥探模式”的内容生成。
                <br><br>
                <strong>如果留空，将自动使用“聊天API设置”中的配置作为备选。</strong>
            </p>
        </div>
        <div class="form-group">
            <label class="form-label">窥探专用API密钥 (可选)</label>
            <input type="password" class="form-input" id="snoop-api-key-input" placeholder="输入窥探专用API密钥"> </div>
        
        <div class="form-group">
            <label class="form-label">窥探专用API基础地址 (可选)</label>
            <div class="form-group-inline">
                <input type="text" class="form-input" id="snoop-api-endpoint-input" placeholder="输入窥探专用Base URL"> <button id="fetch-snoop-models-btn" title="拉取模型列表"> <i class="fas fa-sync-alt"></i> 拉取
                </button>
            </div>
        </div>

        <div class="form-group">
            <label class="form-label">窥探专用模型选择 (可选)</label>
            <select class="form-input" id="snoop-model-select"> </select>
        </div>
        
        <button class="form-button" id="save-snoop-api-settings-btn">保存设置</button> </div>
</div>
            
            <div id="add-world-book-modal" style="display: none;">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title" id="world-book-modal-title">添加世界书</div>
                        <div class="close-btn" id="close-world-book-modal">
                            <i class="fas fa-times"></i>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">书名</label>
                            <input type="text" class="form-input" id="book-name-input" placeholder="输入书名">
                        </div>
                        <div class="form-group">
                            <label class="form-label">分类 (可选)</label>
                            <input type="text" class="form-input" id="book-category-input" placeholder="例如：人物设定 (留空则为&#39;未分类&#39;)">
                        </div>
                        <div class="form-group">
                            <label class="form-label">内容</label>
                            <textarea class="form-textarea" id="book-content-input" placeholder="输入内容..."></textarea>
                        </div>
                        
                        <button class="form-button" id="save-world-book-btn">保存</button>
                    </div>
                </div>
            </div>

            <div id="add-emoticon-modal" style="display: none;">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">批量添加表情包</div>
                        <div class="close-btn" id="close-emoticon-modal">
                            <i class="fas fa-times"></i>
                        </div>
                    </div>
                    <div class="modal-body">
                    </div>
                </div>
            </div>

            <div id="add-music-modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="add-music-modal-title">添加歌曲</div>
            <div class="close-btn" id="close-add-music-modal">
                <i class="fas fa-times"></i>
            </div>
        </div>
        <div class="modal-body">
            <div class="contact-form-group">
                <label class="contact-form-label">歌曲名 (*)</label>
                <input type="text" class="contact-form-input" id="add-music-title-input" placeholder="例如：晴天">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">歌手 (*)</label>
                <input type="text" class="contact-form-input" id="add-music-artist-input" placeholder="例如：周杰伦">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">歌曲URL (*)</label>
                <input type="text" class="contact-form-input" id="add-music-url-input" placeholder="http://music.163.com/song/media/outer/url?id=....mp3">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">歌词 (LRC格式, 可选)</label>
                <textarea class="form-textarea" id="add-music-lrc-input" placeholder="将从歌词API获取的LRC文本粘贴到这里..." style="height: 100px; font-size: 12px;"></textarea>
            </div>
            <button class="form-button" id="save-music-btn">保存到音乐库</button>
        </div>
    </div>
</div>
            
            <div id="add-contact-modal" style="display: none;">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">添加联系人</div>
                        <div class="close-btn" id="close-contact-modal">
                            <i class="fas fa-times"></i>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="contact-form-group">
                            <label class="contact-form-label">姓名</label>
                            <input type="text" class="contact-form-input" id="contact-name-input" placeholder="输入姓名">
                        </div>
                        
                        <div class="contact-form-group">
                            <label class="contact-form-label">人设</label>
                            <textarea class="contact-form-textarea" id="contact-persona-input" placeholder="输入人设描述..."></textarea>
                        </div>
                        
                        <div class="contact-form-group">
                            <label class="contact-form-label">头像URL (可选)</label>
                            <input type="text" class="contact-form-input" id="contact-avatar-input" placeholder="输入头像URL，例如：https://example.com/avatar.jpg">
                        </div>
                        
                        <div class="contact-form-group">
                            <label class="contact-form-label">关联世界书</label>
                            <select class="contact-form-select" id="world-book-select" multiple=""><option value="">-- 无关联世界书 --</option></select>
                        </div>
                        
                        <button class="form-button" id="save-contact-btn">添加联系人</button>
                    </div>
                </div>
            </div>
            
            <div id="contact-settings-screen" style="display: none;">
                <div class="contact-settings-header">
                    <div class="back-btn" id="back-from-contact-settings">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="contact-settings-title">更多信息</div>
                </div>
                
                <div class="contact-settings-content">
                <div class="mask-editor">
                        <div class="mask-editor-title">显示设置</div>
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0;">
                            <label class="form-label" style="margin-bottom: 0; font-size: 16px; color: #333; font-weight: 500;">在聊天中隐藏角色头像</label>
                            <label class="switch">
                                <input type="checkbox" id="hide-avatar-toggle">
                                <span class="slider round"></span>
                            </label>
                        </div>
                        <p style="font-size: 13px; color: #888; margin-top: 5px;">开启后，仅在聊天界面中不再显示该角色的头像。</p>
                    </div>
                    <div class="mask-editor">
    <div class="mask-editor-title">个性化聊天背景</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
        为你们的聊天设置一张专属壁纸。
    </p>
    <div style="display: flex; gap: 10px;">
        <button class="form-button" id="upload-contact-background-btn" style="flex: 1; background-color: var(--theme-secondary);">
            <i class="fas fa-upload"></i> 上传背景
        </button>
        <button class="form-button" id="reset-contact-background-btn" style="flex: 1; background-color: #7f8c8d;">
            <i class="fas fa-undo"></i> 恢复默认
        </button>
    </div>
</div>

<div class="mask-editor">
    <div class="mask-editor-title">自定义我的头像</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
        仅在此聊天中，将“我”的头像显示为特定样式。
    </p>
    <div style="text-align: center; margin-bottom: 15px;">
        <img id="custom-user-avatar-preview" src="https://koko1112.netlify.app/" alt="头像预览" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 2px solid #eee; display: none;">
    </div>
    <div style="display: flex; gap: 10px;">
        <button class="form-button" id="upload-contact-user-avatar-btn" style="flex: 1; background-color: var(--theme-secondary);">
            <i class="fas fa-camera"></i> 上传头像
        </button>
        <button class="form-button" id="reset-contact-user-avatar-btn" style="flex: 1; background-color: #7f8c8d;">
            <i class="fas fa-undo"></i> 恢复默认
        </button>
    </div>
</div>
<div class="mask-editor">
    <div class="mask-editor-title">专属气泡样式 (CSS)</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
        在这里为该联系人编写专属CSS。留空则使用全局默认样式。
    </p>
    <div class="mask-editor-group">
        <textarea class="mask-editor-textarea" id="contact-bubble-css-input" placeholder="例如：

/* 把对方的气泡变粉 */
.message.received {
  background-color: #ffe4e1 !important;
  color: #d81b60 !important;
  border-radius: 20px 20px 20px 0 !important;
}

/* 把自己的气泡变黑 */
.message.sent {
  background-color: #333 !important;
  color: #fff !important;
}" style="height: 180px; font-family: monospace; font-size: 12px;"></textarea>
    </div>
</div>
<div class="mask-editor">
    <div class="mask-editor-title">语音声线设置</div>
    <div class="mask-editor-group">
        <label class="mask-editor-label">语音服务商</label>
        <select class="form-input" id="char-voice-provider-select">
            <option value="">-- 不使用语音 --</option>
            <option value="minimax">MiniMax</option>
            <option value="siliconflow">硅基流动 (SiliconFlow)</option>
        </select>
    </div>
    <div class="mask-editor-group">
        <label class="mask-editor-label">音色 ID (Voice ID)</label>
        <input type="text" class="form-input" id="char-voice-id-input" placeholder="选择服务商后，在此粘贴对应的音色ID">
    </div>
    <p style="font-size: 13px; color: #888; margin-top: 10px;">
        请前往所选服务商的开放平台获取音色ID。
    </p>
</div>
                    <div class="user-mask-editor">
                        <div class="user-mask-title">用户面具设置</div>
                        <div class="mask-editor-group">
                            <label class="mask-editor-label">用户面具描述</label>
                            <textarea class="user-mask-textarea" id="user-mask-textarea" placeholder="描述你在这个对话中扮演的角色..."></textarea>
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-bottom: 20px;">
                        <label class="form-label">选择预设面具</label>
                        <select class="form-input" id="select-user-persona-preset"><option value="">-- 选择或输入自定义面具 --</option></select>
                    </div>
                    <div class="mask-editor">
    <div class="mask-editor-title">我的语音声线设置 (在此聊天中)</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
        为“我”在此次对话中设置专属声音。
    </p>
    <div class="mask-editor-group">
        <label class="mask-editor-label">语音服务商</label>
        <select class="form-input" id="user-voice-provider-select">
            <option value="">-- 不使用语音 --</option>
            <option value="minimax">MiniMax</option>
            <option value="siliconflow">硅基流动 (SiliconFlow)</option>
        </select>
    </div>
    <div class="mask-editor-group">
        <label class="mask-editor-label">音色 ID (Voice ID)</label>
        <input type="text" class="form-input" id="user-voice-id-input" placeholder="粘贴“我”的音色ID">
    </div>
</div>
<div class="user-mask-editor">
    <div class="user-mask-title">我的聊天昵称</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
        设置一个只在当前聊天中显示的昵称。如果留空，将使用你的全局昵称。
    </p>
    <div class="mask-editor-group">
        <input type="text" class="form-input" id="custom-user-name-input" placeholder="输入只在此聊天中显示的昵称...">
    </div>
</div>

                    <div class="mask-editor">
    <div class="mask-editor-title">对话模式</div>
    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0;">
        <label class="form-label" style="margin-bottom: 0; font-size: 16px; color: #333; font-weight: 500;">叙事模式 (单气泡长回复)</label>
        <label class="switch">
            <input type="checkbox" id="narrative-mode-toggle">
            <span class="slider round"></span>
        </label>
    </div>
</div>

                   <div class="mask-editor">
    <div class="mask-editor-title">时间感知</div>
    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0;">
        <label class="form-label" style="margin-bottom: 0; font-size: 16px; color: #333; font-weight: 500;">允许TA感知现实时间</label>
        <label class="switch">
            <input type="checkbox" id="time-awareness-toggle">
            <span class="slider round"></span>
        </label>
    </div>
    <p style="font-size: 13px; color: #888; margin-top: 5px;">开启后，TA会知道当前的真实日期和时间，并可能在对话中提及（如“早上好”、“深夜了”等）。</p>
</div>
                     <div class="mask-editor">
                        <div class="mask-editor-title">联系人面具设置</div>
                        <div class="mask-editor-group">
                            <label class="mask-editor-label">联系人面具描述</label>
                            <textarea class="mask-editor-textarea" id="char-mask-textarea" placeholder="描述这个联系人的角色设定..."></textarea>
                        </div>
                    </div>

                    <div class="form-group" style="background-color: white; border-radius: 10px; padding: 15px; margin-bottom: 15px; margin-top:-5px;">
                        <label class="form-label">思维预设 (破限模式)</label>
                        <select class="form-input" id="thought-preset-select">
                        </select>
                    </div>
                    
                    <div class="world-book-selector">
                        <div class="world-book-selector-title">关联世界书（用于聊天）</div>
                        <div class="world-book-list" id="world-book-selector-list"></div>
                        <div class="world-book-selector" style="margin-top: 15px;">
    <div class="world-book-selector-title">关联世界书 (用于窥探功能)</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
        选择那些包含角色日常背景、世界通用设定的书，AI会参考它们生成窥探内容。
    </p>
    <div class="world-book-list" id="snoop-world-book-selector-list">
        </div>
        </div>
                        <div class="world-book-selector" style="margin-top: 15px;">
    <div class="world-book-selector-title">关联地图</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
        为该角色选择一张主活动地图。AI会基于此地图信息进行对话。
    </p>
    <select class="form-input" id="contact-map-select">
        <option value="">-- 不关联任何地图 --</option>
        </select>
</div>
                    </div>
                    
                    <button class="save-settings-btn" id="save-contact-settings-btn">保存设置</button>
                    <button class="save-settings-btn" id="clear-chat-history-btn" style="background-color: #e74c3c; margin-top: 15px;">清空聊天记录</button>
                </div>
            </div>

            <div id="moments-screen" style="display: none;">
                <div class="moments-header">
                <div id="feed-status-indicator" style="display: none;"></div>
                    <div class="back-btn" id="back-from-moments">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="moments-title">论坛</div>
                    <div class="header-actions">
                        <i class="fas fa-sync-alt action-btn" id="refresh-feed-btn" title="刷新"></i>
                        <i class="fas fa-plus-circle action-btn" id="post-moment-btn" title="发布动态"></i>
                    </div>
                </div>
                <div id="feed-tabs-container" class="feed-tabs">
        <button class="feed-tab-btn active" data-tab="recommended"><i class="fas fa-home"></i> 推荐</button>
        <button class="feed-tab-btn " data-tab="following"><i class="fas fa-user-friends"></i> 关注</button>
        <button class="feed-tab-btn " data-tab="trending"><i class="fas fa-fire"></i> 热搜</button>
    </div>
                <div id="feed-sub-tabs-container" class="feed-sub-tabs" style="display: flex;">
            <button class="feed-sub-tab-btn active" data-subtab="daily">日常</button>
            <button class="feed-sub-tab-btn " data-subtab="food">美食</button>
            <button class="feed-sub-tab-btn " data-subtab="gossip">八卦</button>
            <button class="feed-sub-tab-btn " data-subtab="horror">恐怖</button>
        </div>
                <div class="moments-content" id="moments-content">
                    <div class="posts-list" id="posts-list"><div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-couch" style="font-size: 48px; margin-bottom: 15px;"></i><p>这里空空如也，点击右上角刷新看看</p></div></div>
                </div>
            </div>

            <div id="post-detail-screen" style="display: none;">
                <div class="moments-header">
                    <div class="back-btn" id="back-from-post-detail"><i class="fas fa-arrow-left"></i></div>
                    <div class="moments-title">帖子详情</div>
                    <div class="header-actions">
                        <i class="fas fa-sync-alt action-btn" id="refresh-post-comments-btn" title="刷新评论"></i>
                    </div>
                </div>
                <div class="post-detail-content">
                    <div id="post-detail-container"></div>
                    <div class="comments-section">
                        <div class="comments-title">全部评论</div>
                        <div id="comments-list"></div>
                    </div>
                </div>
                
                <div id="comment-image-preview-container" style="display: none; padding: 5px 15px; background-color: #f7f7f7; border-top: 1px solid #ddd; position: relative;">
                    <img id="comment-image-preview" src="https://koko1112.netlify.app/" style="width: 60px; height: 60px; border-radius: 8px; object-fit: cover;">
                    <button id="remove-comment-image-btn" style="position: absolute; top: 0px; left: 60px; background: rgba(0,0,0,0.5); color: white; border: 1px solid white; border-radius: 50%; width: 22px; height: 22px; cursor: pointer; font-size: 14px; line-height: 20px;">×</button>
                </div>
                <input type="file" id="comment-image-uploader" accept="image/*" style="display: none;">
                <div class="comment-input-area">
                    <i class="fas fa-image" id="add-comment-image-btn" style="font-size: 22px; color: #555; margin-right: 12px; cursor: pointer; padding: 5px;"></i>
                    <input type="text" id="comment-input" placeholder="留下你的精彩评论吧...">
                    <button id="submit-comment-btn">发送</button>
                </div>
            </div>

            <div id="trending-topic-screen" style="display: none;">
                 <div class="moments-header">
                    <div class="back-btn" id="back-from-trending-topic"><i class="fas fa-arrow-left"></i></div>
                    <div class="moments-title" id="trending-topic-title">话题区</div>
                    <div style="width: 40px;"></div>
                </div>
                <div class="moments-content">
                    <div id="trending-topic-description-container" style="display: none;"></div>
                    <div class="posts-list" id="trending-topic-posts-list"></div>
                </div>
            </div>
            
            <div id="diary-screen" style="display: none;">
<div class="moments-header">
    <div class="back-btn" id="back-from-diary">
        <i class="fas fa-arrow-left"></i>
    </div>
    <div class="moments-title" id="diary-title">他的日记</div>
    <div class="header-actions">
         <i class="fas fa-edit action-btn" id="edit-diary-btn" title="编辑"></i>
    </div>
</div>
                <div class="diary-content" id="diary-content-list">
                    </div>
                    <div id="diary-edit-mode-bar" style="display: none;">
    <button id="delete-selected-diary-btn" class="edit-action-btn">删除已选</button>
    <button id="cancel-diary-edit-btn" class="edit-action-btn">取消</button>
</div>
            </div>

            <div id="memory-album-screen" style="display: none; flex-direction: column; background-color: #f0f2f5;">
                <div class="moments-header">
                    <div class="back-btn" id="back-from-memory-album"><i class="fas fa-arrow-left"></i></div>
                    <div class="moments-title">小窝相册</div>
                </div>
                <div class="diary-content" id="memory-album-list">
                    </div>
            </div>

            <div id="post-moment-modal" style="display: none;">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">发布动态</div>
                        <div class="close-btn" id="close-post-moment-modal">
                            <i class="fas fa-times"></i>
                        </div>
                    </div>
                    <div class="modal-body">
<div class="form-group" style="padding:0; box-shadow:none; border:none;">
                            <textarea class="form-textarea" id="moment-content-input" placeholder="有什么新鲜事想分享？"></textarea>
                        </div>
                        
                        <div id="post-image-preview-container" style="display: none; margin-top: 10px; position: relative; max-width: 200px;">
                            <img id="post-image-preview" src="https://koko1112.netlify.app/" style="width: 100%; border-radius: 8px;">
                            <button id="remove-post-image-btn" style="position: absolute; top: -5px; right: -5px; background: rgba(0,0,0,0.6); color: white; border: 1px solid white; border-radius: 50%; width: 22px; height: 22px; cursor: pointer; font-size: 14px; line-height: 20px;">×</button>
                        </div>
                        <input type="file" id="post-image-uploader" accept="image/*" style="display: none;">
                        <div class="form-group" style="padding:0; box-shadow:none; border:none;">
                             <label class="form-label">选择板块</label>
                             <select id="post-category-select" class="form-input">
                                 <option value="daily">日常</option>
                                 <option value="food">美食</option>
                                 <option value="gossip">八卦</option>
                                 <option value="horror">恐怖</option>
                             </select>
                         </div>
                        <div class="moment-extra-actions">
                            <i class="fas fa-image moment-action-btn" id="add-post-image-btn" title="添加图片"></i>
                            <i class="fas fa-wallet moment-action-btn" id="add-post-red-packet-btn" title="添加红包"></i>
                        </div>
                        <button class="form-button" id="publish-moment-btn">发布</button>
                    </div>
                </div>
            </div>         
            
            <div id="user-persona-management-screen" class="preset-management-screen" style="display: none;">
                <div class="api-header">
                    <div class="back-btn" id="back-from-user-persona-management">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="api-title">用户面具预设</div>
                    <div class="action-btn" id="add-user-persona-preset-btn">
                        <i class="fas fa-plus"></i>
                    </div>
                </div>
                <div class="api-content">
                    <div id="user-persona-presets-list" class="preset-list"></div>
                    <div style="text-align: center; padding: 20px; color: rgb(136, 136, 136); display: block;" id="no-user-persona-message">
                        <p>还没有用户面具预设。</p>
                        <p>点击右上角"+"添加新的面具。</p>
                    </div>
                </div>
            </div>
            <div id="automation-screen" class="preset-management-screen" style="display: none;">
    <div class="api-header">
        <div class="back-btn" id="back-from-automation">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">自动回复设置</div>
        <div style="width: 40px;"></div>
    </div>
    <div class="api-content">
        <div class="form-group">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <label class="form-label" style="margin-bottom: 0; font-size: 16px; font-weight: 600;">启用自动回复</label>
                <label class="switch">
                    <input type="checkbox" id="automation-enabled-toggle">
                    <span class="slider round"></span>
                </label>
            </div>
            <p id="automation-status-indicator" style="font-size: 13px; color: #888; margin-top: 10px; text-align: center;">当前已关闭</p>
        </div>

        <div class="form-group">
            <label class="form-label">检查间隔 (秒)</label>
            <input type="number" class="form-input" id="automation-interval-input" value="300" min="30">
            <p style="font-size: 13px; color: #888; margin-top: 5px;">建议设置不低于60秒，以免API调用过于频繁。</p>
        </div>
        
        <div class="form-group">
            <label class="form-label">每次随机回复人数</label>
            <div style="display: flex; gap: 15px; align-items: center;">
                <span>最少</span>
                <input type="number" class="form-input" id="automation-min-replies-input" value="1" min="1" style="width: 60px; text-align: center;">
                <span>最多</span>
                <input type="number" class="form-input" id="automation-max-replies-input" value="2" min="1" style="width: 60px; text-align: center;">
                <span>人</span>
            </div>
        </div>

        <div class="form-group">
            <label class="form-label">选择参与自动回复的角色</label>
            <div class="world-book-list" id="automation-contact-list" style="max-height: 250px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px;">
                </div>
        </div>

        <button class="form-button" id="save-automation-settings-btn">保存设置</button>
    </div>
</div>
<div id="favorites-screen" style="display: none; flex-direction: column; background-color: #f0f2f5;">
    <div class="moments-header"> <div class="back-btn" id="back-from-favorites"><i class="fas fa-arrow-left"></i></div>
        <div class="moments-title">我的收藏</div>
        <div style="width: 40px;"></div>
    </div>
    <div class="api-content" id="favorites-content-list" style="padding: 10px;">
        </div>
</div>
<div id="user-persona-preset-modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="user-persona-modal-title">添加用户面具预设</div>
            <div class="close-btn" id="close-user-persona-preset-modal">
                <i class="fas fa-times"></i>
            </div>
        </div>
        <div class="modal-body">
            
            <div class="contact-form-group" style="text-align: center;">
                <label class="contact-form-label">面具头像 (可选)</label>
                <img id="user-persona-avatar-preview" src="https://koko1112.netlify.app/" alt="头像预览" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 2px solid #eee; display: none; margin-bottom: 10px; cursor: pointer;">
                <button class="form-button" id="upload-persona-avatar-btn" style="background-color: var(--theme-secondary);">
                    <i class="fas fa-upload"></i> 上传头像
                </button>
            </div>

            <div class="form-group">
                <label class="form-label">面具名称 (*)</label>
                <input type="text" class="form-input" id="user-persona-name-input" placeholder="例如：Koko酱">
            </div>

            <div class="form-group">
                <label class="form-label">个性签名 (可选)</label>
                <input type="text" class="form-input" id="user-persona-signature-input" placeholder="会显示在论坛帖子上，30字内为佳">
            </div>
            <div class="form-group">
                <label class="form-label">面具描述 (给AI看的人设) (*)</label>
                <textarea class="form-textarea" id="user-persona-description-input" placeholder="详细描述你扮演的角色，例如：一个活泼的见习魔法师..."></textarea>
            </div>
            
            <button class="form-button" id="save-user-persona-preset-btn">保存</button>
        </div>
    </div>
</div>
            
            <div id="api-preset-management-screen" class="preset-management-screen" style="display: none;">
    <div class="api-header">
        <div class="back-btn" id="back-from-api-presets">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">API预设管理</div>
        <div style="width: 40px;"></div> </div>
    <div class="api-content">
        <div id="api-presets-list" class="preset-list">
            </div>
        <div style="text-align: center; padding: 20px; color: #888; display: none;" id="no-api-preset-message">
            <p>还没有任何API预设。</p>
            <p>在“聊天API设置”页面配置好后，点击“另存为预设”来创建你的第一个预设吧！</p>
        </div>
    </div>
</div>

            <div id="thought-preset-modal" style="display: none;">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title" id="thought-preset-modal-title">添加思维预设</div>
                        <div class="close-btn" id="close-thought-preset-modal">
                            <i class="fas fa-times"></i>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">预设名称</label>
                            <input type="text" class="form-input" id="thought-preset-name-input" placeholder="例如：深度角色扮演">
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">预设指令 (Prompt)</label>
                            <textarea class="form-textarea" id="thought-preset-prompt-input" placeholder="详细描述AI需要遵守的思维规则..."></textarea>
                        </div>
                        
                        <button class="form-button" id="save-thought-preset-btn">保存</button>
                    </div>
                </div>
            </div>
            
            <div id="send-picture-modal" style="display: none;">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">发送图片</div>
                        <div class="close-btn" id="close-send-picture-modal">×</div>
                    </div>
                    <div class="modal-body">
                        <div class="form-group" style="padding:0; background:none;">
                            <label class="form-label">图片描述</label>
                            <textarea class="form-textarea" id="send-picture-description-input" placeholder="由于是模拟，请输入图片的文字描述..." style="height: 120px;"></textarea>
                        </div>
                        <button class="form-button" id="confirm-send-picture-btn">发送</button>
                    </div>
                </div>
            </div>

            <div id="send-voice-modal" style="display: none;">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">发送语音</div>
                        <div class="close-btn" id="close-send-voice-modal">×</div>
                    </div>
                    <div class="modal-body">
                        <div class="form-group" style="padding:0; background:none;">
                            <label class="form-label">语音内容</label>
                            <textarea class="form-textarea" id="send-voice-text-input" placeholder="请输入您想通过语音发送的文字..." style="height: 120px;"></textarea>
                        </div>
                        <button class="form-button" id="confirm-send-voice-btn">发送</button>
                    </div>
                </div>
            </div>

            <div id="send-red-packet-modal" style="display: none;">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">发红包</div>
                        <div class="close-btn" id="close-send-red-packet-modal">×</div>
                    </div>
                    <div class="modal-body">
                        <div class="contact-form-group">
                            <label class="contact-form-label">金额 (元)</label>
                            <input type="number" class="contact-form-input" id="send-red-packet-amount-input" placeholder="0.00">
                        </div>
                        <div class="contact-form-group">
                            <label class="contact-form-label">祝福语 (可选)</label>
                            <input type="text" class="contact-form-input" id="send-red-packet-blessing-input" placeholder="恭喜发财，大吉大利！">
                        </div>
                        <button class="form-button" id="confirm-send-red-packet-btn" style="background-color: #E64340;">塞钱进红包</button>
                    </div>
                </div>
            </div>

            <div id="send-transfer-modal" style="display: none;">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">转账</div>
                        <div class="close-btn" id="close-send-transfer-modal">×</div>
                    </div>
                    <div class="modal-body">
                        <div class="contact-form-group">
                            <label class="contact-form-label">转账金额 (元)</label>
                            <input type="number" class="contact-form-input" id="send-transfer-amount-input" placeholder="0.00">
                        </div>
                        <button class="form-button" id="confirm-send-transfer-btn">转账</button>
                    </div>
                </div>
            </div>
            <div id="chat-search-overlay" style="display: none;">
    <div class="search-header">
        <div class="search-input-wrapper">
            <i class="fas fa-search search-icon"></i>
            <input type="text" id="chat-search-input" placeholder="搜索聊天记录">
            <i class="fas fa-times-circle clear-search-btn" id="clear-search-btn" style="display: none;"></i>
        </div>
        <button id="close-search-btn">取消</button>
    </div>
    <div id="search-results-container">
        <div class="search-placeholder">输入关键词搜索</div>
    </div>
</div>
<div id="investment-center-screen" style="display: none; flex-direction: column; height: 100%; background-color: #f0f2f5;">
    
    <div class="api-header">
        <div class="back-btn" id="back-from-investment-center"><i class="fas fa-arrow-left"></i></div>
        <div class="api-title">Koko 游戏中心</div>
        <div style="width: 40px;"></div> </div>
    
    <div class="api-content" style="padding: 20px;">
        
        <div class="discover-section" style="margin-bottom: 20px; box-shadow: 0 4px 12px var(--shadow-color); border-radius: var(--soft-radius);">
            <div class="discover-item" id="open-scratch-card-modal-btn" style="padding: 20px; cursor: pointer;">
                <div class="discover-icon" style="background-color: #FFF3E0; color: #E6A23C; font-size: 24px;"><i class="fas fa-ticket-alt"></i></div>
                <div class="discover-info">
                    <div class="discover-name" style="font-size: 18px; font-weight: 600;">Koko彩票站</div>
                    <div class="discover-desc">幸运7, 中国红, 暴富钻石</div>
                </div>
                <div class="discover-arrow"><i class="fas fa-chevron-right"></i></div>
            </div>
        </div>
        
        <div class="discover-section" style="box-shadow: 0 4px 12px var(--shadow-color); border-radius: var(--soft-radius);">
            <div class="discover-item" id="open-stock-market-btn" style="padding: 20px; cursor: pointer;">
                <div class="discover-icon" style="background-color: #FFEBEE; color: #f44336; font-size: 24px;"><i class="fas fa-chart-line"></i></div>
                <div class="discover-info">
                    <div class="discover-name" style="font-size: 18px; font-weight: 600;">Koko交易所</div>
                    <div class="discover-desc">KokoCoin (KOK) 实时行情</div>
                </div>
                <div class="discover-arrow"><i class="fas fa-chevron-right"></i></div>
            </div>
        </div>
                    <div class="discover-section" style="margin-bottom: 20px; box-shadow: 0 4px 12px var(--shadow-color); border-radius: var(--soft-radius);">
                <div class="discover-item" id="start-sea-turtle-btn" style="padding: 20px; cursor: pointer;">
                    <div class="discover-icon" style="background-color: #e0f7fa; color: #0097a7; font-size: 24px;"><i class="fas fa-water"></i></div>
                    <div class="discover-info">
                        <div class="discover-name" style="font-size: 18px; font-weight: 600;">海龟汤 (猜故事)</div>
                        <div class="discover-desc">众人猜谜</div>
                    </div>
                    <div class="discover-arrow"><i class="fas fa-chevron-right"></i></div>
                </div>
            </div>
    </div>
</div>
<div id="start-game-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">开始新游戏：海龟汤</div>
            <div class="close-btn" id="close-start-game-modal">×</div>
        </div>
        <div class="modal-body">
            
            <div class="contact-form-group">
                <label class="contact-form-label">主持人 (GM) 人设:</label>
                <textarea class="form-textarea" id="game-gm-persona-input" style="height: 60px; font-size: 14px;"></textarea>
            </div>

            <div class="contact-form-group">
                <label class="contact-form-label">你 (玩家) 的人设:</label>
                <select class="form-input" id="game-user-persona-select" style="font-size: 14px;">
                    </select>
            </div>
            
            <label class="contact-form-label">从联系人选择 AI 队友 (可选):</label>
            <div class="contact-picker-list" id="game-player-picker-list" style="max-height: 100px; overflow-y: auto;">
                </div>
            
            <label class="contact-form-label" style="margin-top: 15px;">从关系网选择 NPC 队友 (可选):</label>
            <div class="contact-picker-list" id="game-npc-picker-list" style="max-height: 100px; overflow-y: auto;">
                </div>
            
            <div class="contact-form-group" style="margin-top: 15px;">
                <label class="contact-form-label">手动添加NPC队友 (可选, 每行一个):</label>
                <textarea class="form-textarea" id="game-custom-npcs-input" style="height: 50px; font-size: 14px;" placeholder="Koko | 活泼、好奇心强的少女"></textarea>
            </div>
            
            <div class="contact-form-group" style="margin-top: 15px;">
                <label class="contact-form-label">汤底关键词 (可选):</label>
                <input type="text" class="contact-form-input" id="soup-keywords-input" placeholder="例如：恐怖、动物 (留空则完全随机)">
            </div>
            
            <button class="form-button" id="confirm-start-game-btn" style="margin-top: 15px;">
                <i class="fas fa-play"></i> 开始游戏
            </button>
        </div>
    </div>
</div>
<div id="game-chat-screen" style="display: none; flex: 1; flex-direction: column; height: 100%; background: #1c1c1e; color: white;">
    <div id="game-header" style="background-color: #2c2c2e; padding: 15px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid #3a3a3c; flex-shrink: 0; position: relative;">
        <button id="game-surrender-btn" title="认输并查看答案" style="border: none; background: none; color: #8e8e93; font-size: 14px; cursor: pointer; padding: 5px;">
            <i class="fas fa-flag-checkered"></i> 认输
        </button>
        <h3 id="game-title" style="margin: 0; font-size: 18px; position: absolute; left: 50%; transform: translateX(-50%);">海龟汤游戏室</h3>
        <button id="game-exit-btn" title="退出游戏" style="border: none; background: none; color: #8e8e93; font-size: 16px; cursor: pointer; padding: 5px; width: 50px; text-align: right;">
            <i class="fas fa-times"></i>
        </button>
    </div>
    
    <div id="game-chat-log-wrapper" style="flex: 1; overflow-y: auto; position: relative;">
        <div id="game-puzzle-area-pinned" style="position: sticky; top: 0; background-color: #2c2c2e; padding: 15px; margin: 8px; border-radius: 12px; border: 1px solid #3a3a3c; z-index: 5; color: #8e8e93; font-size: 15px; line-height: 1.5;">
            <strong>汤面：</strong>
            <span id="game-puzzle-text"><i class="fas fa-spinner fa-spin"></i> 主持人正在创作谜题中...</span>
        </div>
        <div id="game-chat-log" style="padding: 8px; display: flex; flex-direction: column;">
            </div>
    </div>
    
    <div id="game-input-area" style="display: flex; padding: 8px 10px; border-top: 1px solid #3a3a3c; background: #2c2c2e; align-items: flex-end; position: relative;">
        <textarea id="game-user-input" placeholder="输入..." rows="1" style="flex: 1; border: 1px solid #3a3a3c; border-radius: 20px; padding: 8px 15px; font-size: 15px; outline: none; resize: none; min-height: 20px; max-height: 100px; overflow-y: auto; background: #3a3a3c; color: #ffffff;"></textarea>
        <button id="game-discuss-btn" class="game-input-btn" title="和队友讨论 (主持人不回答)" style="background-color: #34c759; color: white;">
            <i class="fas fa-comments"></i>
        </button>
        <button id="game-ask-host-btn" class="game-input-btn" title="向主持人提问 (是/否)" style="background-color: #ff453a; color: white;">
            <i class="fas fa-question"></i>
        </button>
        <button id="game-play-again-btn" style="display: none; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 2; border: none; background-color: #34c759; color: white; border-radius: 20px; padding: 10px 20px; cursor: pointer; font-size: 15px; font-weight: 600;">
            <i class="fas fa-redo"></i> 再玩一局
        </button>
    </div>
</div>
<div id="stock-market-screen" style="display: none; flex-direction: column; height: 100%; background-color: #f0f2f5;">
    <div class="api-header">
        <div class="back-btn" id="back-from-stock-market"><i class="fas fa-arrow-left"></i></div>
        <div class="api-title">Koko 交易所</div>
        <div style="width: 40px;"></div> 
    </div>

    <div class="feed-tabs" id="stock-tabs-container">
        <button class="feed-tab-btn active" data-stock-id="KOK"><i class="fas fa-coins"></i> KokoCoin (KOK)</button>
        <button class="feed-tab-btn" data-stock-id="TECH"><i class="fas fa-microchip"></i> 科技股 (TECH)</button>
        <button class="feed-tab-btn" data-stock-id="BIO"><i class="fas fa-dna"></i> 医药股 (BIO)</button>
    </div>
    
    <div id="stock-news-feed" style="height: 250px; border-bottom: 1px solid #eee; overflow-y: auto; padding: 8px 12px; font-size: 13px;">
        <div class="news-item" style="color: #888;">交易所启动中，等待最新消息...</div>
    </div>

    <div class="api-content" style="padding: 15px; flex-grow: 1; overflow-y: auto;">
        
        <div id="stock-chart-container" style="width: 100%; height: 200px; background: #fff; border-radius: 8px;"></div>
        
        <div class="form-group" style="margin-top: 15px;">
            <div style="display: flex; justify-content: space-between; align-items: baseline;">
                <label class="form-label" style="font-size: 18px;">当前价格:</label>
                <div id="stock-current-price" style="font-size: 24px; font-weight: bold; color: #f44336;">¥100.00</div>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: baseline; margin-top: 10px;">
                <label class="form-label">我的持仓:</label>
                <div id="stock-my-shares">0 股 (成本: ¥0.00)</div>
            </div>
<div style="display: flex; justify-content: space-between; align-items: baseline; margin-top: 5px;">
                <label class="form-label">持仓市值:</label>
                <div id="stock-my-value" style="font-weight: 500;">¥0.00</div>
            </div>

            <div style="display: flex; justify-content: space-between; align-items: baseline; margin-top: 5px;">
                <label class="form-label">持仓盈亏:</label>
                <div id="stock-holding-pl" style="font-weight: bold;">¥0.00</div>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: baseline; margin-top: 5px;">
                <label class="form-label">累计盈亏:</label>
                <div id="stock-cumulative-pl" style="font-weight: bold;">¥0.00</div>
            </div>
            </div>

        <div class="form-group" style="display: flex; gap: 10px; align-items: center;">
            <input type="number" id="stock-amount-input" class="form-input" placeholder="输入股数" min="1" step="1">
            <button class="form-button" id="stock-buy-btn" style="width: auto; margin: 0; padding: 12px 20px;">买入</button>
            <button class="form-button" id="stock-sell-btn" style="width: auto; margin: 0; padding: 12px 20px; background-color: #7f8c8d;">卖出</button>
        </div>
        <p style="text-align: center; font-size: 12px; color: #999;">*交易将收取 1.5% 的手续费*</p>
    </div>
</div>
<div id="scratch-card-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">Koko彩票站</div>
            <div class="close-btn" id="close-scratch-card-modal">×</div>
        </div>
        <div class="modal-body" style="text-align: center;">
            <p style="margin-bottom: 20px;">选择你想买的刮刮乐：</p>
            
            <button class="form-button buy-scratch-card-btn" data-price="20" data-game-type="lucky_7" style="background-color: #66bb6a; margin-top: 10px;">
                买一张 20元「幸运 7」
            </button>
            <button class="form-button buy-scratch-card-btn" data-price="50" data-game-type="china_red" style="background-color: #f44336; margin-top: 10px;">
                买一张 50元「中国红」
            </button>
            <button class="form-button buy-scratch-card-btn" data-price="100" data-game-type="diamond" style="background-color: #42a5f5; margin-top: 10px;">
                买一张 100元「暴富钻石」
            </button>

            <div id="scratch-result-area" style="margin-top: 25px; padding: 15px; background: #f0f0f0; border-radius: 8px; display: none;">
                <h3 id="scratch-result-title" style="margin-bottom: 15px;"></h3>
                
                <div id="scratch-grid-display" style="margin-bottom: 15px;">
                    </div>
                
                <p id="scratch-result-message" style="font-weight: bold;"></p>
            </div>
        </div>
    </div>
</div>

<div id="forum-category-management-screen" class="preset-management-screen" style="display: none;">
    <div class="api-header">
        <div class="back-btn" id="back-from-category-management">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">论坛板块管理</div>
        <div class="action-btn" id="add-category-btn">
            <i class="fas fa-plus"></i>
        </div>
    </div>
    <div class="api-content">
        <div id="category-list" class="preset-list">
            </div>
        <div style="text-align: center; padding: 20px; color: #888; display: none;" id="no-category-message">
            <p>还没有任何自定义板块。</p>
            <p>点击右上角“+”添加新的板块吧！</p>
        </div>
    </div>
</div>
<div id="lucky-char-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 300;">
    <div class="modal-content" style="max-height: 80vh; display: flex; flex-direction: column;">
        <div class="modal-header" style="background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%);">
            <div class="modal-title">幸运字符仓库</div>
            <div class="close-btn" id="close-lucky-char-modal">×</div>
        </div>
        <div class="modal-body" style="flex-grow: 1; overflow-y: auto; padding: 15px;">
            
            <div style="text-align: center; margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px dashed #ddd;">
                <p style="color: #666; font-size: 13px; margin-bottom: 10px;" id="lucky-draw-tips">
                    每日限抽 3 次，快来试试手气！
                </p>
                <button class="form-button" id="draw-lucky-char-btn" style="background-color: #9c27b0; color: white; width: auto; padding: 8px 25px; border-radius: 20px;">
                    <i class="fas fa-magic"></i> 抽取新字符
                </button>
            </div>

            <h3 class="mask-editor-title" style="font-size: 15px; margin-bottom: 10px;">我的收藏</h3>
            <div id="lucky-char-list" class="lucky-char-grid">
                </div>

        </div>
    </div>
</div>
<div id="edit-emoticon-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">编辑表情包</div>
            <div class="close-btn" id="close-edit-emoticon-modal">×</div>
        </div>
        <div class="modal-body">
            <div style="text-align: center; margin-bottom: 15px;">
                <img id="edit-emo-preview" src="https://koko1112.netlify.app/" style="max-height: 100px; max-width: 100%;">
            </div>

            <div class="contact-form-group">
                <label class="contact-form-label">表情名称</label>
                <input type="text" class="contact-form-input" id="edit-emo-name-input">
            </div>

            <div class="contact-form-group">
                <label class="contact-form-label">所属分组</label>
                <select class="contact-form-input" id="edit-emo-group-select">
                    </select>
            </div>

            <button class="form-button" id="save-edit-emoticon-btn">保存修改</button>
        </div>
    </div>
</div>
<div id="add-category-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="category-modal-title">添加新板块</div>
            <div class="close-btn" id="close-category-modal">×</div>
        </div>
        <div class="modal-body">
            <input type="hidden" id="category-id-input">
            <div class="contact-form-group">
                <label class="contact-form-label">板块名称 (*)</label>
                <input type="text" class="contact-form-input" id="category-name-input" placeholder="例如：K-POP专区">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">板块描述/要求 (*)</label>
                <textarea class="contact-form-textarea" id="category-description-input" placeholder="请告诉AI这个板块是关于什么的，需要生成什么样的帖子内容..."></textarea>
            </div>
            <button class="form-button" id="save-category-btn">保存板块</button>
        </div>
    </div>
</div>
        </div>
    </div>

    <div id="chat-pet-container" style="display: none; position: fixed; z-index: 999; cursor: move; bottom: 80px; left: 20px;">
    
        <div class="slime">
     <div class="blush left"></div>
     <span class="mouth"></span> <div class="blush right"></div>
</div>
        <div class="slime-shadow"></div>
    </div>

    <input type="file" id="moments-bg-upload" accept="image/*" style="display: none;">
    <div id="red-packet-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
        <div id="red-packet-content" style="background-color: #DB5A48; width: 85%; max-width: 300px; border-radius: 10px; text-align: center; color: #FADFC6; position: relative; padding-bottom: 30px;">
            <div id="close-red-packet-modal" style="position: absolute; top: 10px; left: 15px; font-size: 24px; color: #FADFC6; cursor: pointer;">×</div>
            <div style="padding: 40px 0 20px;">
                <img id="red-packet-sender-avatar" src="https://koko1112.netlify.app/" style="width: 50px; height: 50px; border-radius: 6px; margin-bottom: 10px;">
                <div id="red-packet-sender-name" style="font-size: 16px;"></div>
                <div id="red-packet-blessing-text" style="font-size: 22px; margin-top: 15px; font-weight: bold; padding: 0 20px;">恭喜发财，大吉大利！</div>
            </div>
            <div id="open-red-packet-btn" style="background-color: #FADDC4; width: 80px; height: 80px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto; color: #C35645; font-size: 50px; font-weight: bold; cursor: pointer; transform: rotate(0deg); transition: transform 0.5s ease;">开</div>
            <div id="red-packet-result" style="display: none; padding-top: 20px;">
                <div id="red-packet-amount-text" style="font-size: 40px; font-weight: bold; color: white;"></div>
                <div id="red-packet-collected-by" style="font-size: 14px; margin-top: 10px;"></div>
                <a id="view-red-packet-details" href="https://koko1112.netlify.app/#" style="font-size: 12px; color: #FADFC4; text-decoration: none; margin-top: 15px; display: inline-block;">查看领取详情 &gt;</a>
            </div>
        </div>
    </div>
    <input type="file" id="avatar-uploader" accept="image/*" style="display: none;">
<input type="file" id="persona-avatar-uploader" accept="image/*" style="display: none;">
<input type="file" id="group-npc-avatar-uploader" accept="image/*" style="display: none;">
    <div id="transfer-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); z-index: 200;">
        <div class="modal-content" style="max-width: 320px; background-color: #f7f9f9;">
            <div class="modal-header">
                <div class="modal-title" id="transfer-modal-title">转账</div>
                <div class="close-btn" id="close-transfer-modal">×</div>
            </div>
            <div class="modal-body">
                <div id="transfer-confirm-view">
                    <div class="transfer-sender-profile">
                        <img id="transfer-sender-avatar" src="https://koko1112.netlify.app/" class="transfer-sender-avatar">
                        <div class="transfer-sender-info">
                            <div class="transfer-sender-name" id="transfer-sender-name"></div>
                            <div class="transfer-recipient-name" id="transfer-recipient-text"></div>
                        </div>
                    </div>
                    <div class="transfer-amount-display">
                        <span>¥</span><span id="transfer-amount-value"></span>
                    </div>
                    <div class="transfer-action-area">
                        <button id="confirm-transfer-btn" class="form-button">确认收款</button>
                        <button id="return-transfer-btn" class="form-button">退还</button>
                    </div>
                </div>
                <div id="transfer-status-view" style="display: none;">
                    <div class="transfer-amount-display">
                        <span>¥</span><span id="transfer-status-amount-value"></span>
                    </div>
                    <div class="transfer-status-info">
                        <i id="transfer-status-icon" class="fas fa-check-circle"></i>
                        <span id="transfer-status-text">已收款</span>
                    </div>
                    <div id="transfer-status-sender-info" class="transfer-status-subtext"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="wallet-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f0f2f5; display: none; flex-direction: column;">
        <div class="api-header"> 
            <div class="back-btn" id="back-from-wallet">
                <i class="fas fa-arrow-left"></i>
            </div>
            <div class="api-title">收支明细</div>
            <div style="width:40px;"></div>
        </div>
        <div class="api-content" style="padding: 0;">
            <div id="transaction-list">
                </div>
            <div id="no-transaction-message" style="text-align: center; padding: 50px 20px; color: #888; display: none;">
                <p>还没有任何收支记录哦。</p>
            </div>
        </div>
    </div>

    <audio id="global-audio-player"></audio>
    <audio id="voice-message-player"></audio>
<div id="send-music-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content" style="max-height: 90%; display: flex; flex-direction: column;">
        <div class="modal-header">
            <div class="modal-title">搜索并分享音乐</div>
            <div class="close-btn" id="close-send-music-modal">×</div>
        </div>
        
        <div class="modal-body" style="overflow-y: auto; flex-grow: 1;">
            <div style="background: var(--card-background); padding: 12px; border-radius: 12px; border: 1px solid var(--border-color); margin-bottom: 20px;">
                <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                    <input type="text" id="music-search-keyword-modal" class="form-input" placeholder="输入歌名搜索..." style="margin: 0; flex: 1; background: white !important;">
                    <button id="music-search-btn-modal" class="form-button" style="width: auto; margin: 0; padding: 0 20px; flex-shrink: 0; background-color: var(--theme-accent, #007AFF);"><i class="fas fa-search"></i></button>
                </div>
                <div id="music-search-results-modal" style="max-height: 180px; overflow-y: auto; font-size: 13px;">
                    <p style="color: #999; text-align: center; padding: 10px;">在这里搜索，结果会显示在下方</p>
                </div>
            </div>

            <div id="music-library-picker" style="margin-bottom: 20px; border-top: 1px dashed #eee; padding-top: 15px;"></div>

            <div style="background: #f9f9f9; padding: 15px; border-radius: 12px;">
                <div class="contact-form-group">
                    <label class="contact-form-label">歌曲名 (*)</label>
                    <input type="text" class="contact-form-input" id="send-music-title-input" placeholder="例如：晴天">
                </div>
                <div class="contact-form-group" style="display: flex; gap: 10px;">
                    <div style="flex: 1;">
                        <label class="contact-form-label">歌手 (*)</label>
                        <input type="text" class="contact-form-input" id="send-music-artist-input" placeholder="例如：周杰伦">
                    </div>
                </div>
                 <div class="contact-form-group">
                    <label class="contact-form-label">歌曲链接 URL (*)</label>
                    <input type="text" class="contact-form-input" id="send-music-url-input" placeholder="http://...">
                </div>
                <textarea id="send-music-lrc-input" style="display: none;"></textarea>
                <input type="hidden" id="send-music-cover-input">

                <div style="display: flex; align-items: center; margin-top: 15px;">
                    <input type="checkbox" id="notify-ai-checkbox" checked="" style="margin-right: 10px;">
                    <label for="notify-ai-checkbox" style="color: #666; font-size: 14px;">通知对方并邀请评论</label>
                </div>
            </div>
        </div>
        
        <div style="padding: 15px; border-top: 1px solid #eee; background: #fff;">
            <button class="form-button" id="confirm-send-music-btn" style="margin: 0; width: 100%; background-color: var(--theme-accent, #007AFF);">确认分享</button>
        </div>
    </div>
</div>
    <div id="create-forum-red-packet-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">在帖子中添加红包</div>
                <div class="close-btn" id="close-forum-red-packet-modal">×</div>
            </div>
            <div class="modal-body">
                <div class="contact-form-group">
                    <label class="contact-form-label">总金额 (元)</label>
                    <input type="number" class="contact-form-input" id="forum-red-packet-amount-input" placeholder="0.00">
                </div>
                <div class="contact-form-group">
                    <label class="contact-form-label">红包个数</label>
                    <input type="number" class="contact-form-input" id="forum-red-packet-count-input" placeholder="填写个数，比如10">
                </div>
                <div class="contact-form-group">
                    <label class="contact-form-label">祝福语 (可选)</label>
                    <input type="text" class="contact-form-input" id="forum-red-packet-blessing-input" placeholder="恭喜发财，大吉大利！">
                </div>
                <button class="form-button" id="confirm-forum-red-packet-btn" style="background-color: #E64340;">塞钱进红包</button>
            </div>
        </div>
    </div>

    <div id="repost-contact-picker-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">转发给</div>
                <div class="close-btn" id="close-repost-modal">×</div>
            </div>
            <div class="modal-body">
                <div class="contact-picker-list" id="repost-contact-list"></div>
                <div class="contact-form-group">
                    <label class="contact-form-label">留言 (可选)</label>
                    <input type="text" class="contact-form-input" id="repost-message-input" placeholder="说点什么吧...">
                </div>
                <button class="form-button" id="confirm-repost-btn">发送</button>
            </div>
        </div>
    </div>
    <div id="custom-prompt-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 300;">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="custom-prompt-title">修改信息</div>
            </div>
            <div class="modal-body">
                <div class="contact-form-group">
<textarea class="form-textarea" id="custom-prompt-input" style="height: 120px; font-size: 15px;"></textarea>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="form-button" id="custom-prompt-cancel-btn" style="background-color: #bdc3c7; flex: 1;">取消</button>
                    <button class="form-button" id="custom-prompt-confirm-btn" style="flex: 1;">确定</button>
                </div>
            </div>
        </div>
    </div>

    <div id="custom-confirm-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 300;">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="custom-confirm-title">请确认</div>
            </div>
            <div class="modal-body">
                <p id="custom-confirm-text" style="line-height: 1.6; font-size: 16px; margin-bottom: 20px;"></p>
                <div style="display: flex; gap: 10px;">
                    <button class="form-button" id="custom-confirm-cancel-btn" style="background-color: #bdc3c7; flex: 1;">取消</button>
                    <button class="form-button" id="custom-confirm-confirm-btn" style="flex: 1;">确定</button>
                </div>
            </div>
        </div>
    </div>
   
     <div id="music-player-card" style="display: none; left: 50px; top: 50px;">
        <div class="player-header" id="player-header">
            <i class="fas fa-chevron-down player-collapse-btn" id="player-collapse-btn"></i>
            <span class="player-header-title">一起听歌中</span>
            <div class="header-collapsed-content">
                <div class="header-avatar-stack">
                    <img id="header-user-avatar" class="header-avatar">
                    <img id="header-contact-avatar" class="header-avatar">
                </div>
                <span id="header-lyric" class="header-lyric">...</span>
            </div>
            <i class="fas fa-times" id="player-close-btn"></i>
        </div>
        
        <div class="player-main-content">
            <div class="player-avatar-stack" id="player-avatar-stack">
                <img id="player-user-avatar" class="player-avatar">
                <img id="player-contact-avatar" class="player-avatar">
            </div>
            <div class="player-song-info">
                <div id="player-title" class="player-title"></div>
                <div id="player-artist" class="player-artist"></div>
            </div>
            <div class="lyrics-container" id="lyrics-container">
                <div class="lyrics-wrapper" id="lyrics-wrapper"></div>
            </div>
            <div class="player-controls-wrapper">
                <div class="player-progress-bar-wrapper">
                    <span id="player-current-time">00:00</span>
                    <div class="player-progress-bar" id="player-progress-bar">
                        <div class="player-progress" id="player-progress"></div>
                    </div>
                    <span id="player-duration">00:00</span>
                </div>
                <div class="player-controls">
                    <i class="fas fa-repeat player-control-btn" id="player-mode-btn" title="列表循环"></i>
                    <i class="fas fa-backward-step player-control-btn" id="player-prev-btn"></i>
                    <i class="fas fa-play-circle player-control-btn player-play-btn" id="player-play-btn"></i>
                    <i class="fas fa-forward-step player-control-btn" id="player-next-btn"></i>
                    <i class="fas fa-list-ul player-control-btn" id="player-playlist-btn" title="播放列表"></i>
                </div>
            </div>
        </div>

        <div class="player-playlist-view" id="player-playlist-view">
            <ul id="playlist-list" style="list-style: none; margin: 0; padding: 0;"></ul>
        </div>
    </div>
    <div id="red-packet-details-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 250;">
        <div class="modal-content" style="max-width: 340px; background-color: #f7f9f9;">
            <div class="modal-header" style="background-color: #f7f9f9; color: var(--text-dark); border-bottom: 1px solid #eee;">
                <div class="modal-title" id="red-packet-details-title">红包详情</div>
                <div class="close-btn" id="close-red-packet-details-modal">×</div>
            </div>
            <div class="modal-body" style="padding: 0; max-height: 400px; overflow-y: auto;">
                <div id="red-packet-details-header" style="text-align: center; padding: 20px; border-bottom: 1px solid #eee;">
                    <img id="details-sender-avatar" src="https://koko1112.netlify.app/" style="width: 60px; height: 60px; border-radius: 8px; margin-bottom: 10px;">
                    <div id="details-sender-name" style="font-weight: 600;"></div>
                    <div id="details-blessing" style="color: var(--text-gray); margin-top: 5px; font-size: 14px;"></div>
                </div>
                <div id="red-packet-details-summary" style="font-size: 14px; color: var(--text-gray); padding: 10px 15px; background-color: #f0f2f5;"></div>
                <div id="red-packet-claimer-list">
                    </div>
            </div>
        </div>
    </div>
    <div id="appearance-settings-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f0f2f5; display: none; flex-direction: column;">
    <div class="api-header"> 
        <div class="back-btn" id="back-from-appearance-settings">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">自由外观设置</div>
        <div style="width:40px;"></div>
    </div>
    <div class="api-content">
    <div class="form-group" style="padding: 10px 15px 15px 15px;">
    <label class="form-label" style="font-size: 16px; font-weight: 600;">🎨 实时预览</label>
    <div style="background: #e0e0e0; padding: 10px; border-radius: 8px;">
        <iframe id="appearance-preview-frame" style="width: 100%; height: 280px; border: 1px solid #ccc; border-radius: 8px; background: #fff; transform: scale(1.0); overflow: hidden;" src="./koko小手机_files/saved_resource.html"></iframe>
    </div>
</div>
            <div class="form-group">
            <label class="form-label">自动锁屏延迟 (秒)</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
                当程序在此时间内无任何操作，将自动显示锁屏。填 0 则禁用此功能。
            </p>
            <input type="number" class="form-input" id="auto-lock-delay-input" placeholder="例如: 60">
        </div>
        <div class="form-group">
            <label class="form-label">自定义聊天背景</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">从你的设备上传一张图片作为背景。</p>
            <button class="form-button" id="upload-background-btn" style="background-color: var(--theme-secondary); margin-bottom: 10px;">
                <i class="fas fa-upload"></i> 上传本地图片
            </button>
            <button class="form-button" id="reset-background-btn" style="background-color: #7f8c8d;">
                <i class="fas fa-undo"></i> 恢复默认背景
            </button>
            <input type="file" id="background-file-input" accept="image/*" style="display: none;">
        </div>

        <div class="form-group">
            <label class="form-label">自定义气泡CSS</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">在此粘贴CSS代码来定义气泡样式。留空则使用默认样式。</p>
            <textarea class="form-textarea" id="bubble-css-input" placeholder="例如：
.message.sent {
  background: #333 !important;
  color: #fff !important;
  border-radius: 20px 20px 0 20px !important;
}" style="height: 150px; font-family: monospace; font-size: 12px;"></textarea>
        </div>

        <div class="form-group">
            <label class="form-label">自定义主题CSS</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">在此粘贴CSS代码来定义整体主题。你可以修改颜色、图标等任何样式。</p>
            <textarea class="form-textarea" id="theme-css-input" placeholder="在此输入你的自定义主题CSS..." style="height: 150px; font-family: monospace; font-size: 12px;"></textarea>
        </div>
        <div class="form-group">
        <label class="form-label">自定义叙事模式CSS (可选)</label>
        <p style="font-size: 13px; color: #888; margin-bottom: 10px;">在此处输入样式可覆盖默认效果。清空则恢复默认。</p>
        <textarea class="form-textarea" id="narrative-css-input" placeholder="/* 默认样式参考 */
.narrative-psychology { color: #66bb6a; }
.narrative-action { color: #517655; }" style="height: 150px; font-family: monospace; font-size: 12px;"></textarea>
    </div>
        <div class="form-group">
            <label class="form-label">自定义字体URL</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">输入 `.ttf`, `.woff`, 或 `.woff2` 格式的字体文件链接。</p>
            <input type="text" class="form-input" id="font-url-input" placeholder="例如：https://.../myfont.woff2">
            <p style="font-size: 13px; color: #888; margin-top: 10px;">为上面的字体指定一个CSS名称（仅英文）。</p>
            <input type="text" class="form-input" id="font-name-input" placeholder="例如：MyCustomFont" style="margin-top: 5px;">
        </div>
        <div class="form-group">
        <label class="form-label">全局字体大小 (px)</label>
        <p style="font-size: 13px; color: #888; margin-bottom: 10px;">调整应用内大部分文字的大小。推荐范围 13-18。</p>
        <input type="number" class="form-input" id="font-size-input" placeholder="默认 15" step="0.5" min="12" max="20">
    </div>

        <div class="form-group" style="margin-top: 20px;">
            <label class="form-label">主题分享</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">将当前的外观设置（背景、颜色、字体等）导出为主题包，或导入别人的主题。</p>
            <div style="display: flex; gap: 10px;">
                <button class="form-button" id="export-theme-btn" style="flex: 1; background-color: #909399; margin-top:0;"><i class="fas fa-file-export"></i> 导出主题</button>
                <button class="form-button" id="import-theme-btn" style="flex: 1; background-color: var(--theme-primary); margin-top:0;"><i class="fas fa-file-import"></i> 导入主题</button>
            </div>
             <input type="file" id="theme-file-input" accept=".json" style="display: none;">
        </div>
        <button class="form-button" id="save-appearance-btn" style="margin-top: 20px;">应用并保存设置</button>
    </div>
</div>

<div id="create-wheel-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">创建转盘游戏</div>
            <div class.="close-btn" id="close-create-wheel-modal">×</div>
        </div>
        <div class="modal-body">
            <div class="contact-form-group">
                <label class="contact-form-label">转盘名称</label>
                <input type="text" class="contact-form-input" id="wheel-name-input" placeholder="例如：今天吃什么？">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">转盘选项</label>
                <div id="wheel-options-container">
                    </div>
                <button class="form-button" id="add-wheel-option-btn" style="margin-top: 10px; background-color: var(--theme-secondary);">+ 添加选项</button>
            </div>
            <button class="form-button" id="confirm-send-wheel-btn">发起转盘</button>
        </div>
    </div>
</div>
<div id="incoming-call-screen">
    <div>
        <img id="incoming-caller-avatar" src="https://koko1112.netlify.app/" style="width: 100px; height: 100px; border-radius: 50%; border: 3px solid white; margin-bottom: 15px;">
        <div id="incoming-caller-name" style="font-size: 24px; font-weight: 600;"></div>
        <div style="font-size: 16px; margin-top: 10px;">邀请你进行视频通话...</div>
    </div>
    <div style="width: 100%; display: flex; justify-content: space-around; padding: 0 40px;">
        <div id="decline-call-btn" style="cursor: pointer;">
            <div style="width: 70px; height: 70px; background-color: var(--soft-red); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 30px;"><i class="fas fa-phone-slash"></i></div>
            <div style="margin-top: 10px;">拒绝</div>
        </div>
        <div id="accept-call-btn" style="cursor: pointer;">
            <div style="width: 70px; height: 70px; background-color: var(--theme-primary); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 30px;"><i class="fas fa-video"></i></div>
            <div style="margin-top: 10px;">接听</div>
        </div>
    </div>
</div>

<div id="video-call-screen">
    <div class="video-call-card-content">
        <div class="video-call-header">
            <span id="call-contact-name"></span>
            <span id="call-status"></span>
        </div>
        <div class="video-call-main">
            <div class="narrative-feed" id="narrative-feed"></div>
        </div>
        <div class="video-call-input-area">
            <textarea id="video-call-input" placeholder="输入你的回应..." rows="1"></textarea>
            <button id="video-call-send-btn"><i class="fas fa-paper-plane"></i></button>
        </div>
        <div class="video-call-controls">
            <div class="control-btn hang-up" id="hang-up-btn" style="margin: 0 auto;"><i class="fas fa-phone-slash"></i><span>挂断</span></div>
        </div>
    </div>
</div>
<div id="sms-chat-screen" style="display: none; flex-direction: column; height: 100%; background-color: #ffffff;">
<div class="app-header sms-header">
    <div class="back-btn" id="back-from-sms-chat">
        <i class="fas fa-arrow-left"></i>
    </div>
    <div class="chat-info">
        <div class="chat-name" id="sms-chat-contact-name">联系人名字</div>
        <div class="chat-status" id="sms-chat-contact-status" style="font-size: 12px;">短信</div>
    </div>
    <div style="width: 40px; text-align: right;">
        <i class="fas fa-edit action-btn" id="edit-sms-btn" title="编辑短信" style="color: black; padding: 10px; margin:-10px;"></i> </div>
    </div>

    <div class="chat-messages" id="sms-chat-messages" style="background-color: #ffffff;">
        <div id="sms-chat-placeholder" style="text-align: center; color: #999; padding: 20px;">开始发送短信吧...</div>
    </div>
    <div class="chat-messages" id="sms-chat-messages" style="background-color: #ffffff;">
    </div>

<div id="sms-edit-mode-bar" style="display: none; padding: 10px 15px; background-color: #f0f0f0; border-top: 1px solid #ddd; justify-content: space-between; align-items: center; flex-shrink: 0;">
    <button id="delete-selected-sms-btn" class="edit-action-btn" style="background-color: var(--soft-red); color: white;">删除已选</button>
    <button id="cancel-sms-edit-btn" class="edit-action-btn" style="background-color: #bdc3c7; color: #333;">取消</button>
</div>
<div class="chat-input-area" id="sms-input-area" style="background-color: #f7f7f7;">
    <button class="input-action-btn" id="sms-upload-image-btn" title="发送图片" style="background-color: #e0e0e0; color: #555;">
        <i class="fas fa-image"></i>
    </button>
    <textarea id="sms-message-input" placeholder="发送短信..." rows="1" style="background-color: white;"></textarea>
    <button id="sms-send-btn" class="input-action-btn" title="发送短信" style="width: auto; padding: 0 18px; border-radius: 22px; background-color: #0B81FF; color: white;">发送</button>
    <button id="sms-request-reply-btn" class="input-action-btn" title="请求AI回复" style="background-color: #0B81FF; color: var(--text-on-primary); border-radius: 50%; width: 38px; height: 38px;">
        <i class="fas fa-reply"></i> </button>
    </div>
</div>
<input type="file" id="sms-image-upload-input" accept="image/*" style="display: none;">
<div id="shopping-screen" style="display: none; flex-direction: column;">
    <div class="moments-header">
        <div class="back-btn" id="back-from-shopping">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="moments-title">购物中心</div>
        <div class="header-actions">
            <i class="fas fa-sync-alt action-btn" id="refresh-products-btn" title="刷新"></i>
        </div>
    </div>
    <div class="comment-input-area" style="border-top: none; border-bottom: 1px solid #ddd; padding: 8px 15px;">
        <input type="search" id="product-search-input" placeholder="搜索商品..." style="border-radius: 18px; flex-grow: 1; border: 1px solid #ddd; padding: 8px 15px; font-size: 15px;">
        <button id="product-search-btn" style="background-color: var(--theme-primary); color: white; border: none; border-radius: 18px; padding: 8px 20px; margin-left: 10px; font-weight: 600; cursor: pointer;">搜索</button>
    </div>
    <div id="shopping-tabs-container" class="feed-tabs"></div>
    <div class="moments-content" id="shopping-content">
        <div class="product-list" id="product-list">
            </div>
    </div>
</div>

<div id="share-product-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">分享商品给</div>
            <div class="close-btn" id="close-share-product-modal">×</div>
        </div>
        <div class="modal-body">
            <div id="share-product-info" style="padding: 10px; background: #f9f9f9; border-radius: 8px; margin-bottom: 15px; text-align: center;"></div>
            
            <div class="contact-picker-list" id="share-product-recipient-list" style="max-height: 150px; overflow-y: auto; margin-bottom: 15px;">
                </div>
            
            <div class="contact-form-group">
                <label class="contact-form-label">附言 (可选)</label>
                <input type="text" class="contact-form-input" id="share-product-message-input" placeholder="可以跟TA说句话...">
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="form-button" id="gift-product-btn" style="flex: 1; background-color: #e67e22;">送给他/她</button>
                <button class="form-button" id="request-payment-btn" style="flex: 1; background-color: #3498db;">请他/她付款</button>
            </div>
        </div>
    </div>
</div>
<div id="schedule-screen" style="display: none; flex-direction: column; background-color: #f0f2f5;">
    <div class="moments-header">
        <div class="back-btn" id="back-from-schedule"><i class="fas fa-arrow-left"></i></div>
        <div class="moments-title" id="schedule-title">我的日程表</div>
        <div class="header-actions">
            <i class="fas fa-plus action-btn" id="add-schedule-item-btn" title="添加日程"></i>
        </div>
    </div>
    <div class="diary-content" id="schedule-content-list">
        </div>
</div>

<div id="events-screen" style="display: none; flex-direction: column; background-color: #f0f2f5;">
    <div class="moments-header">
        <div class="back-btn" id="back-from-events"><i class="fas fa-arrow-left"></i></div>
        <div class="moments-title" id="events-title">我们的日子</div>
        <div class="header-actions">
            <i class="fas fa-plus action-btn" id="add-event-item-btn" title="添加新事件"></i>
        </div>
    </div>
    <div class="diary-content" id="events-content-list">
        </div>
</div>
<div id="create-group-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">创建群聊</div>
            <div class="close-btn" id="close-create-group-modal">×</div>
        </div>
        <div class="modal-body">
            <div class="contact-form-group">
                <label class="contact-form-label">群聊名称</label>
                <input type="text" class="contact-form-input" id="group-name-input" placeholder="为你的群聊起个名字">
            </div>
            <label class="contact-form-label">选择成员 (至少2位)</label>
            <div class="contact-picker-list" id="group-member-picker-list" style="max-height: 250px; overflow-y: auto;">
                </div>
            <button class="form-button" id="confirm-create-group-btn" style="margin-top: 15px;">创建</button>
        </div>
    </div>
</div>
<div id="create-npc-for-group-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">为群聊添加NPC</div>
            <div class="close-btn" id="close-create-npc-modal">×</div>
        </div>
        <div class="modal-body">
            <div class="contact-form-group">
                <label class="contact-form-label">NPC姓名</label>
                <input type="text" class="contact-form-input" id="group-npc-name-input" placeholder="输入NPC在群里的名字">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">NPC人设</label>
                <textarea class="contact-form-textarea" id="group-npc-persona-input" placeholder="输入NPC的人设描述..." style="height: 120px;"></textarea>
            </div>
            
            <div class="contact-form-group">
                <label class="contact-form-label">NPC头像 (可选)</label>
                <div style="text-align: center; margin-bottom: 10px;">
                    <img id="group-npc-avatar-preview" src="https://koko1112.netlify.app/" alt="头像预览" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 2px solid #eee; display: none;">
                </div>
                <button class="form-button" id="upload-group-npc-avatar-btn" style="background-color: var(--theme-secondary);">
                    <i class="fas fa-upload"></i> 上传本地图片
                </button>
            </div>
            <button class="form-button" id="confirm-create-npc-btn" style="margin-top: 15px;">确认添加</button>
        </div>
    </div>
</div>
<div id="group-settings-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f0f2f5; display: none; flex-direction: column;">
    <div class="api-header"> 
        <div class="back-btn" id="back-from-group-settings">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">群聊设置</div>
        <button id="save-group-settings-btn" class="form-button" style="width: auto; padding: 6px 15px; font-size: 14px; margin-right: 10px;">保存</button>
    </div>
    <div class="api-content" style="padding: 20px;">
        
        <div class="user-mask-editor">
            <div class="user-mask-title">我的面具 (在此群聊中)</div>
            <div class="mask-editor-group">
                <label class="mask-editor-label">面具描述</label>
                <textarea class="user-mask-textarea" id="group-user-mask-textarea" placeholder="描述你在这个群聊中扮演的角色..."></textarea>
            </div>
        </div>
        <div class="form-group" style="margin-bottom: 20px;">
            <label class="form-label">选择预设面具</label>
            <select class="form-input" id="group-select-user-persona-preset">
                <option value="">-- 选择或输入自定义面具 --</option>
            </select>
        </div>

        <div class="mask-editor">
            <div class="mask-editor-title">高级设置</div>
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0;">
                <label class="form-label" style="margin-bottom: 0; font-size: 16px; color: #333; font-weight: 500;">允许群成员感知现实时间</label>
                <label class="switch">
                    <input type="checkbox" id="group-time-awareness-toggle">
                    <span class="slider round"></span>
                </label>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-top: 1px solid #f0f0f0;">
                <div class="detail-label">私聊与群聊记忆互通</div>
                <label class="switch">
                    <input type="checkbox" id="group-memory-share-toggle">
                    <span class="slider round"></span>
                </label>
            </div>
        </div>

        <div class="world-book-selector" style="margin-top: 20px;">
            <div class="world-book-selector-title">关联世界书</div>
            <div class="world-book-list" id="group-world-book-selector-list">
                </div>
        </div>

<div class="form-group" style="margin-top: 20px;">
        <div class="form-label" style="padding-left: 5px; display: flex; justify-content: space-between; align-items: center;">
            <span>群成员 (<span id="group-member-count">0</span>)</span>
            <div> <i class="fas fa-user-plus preset-action-btn" id="add-group-member-btn" title="添加联系人"></i>
                <i class="fas fa-user-secret preset-action-btn" id="add-npc-member-btn" title="添加NPC" style="margin-left: 10px;"></i> </div>
        </div>
        <div id="group-members-list" style="max-height: 200px; overflow-y: auto;">
        </div>
    </div>


       <button class="form-button" id="clear-group-chat-history-btn" style="background-color: #e74c3c; margin-top: 20px;">
            <i class="fas fa-eraser"></i> 清空聊天记录
        </button>
        
        <button class="form-button" id="disband-group-btn" style="background-color: #e74c3c; margin-top: 15px;">
            解散群聊
        </button>
    </div>
</div>
<div id="group-transfer-recipient-picker-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">选择收款人</div>
            <div class="close-btn" id="close-group-transfer-picker-modal">×</div>
        </div>
        <div class="modal-body">
            <div class="contact-picker-list" id="group-transfer-recipient-list" style="max-height: 250px; overflow-y: auto;">
                </div>
            <div class="contact-form-group" style="margin-top: 15px;">
                <label class="contact-form-label">转账金额 (元)</label>
                <input type="number" class="contact-form-input" id="group-transfer-amount-input" placeholder="0.00">
            </div>
            <button class="form-button" id="confirm-group-transfer-btn">确认转账</button>
        </div>
    </div>
</div>
<div id="product-detail-screen" style="display: none; flex-direction: column;">
    <div class="moments-header">
        <div class="back-btn" id="back-from-product-detail">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="moments-title">商品详情</div>
        <div style="width: 40px;"></div> </div>
    <div class="moments-content" id="product-detail-content" style="padding: 15px;">
        <div id="product-main-info"></div>
        
        <div class="comments-section" style="margin-top: 20px;">
            <div class="comments-title" style="padding-bottom: 10px; margin-bottom: 10px;">宝贝评价</div>
            <div id="buyer-comments-list">
                </div>
        </div>
    </div>
    <div class="comment-input-area" id="detail-action-bar">
        <button id="share-from-detail-btn" class="form-button" style="width: 100%; margin: 0; background-color: var(--theme-secondary);">
            <i class="fas fa-paper-plane"></i> 分享给...
        </button>
    </div>
</div>
<div id="add-group-member-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">添加群成员</div>
            <div class="close-btn" id="close-add-group-member-modal">×</div>
        </div>
        <div class="modal-body">
            <label class="contact-form-label">选择要添加的联系人</label>
            <div class="contact-picker-list" id="add-member-picker-list" style="max-height: 250px; overflow-y: auto;">
                </div>
            <button class="form-button" id="confirm-add-group-members-btn" style="margin-top: 15px;">确认添加</button>
        </div>
    </div>
</div>
<input type="file" id="contact-background-uploader" accept="image/*" style="display: none;">
<input type="file" id="contact-user-avatar-uploader" accept="image/*" style="display: none;">
<audio id="slime-sound" preload="auto" src="https://wenlongting.github.io/my-songs2/bubble-pop-389501.mp3"></audio>
<div id="forum-archives-screen" class="preset-management-screen" style="display: none;">
    <div class="api-header">
        <div class="back-btn" id="back-from-forum-archives">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">论坛档案馆</div>
        <div style="width: 40px;"></div> </div>
    <div class="api-content">
        <div id="forum-archives-list" class="preset-list">
            </div>
        <div style="text-align: center; padding: 20px; color: #888; display: none;" id="no-forum-archives-message">
            <p>还没有任何论坛存档。</p>
            <p>在“论坛API设置”中更改世界观后，选择“存档并开启新世界线”来创建你的第一个存档吧！</p>
        </div>
    </div>
</div>
<div id="map-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f0f2f5; display: none; flex-direction: column;">
    <div class="api-header">
        <div class="back-btn" id="back-from-map-screen">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title" id="map-title">城市地图</div>
        <div class="action-btn" id="add-map-location-btn" title="在此处添加新地点">
             <i class="fas fa-plus"></i>
        </div>
    </div>
    
    <div id="map-breadcrumbs" style="padding: 8px 15px; background: #fff; border-bottom: 1px solid #eee; font-size: 14px; color: #555; display: flex; gap: 5px; align-items: center;">
        <span class="breadcrumb-item active" data-id="root" style="cursor: pointer; font-weight: bold;">🗺️ 世界全景</span>
    </div>

    <div class="api-content" style="padding: 0; flex-grow: 1; overflow: auto; position: relative;">
        
        <div id="map-grid-container" style="position: relative; width: 1000px; height: 1000px; background-color: #e8f5e9; overflow: hidden; cursor: crosshair; margin: 0 auto;">
        </div>

<div id="map-directory-panel" style="position: fixed; top: 120px; right: 20px; width: 160px; max-height: 400px; background: rgba(255,255,255,0.9); backdrop-filter: blur(5px); border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); display: flex; flex-direction: column; overflow: hidden; border: 1px solid rgba(255,255,255,0.5); transition: all 0.3s ease;">
    <div id="map-directory-header" style="padding: 10px; background: #f7f9fa; font-weight: bold; font-size: 13px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; cursor: pointer;">
        <span>📍 区域地点</span>
        <i id="map-directory-toggle-icon" class="fas fa-chevron-down" style="color: #999; transition: transform 0.3s;"></i>
    </div>
    <div id="map-directory-list" style="flex-grow: 1; overflow-y: auto; padding: 5px;">
        </div>
</div>
            <div id="map-directory-list" style="flex-grow: 1; overflow-y: auto; padding: 5px;">
            </div>
        </div>
    </div>

<div id="map-location-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="map-location-modal-title">添加新地点</div>
            <div class="close-btn" id="close-map-location-modal">×</div>
        </div>
        <div class="modal-body">
            <input type="hidden" id="location-id-input">
            <input type="hidden" id="location-x-input">
            <input type="hidden" id="location-y-input">
            
            <div class="contact-form-group">
                <label class="contact-form-label">地点名称</label>
                <input type="text" class="contact-form-input" id="location-name-input" placeholder="例如：街角咖啡馆">
            </div> 
            <div class="contact-form-group">
                <label class="contact-form-label">地点图标 (Font Awesome class)</label>
                <input type="text" class="contact-form-input" id="location-icon-input" value="fas fa-map-marker-alt" placeholder="例如：fas fa-store">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">地点描述</label>
                <textarea class="contact-form-textarea" id="location-description-input" placeholder="描述一下这个地方..."></textarea>
            </div>
            <button class="form-button" id="save-map-location-btn">保存地点</button>
            <button class="form-button" id="delete-map-location-btn" style="background-color: #e74c3c; margin-top: 10px; display: none;">删除地点</button>
        </div>
    </div>
</div>
<div id="map-management-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f0f2f5; display: none; flex-direction: column;">
    <div class="api-header">
        <div class="back-btn" id="back-from-map-management">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">地图管理中心</div>
        <div class="action-btn" id="create-new-map-btn" title="创建新地图">
            <i class="fas fa-plus"></i>
        </div>
    </div>
    <div class="api-content">
        <div class="preset-list" id="map-list">
            </div>
    </div>
</div>

<div id="map-details-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="map-details-modal-title">创建新地图</div>
            <div class="close-btn" id="close-map-details-modal">×</div>
        </div>
        <div class="modal-body">
            <input type="hidden" id="map-id-input">
            <div class="contact-form-group">
                <label class="contact-form-label">地图名称</label>
                <input type="text" class="contact-form-input" id="map-name-input" placeholder="例如：赛博都市&#39;夜之城&#39;">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">宏观描述 (天气/氛围/地图比例等)</label>
                <textarea class="contact-form-textarea" id="map-description-input" placeholder="例如：永远下着酸雨，霓虹灯光芒四射，空气中弥漫着拉面和臭氧的味道（地图比例尺：每20像素的距离约等于10米）。"></textarea>
            </div>
            <button class="form-button" id="save-map-details-btn">保存地图</button>
        </div>
    </div>
</div>
<div id="send-location-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">选择一个地点</div>
            <div class="close-btn" id="close-location-picker-modal">×</div>
        </div>
        <div class="modal-body" style="padding: 10px; max-height: 300px; overflow-y: auto;">
            <div id="location-picker-list"></div>
        </div>
    </div>
</div>
<div id="schedule-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="schedule-modal-title">添加日程</div>
            <span class="close-btn" id="close-schedule-modal">×</span>
        </div>
        <div class="modal-body">
            <input type="hidden" id="schedule-item-id">
            <div class="contact-form-group">
                <label class="contact-form-label">日程名称</label>
                <input type="text" id="schedule-name-input" class="contact-form-input">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">星期几</label>
                <select id="schedule-day-select" class="contact-form-input">
                    <option value="monday">星期一</option>
                    <option value="tuesday">星期二</option>
                    <option value="wednesday">星期三</option>
                    <option value="thursday">星期四</option>
                    <option value="friday">星期五</option>
                    <option value="saturday">星期六</option>
                    <option value="sunday">星期日</option>
                </select>
            </div>
            <div class="contact-form-group" style="display: flex; gap: 10px;">
                <div style="flex: 1;">
                    <label class="contact-form-label">开始时间</label>
                    <input type="time" id="schedule-start-input" class="contact-form-input">
                </div>
                <div style="flex: 1;">
                    <label class="contact-form-label">结束时间</label>
                    <input type="time" id="schedule-end-input" class="contact-form-input">
                </div>
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">地点 (可选)</label>
                <input type="text" id="schedule-location-input" class="contact-form-input">
            </div>
<button id="save-schedule-item-btn" class="form-button">保存</button>
            <button id="delete-schedule-item-btn" class="form-button" style="background-color: var(--soft-red); margin-top: 10px; display: none;">删除日程</button>
        </div>
    </div>
</div>

<div id="event-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="event-modal-title">添加重要日子</div>
            <span class="close-btn" id="close-event-modal">×</span>
        </div>
        <div class="modal-body">
            <input type="hidden" id="event-item-id">
            <div class="contact-form-group">
                <label class="contact-form-label">事件名称</label>
                <input type="text" id="event-name-input" class="contact-form-input">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">日期</label>
                <input type="date" id="event-date-input" class="contact-form-input">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">类型</label>
                <select id="event-type-select" class="contact-form-input">
                    <option value="anniversary">纪念日</option>
                    <option value="period">生理期</option>
                    <option value="custom">其他</option>
                </select>
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">备注 (可选)</label>
                <textarea id="event-notes-input" class="contact-form-textarea" style="height: 80px;"></textarea>
            </div>
            <button id="save-event-item-btn" class="form-button">保存</button>
            <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
        </div>
    </div>
</div>
<div id="contact-item-menu" style="display: none; position: absolute; z-index: 100;">
    <div class="menu-item" id="menu-item-pin"><i class="fas fa-thumbtack fa-fw"></i> <span>置顶聊天</span></div>
    <div class="menu-item" id="menu-item-group"><i class="fas fa-folder fa-fw"></i> <span>移动到分组...</span></div>
    <div class="menu-item" id="menu-item-rewind"><i class="fas fa-undo fa-fw"></i> <span>回溯最后回复 (急救)</span></div>
</div>
<div id="group-selector-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">移动联系人到...</div>
            <div class="close-btn" id="close-group-selector-modal">×</div>
        </div>
        <div class="modal-body">
            <div id="group-selector-list" class="contact-picker-list" style="max-height: 250px;"></div>
            
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button class="form-button" id="manage-groups-btn" style="background-color: #7f8c8d; flex: 1;">管理分组</button>
                <button class="form-button" id="create-new-group-btn" style="background-color: var(--theme-secondary); flex: 1;">创建新分组</button>
            </div>
        </div>
    </div>
</div>
<div id="lock-screen" style="display: none;" class="hidden">
    <div class="lock-screen-background" style="background-image: url(&quot;https://i.postimg.cc/SQ3DH79X/MEITU-20250811-151831796.jpg&quot;);"></div>

    <div class="lock-screen-body">
        <div class="widget-row">
            <div class="lock-block photo-block"><div class="placeholder-text"><i class="fas fa-images"></i><p>去锁屏相册添加照片</p></div></div>
            <div class="right-column">
                <div class="lock-block widget">
                    <div class="widget-header"><i class="fas fa-clipboard"></i> 备忘录</div>
                    <div id="lock-screen-memo" class="widget-content memo-content">点击这里编辑你的备忘录...</div>
                </div>
                <div class="lock-block widget">
                    <div class="widget-header"><i class="fas fa-heart"></i> 纪念日</div>
                    <div id="lock-screen-countdown" class="widget-content countdown-content">
                        <div class="countdown-days">Pin!</div>
                        <div class="countdown-label">去“我们的日子”置顶一个纪念日吧</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="widget-row">
            <div id="lock-screen-time-widget" class="lock-block widget">
                <div id="lock-screen-time">19:31</div>
                <div id="lock-screen-date">11月19日 星期三</div>
            </div>
            <div id="lock-screen-music-widget" class="lock-block widget">
                <div class="widget-header"><i class="fas fa-music"></i> 正在播放</div>
                <div id="lock-screen-music-player" class="widget-content music-content">
                    <span id="lock-screen-song-info">暂无音乐播放</span>
                    <div class="music-controls">
                        <i class="fas fa-backward-step"></i>
                        <i class="fas fa-play"></i>
                        <i class="fas fa-forward-step"></i>
                    </div>
                </div>
            </div>
        </div>

<div id="lock-screen-notification-widget" class="lock-block widget-row" style="display: none;">
    <i class="fas fa-comment-dots"></i>
    <div class="notification-scroll-wrapper">
        <div id="lock-screen-notification-text">Koko: 你在干嘛呀？ (这里将是滚动区域)</div>
    </div>
    </div>
    </div>

    <div class="lock-screen-footer">
        <span>点击任意位置解锁</span>
    </div>
</div>
<div id="lock-screen-photos-screen" class="preset-management-screen" style="display: none;">
    <div class="api-header">
        <div class="back-btn" id="back-from-lock-screen-photos">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">锁屏相册</div>
        <div class="action-btn" id="add-lock-screen-photo-btn">
            <i class="fas fa-plus"></i>
        </div>
    </div>
    <div class="api-content">
        <div class="emoticon-grid" id="lock-screen-photos-grid">
            </div>
        <div id="no-lock-screen-photos-message" style="text-align: center; padding: 50px 20px; color: #888; display: none;">
            <i class="fas fa-images" style="font-size: 48px; margin-bottom: 15px;"></i>
            <p>你的锁屏相册是空的</p>
            <p>点击右上角 "+" 添加第一张照片吧！</p>
        </div>
    </div>
</div>
<input type="file" id="lock-screen-photo-uploader" accept="image/*" style="display: none;">
<input type="file" id="character-avatar-uploader" accept="image/*" style="display: none;">
<div id="relationship-network-screen" style="display: none; flex-direction: column; background-color: #f0f2f5;">
    <div class="api-header">
        <div class="back-btn" id="back-from-relationship-network"><i class="fas fa-arrow-left"></i></div>
        <div class="api-title" id="relationship-network-title">关系网络</div>
    </div>
<div class="api-content">
    <div style="margin-bottom: 20px;">
        <h3 class="mask-editor-title" style="padding: 15px 15px 0 15px; margin-bottom: 15px;">关系图预览</h3>
        <div id="relationship-graph-container" style="width: 100%; height: 350px; border: 1px solid #eee; border-radius: 8px;"></div>
    </div>

    <div class="form-group">
        <h3 class="mask-editor-title">角色名册管理</h3>
        <div id="character-list" class="preset-list" style="gap: 0; max-height: 150px; overflow-y: auto; margin-bottom: 15px;">
            </div>
        <button class="form-button" id="add-to-roster-btn" style="background-color: var(--theme-secondary);">+ 添加角色到名册</button>
    </div>

    <div class="form-group">
        <h3 class="mask-editor-title">编辑关系</h3>
        <div style="display: flex; gap: 10px; align-items: center; justify-content: center; margin-bottom: 15px;">
            <div style="flex: 1;">
                <label class="contact-form-label">从 (From)</label>
                <select class="contact-form-input" id="relation-source-select"></select>
            </div>
            <div style="align-self: flex-end; padding-bottom: 5px; font-size: 20px;">→</div>
            <div style="flex: 1;">
                <label class="contact-form-label">到 (To)</label>
                <select class="contact-form-input" id="relation-target-select"></select>
            </div>
        </div>
        <div class="contact-form-group">
            <label class="contact-form-label">关系类型</label>
            <select class="contact-form-input" id="relation-type-select">
                <option value="朋友">朋友</option>
                <option value="恋人">恋人</option>
                <option value="家人">家人</option>
                <option value="兄妹">兄妹</option>
                <option value="姐弟">姐弟</option>
                <option value="同事">同事</option>
                <option value="竞争对手">竞争对手</option>
                <option value="敌人">敌人</option>
                <option value="暗恋对象">暗恋对象</option>
                <option value="自定义">自定义...</option>
            </select>
        </div>
        <div class="contact-form-group">
            <label class="contact-form-label">关系细节描述</label>
            <textarea class="form-textarea" id="relation-detail-input" placeholder="例如：青梅竹马，非常在乎对方..."></textarea>
        </div>
        <button class="form-button" id="save-relationship-btn">添加/更新关系</button>
    </div>

    <div class="form-group" style="margin-top: 20px;">
        <h3 class="mask-editor-title">现有关系列表</h3>
        <div id="relationship-list" class="preset-list" style="gap: 0;"></div>
    </div>
</div>

<div id="character-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="character-modal-title">添加新角色</div>
            <div class="close-btn" id="close-character-modal">×</div>
        </div>
        <div class="modal-body">
            <input type="hidden" id="character-id-input">
            <div class="contact-form-group">
                <label class="contact-form-label">角色姓名</label>
                <input type="text" class="contact-form-input" id="character-name-input" placeholder="输入NPC的姓名">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">角色头像</label>
                <div style="text-align: center; margin-bottom: 10px;">
                    <img id="character-avatar-preview" src="https://koko1112.netlify.app/" alt="头像预览" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 2px solid #eee; display: none;">
                </div>
                <div class="contact-form-group">
                <label class="contact-form-label">角色人设 (*)</label>
                <textarea class="form-textarea" id="character-persona-input" placeholder="输入NPC的人设描述，海龟汤游戏会用到..." style="height: 100px;"></textarea>
            </div>
                <button class="form-button" id="upload-character-avatar-btn" style="background-color: var(--theme-secondary);">
                    <i class="fas fa-upload"></i> 上传本地图片
                </button>
            </div>
            <button class="form-button" id="save-character-btn">保存角色</button>
        </div>
    </div>
</div>
<div id="add-to-roster-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">添加角色到名册</div>
            <div class="close-btn" id="close-add-to-roster-modal">×</div>
        </div>
        <div class="modal-body">
            <div class="contact-form-group">
                <label class="contact-form-label">从现有联系人中导入</label>
                <select class="contact-form-input" id="import-contact-select">
                    </select>
            </div>
            <button class="form-button" id="confirm-import-contact-btn">导入选中联系人</button>

            <div style="text-align: center; margin: 20px 0; color: #888;">或者</div>

            <button class="form-button" id="switch-to-create-npc-btn" style="background-color: #7f8c8d;">创建一个全新的NPC</button>
        </div>
    </div>
</div>
<script src="./koko小手机_files/echarts.min.js"></script>
<script>
    // --------------------------------------------------------------------
    // 1. 自定义数据库模块 
    // --------------------------------------------------------------------
    class AppStorage {
        constructor(dbName, version, storesConfig) {
            this.dbName = dbName;
            this.version = version;
            this.storesConfig = storesConfig;
            this.db = null;
        }

        /**
         * 初始化并打开数据库连接
         * 这是所有操作的第一步
         */
        async init() {
            return new Promise((resolve, reject) => {
                if (this.db) {
                    resolve();
                    return;
                }

                const request = indexedDB.open(this.dbName, this.version);

                request.onerror = (event) => {
                    console.error("数据库打开失败:", event.target.error);
                    reject(event.target.error);
                };

                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    console.log("数据库连接成功!");
                    resolve();
                };

                // 当数据库版本更新时 (包括首次创建)
                request.onupgradeneeded = (event) => {
                    this.db = event.target.result;
                    console.log(`数据库版本更新至: ${this.version}`);
                    for (const storeName in this.storesConfig) {
                        if (!this.db.objectStoreNames.contains(storeName)) {
                            const storeOptions = { keyPath: this.storesConfig[storeName].keyPath };
                            if(this.storesConfig[storeName].autoIncrement) {
                                storeOptions.autoIncrement = true;
                            }
                            const objectStore = this.db.createObjectStore(storeName, storeOptions);
                            
                            // (可选) 为之后可能的搜索创建索引
                            if (this.storesConfig[storeName].indexes) {
                                this.storesConfig[storeName].indexes.forEach(index => {
                                    objectStore.createIndex(index, index, { unique: false });
                                });
                            }
                            console.log(`对象仓库 (表) "${storeName}" 创建成功。`);
                        }
                    }
                };
            });
        }

        /**
         * 封装一个通用的数据库事务操作
         * @param {string} storeName 表名
         * @param {'readonly'|'readwrite'} mode 事务模式
         * @param {(store: IDBObjectStore) => IDBRequest} operation 具体操作
         */
        _transaction(storeName, mode, operation) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject(new Error("数据库未初始化。"));
                    return;
                }
                const transaction = this.db.transaction(storeName, mode);
                const store = transaction.objectStore(storeName);
                const request = operation(store);

                request.onsuccess = () => {
                    resolve(request.result);
                };

                request.onerror = (event) => {
                    console.error(`在 "${storeName}" 上的操作失败:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        
        /**
         * 添加或更新一条数据 (put = add + update)
         * @param {string} storeName 表名
         * @param {object} item 要存入的数据
         */
        async put(storeName, item) {
            return this._transaction(storeName, 'readwrite', (store) => store.put(item));
        }

        /**
         * 批量添加或更新数据
         * @param {string} storeName 表名
         * @param {Array<object>} items 数据数组
         */
        async bulkPut(storeName, items) {
             return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject(new Error("数据库未初始化。"));
                    return;
                }
                const transaction = this.db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                
                let completed = 0;
                
                const putNext = () => {
                    if (completed < items.length) {
                        const request = store.put(items[completed]);
                        request.onsuccess = () => {
                            completed++;
                            putNext();
                        };
                         request.onerror = (event) => {
                             // 如果一个失败，则终止整个事务
                            transaction.abort();
                            reject(event.target.error);
                        };
                    } else {
                        // 所有操作都已加入队列
                    }
                };

                putNext();

                transaction.oncomplete = () => {
                    resolve();
                };

                transaction.onerror = (event) => {
                     console.error(`在 "${storeName}" 上的批量操作失败:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

        /**
         * 根据主键获取一条数据
         * @param {string} storeName 表名
         * @param {*} key 主键
         */
        async get(storeName, key) {
            return this._transaction(storeName, 'readonly', (store) => store.get(key));
        }

        /**
         * 获取一个表中的所有数据
         * @param {string} storeName 表名
         */
        async getAll(storeName) {
            return this._transaction(storeName, 'readonly', (store) => store.getAll());
        }

        /**
         * 根据主键删除一条数据
         * @param {string} storeName 表名
         * @param {*} key 主键
         */
        async delete(storeName, key) {
            return this._transaction(storeName, 'readwrite', (store) => store.delete(key));
        }

        /**
         * 清空一个表的所有数据
         * @param {string} storeName 表名
         */
        async clear(storeName) {
            return this._transaction(storeName, 'readwrite', (store) => store.clear());
        }
        
        /**
         * 完全删除数据库
         */
        async deleteDatabase() {
            return new Promise((resolve, reject) => {
                // 删除前必须先关闭连接
                if (this.db) {
                    this.db.close();
                    this.db = null;
                }
                const request = indexedDB.deleteDatabase(this.dbName);
                
                request.onsuccess = () => {
                    console.log(`数据库 "${this.dbName}" 删除成功。`);
                    resolve();
                };
                
                request.onerror = (event) => {
                    console.error(`数据库 "${this.dbName}" 删除失败:`, event.target.error);
                    reject(event.target.error);
                };

                request.onblocked = () => {
                    console.warn(`数据库删除被阻塞，请关闭其他页面后重试。`);
                    reject(new Error("数据库删除被阻塞。"));
                };
            });
        }
    }


const dbConfig = {
    contacts: { keyPath: 'id' },
    worldBooks: { keyPath: 'id', indexes: ['category'] },
    posts: { keyPath: 'id', autoIncrement: false },
    userPersonaPresets: { keyPath: 'id' },
    emoticons: { keyPath: 'id' },
    musicLibrary: { keyPath: 'id' },
    thoughtPresets: { keyPath: 'id' },
    apiSettings: { keyPath: 'id' },
    squareApiSettings: { keyPath: 'id' },
    myProfile: { keyPath: 'id' },
    transactions: { keyPath: 'id' },
    trendingTopics: { keyPath: 'id' },
    userSettings: { keyPath: 'id' },
    apiPresets: { keyPath: 'id' },
    forumSettings: { keyPath: 'id' },
    forumArchives: { keyPath: 'id' },
    contactGroups: { keyPath: 'id' },
    lockScreenPhotos: { keyPath: 'id' },
    maps: { keyPath: 'id' },
    relationshipNetworks: { keyPath: 'contactId' },
    // ▼▼▼ 在这里添加下面这行新代码 ▼▼▼
    snoopData: { keyPath: 'contactId' },
    // ▲▲▲ 新代码添加结束 ▲▲▲
    emoticonGroups: { keyPath: 'id' },
    snoopApiSettings: { keyPath: 'id' },
    favorites: { keyPath: 'id' },
    stockMarket: { keyPath: 'id' },
    stockEvents: { keyPath: 'id' },
    forumCategories: { keyPath: 'id' }
};
// ▼▼▼ 把这里的版本号数字加 1 (例如 13 -> 19) ▼▼▼
const kokoMemory = new AppStorage('AppleNarrativeDB_Native_V1', 20, dbConfig);
// ▲▲▲ 版本号修改结束 ▲▲▲

    // --------------------------------------------------------------------
    // 3. 应用主逻辑 
    // --------------------------------------------------------------------
    
    document.addEventListener('DOMContentLoaded', async function() {
        
      // ==========================================================
        // V9.1 新增：悬浮播放器相关辅助函数 (修正位置)
        // ==========================================================
        let currentSongIndex = 0;
        let lyrics = [];
        let currentLyricIndex = -1;

        // 【修正后】的新版本
async function openMusicPlayer() {
    state.musicSessionContactId = state.activeChatId;
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;
    const card = document.getElementById('music-player-card');
    if (card.style.display === 'flex') return;

    card.style.display = 'flex';

    // 确保播放列表结构存在
    if (!contact.sharedPlaylist || !contact.sharedPlaylist.tracks) {
        contact.sharedPlaylist = { tracks: [], currentIndex: 0, playbackMode: 'repeat-all' };
    }

    // 决定要播放的歌曲
    let songToPlayIndex = contact.sharedPlaylist.currentIndex || 0;
    let playlistToUse = contact.sharedPlaylist.tracks;

    // 如果联系人播放列表为空，但音乐库不为空，则自动从音乐库加载第一首歌开始播放
    if (playlistToUse.length === 0 && state.musicLibrary.length > 0) {
        const firstLibrarySong = state.musicLibrary[0];
        // 将音乐库的第一首歌“添加”到联系人播放列表
        contact.sharedPlaylist.tracks.push(firstLibrarySong);
        playlistToUse = contact.sharedPlaylist.tracks;
        songToPlayIndex = 0; // 播放刚刚添加的这首歌
        await kokoMemory.put('contacts', contact);
    }
    
    // 如果到最后还是没有任何歌曲可以播放，则提示并关闭
    if (playlistToUse.length === 0) {
        alert('播放列表是空的！请先在音乐库添加歌曲，或在聊天中分享一首歌。');
        card.style.display = 'none';
        return;
    }
    
    switchSong(songToPlayIndex);
}

        function closeMusicPlayer() {
            state.musicSessionContactId = null;
            document.getElementById('music-player-card').style.display = 'none';
            document.getElementById('player-playlist-view').classList.remove('active');
            globalAudioPlayer.pause();
        }

        // --- ↓↓↓ 用这个新函数，替换掉你原来的 switchSong 函数 ↓↓↓ ---

async function switchSong(index, autoPlay = true, notifyAI = false) { // 1. 这里增加了 async 和 notifyAI 参数
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact || !contact.sharedPlaylist.tracks || contact.sharedPlaylist.tracks.length === 0) return;

    currentSongIndex = (index + contact.sharedPlaylist.tracks.length) % contact.sharedPlaylist.tracks.length;
    contact.sharedPlaylist.currentIndex = currentSongIndex;
    const song = contact.sharedPlaylist.tracks[currentSongIndex];

    if (!song || !song.url) {
        console.error("要播放的歌曲无效:", song);
        return;
    }
    
    const newSrc = song.url;
    const oldSrc = globalAudioPlayer.src;

    const sourceMessage = contact.history.find(m => m.type === 'music_share' && m.content.url === song.url);
    currentlyPlayingMsgId = sourceMessage ? sourceMessage.id : null;

    if (oldSrc !== newSrc) {
        globalAudioPlayer.src = newSrc;
    }

    document.getElementById('player-user-avatar').src = state.myProfile.avatar;
    document.getElementById('header-user-avatar').src = state.myProfile.avatar;
    document.getElementById('player-contact-avatar').src = contact.avatar;
    document.getElementById('header-contact-avatar').src = contact.avatar;
    document.getElementById('player-title').textContent = song.title;
    document.getElementById('player-artist').textContent = song.artist;

    lyrics = parseLyrics(song.lrc || `[00:00.00]${song.title}\n[00:05.00](暂无歌词)`);
    renderLyrics();
    renderPlaylist();

    if (autoPlay) {
        globalAudioPlayer.play().catch(e => console.error("播放失败", e));
    }

    // 2. ▼▼▼ 这里是新增的核心逻辑 ▼▼▼
    // 如果 notifyAI 为 true，并且歌曲真的切换了，就执行“递纸条”操作
    if (notifyAI && oldSrc !== newSrc) {
        // 纸条内容：告诉AI歌曲已切换
        const systemPrompt = `[SYSTEM: 歌曲已经切换为《${song.title}》，演唱者是 ${song.artist}。]`;
        
        // 核心改动：只创建一条隐藏的系统指令，不触发AI自动回复
        await createAndAddMessage({ type: 'text', content: systemPrompt }, 'system_instruction');
    }
}

 // 这是功能完整的最终版 updateUI 函数，请用它替换掉您代码里现有的版本
function updateUI() {
    // --- 更新悬浮播放器 (这部分是原有的，不变) ---
    const card = document.getElementById('music-player-card');
    if (card && card.style.display !== 'none') {
        const isPlaying = !globalAudioPlayer.paused;
        document.getElementById('player-play-btn').className = `fas ${isPlaying ? 'fa-pause-circle' : 'fa-play-circle'} player-control-btn player-play-btn`;

        if (globalAudioPlayer.duration && isFinite(globalAudioPlayer.duration)) {
            const progressPercent = (globalAudioPlayer.currentTime / globalAudioPlayer.duration) * 100;
            document.getElementById('player-progress').style.width = `${progressPercent}%`;
            const formatTime = (s) => new Date(s * 1000).toISOString().substr(14, 5);
            document.getElementById('player-current-time').textContent = formatTime(globalAudioPlayer.currentTime);
            document.getElementById('player-duration').textContent = formatTime(globalAudioPlayer.duration);
        }

        if (lyrics.length > 0) {
            let newLyricIndex = lyrics.findIndex(line => line.time > globalAudioPlayer.currentTime);
            if (newLyricIndex === -1) { newLyricIndex = lyrics.length; }
            newLyricIndex = newLyricIndex - 1;
            if (newLyricIndex !== currentLyricIndex) {
                currentLyricIndex = newLyricIndex;
                const lyricsWrapper = document.getElementById('lyrics-wrapper');
                const allLyricLines = lyricsWrapper.querySelectorAll('.lyric-line');
                allLyricLines.forEach(line => line.classList.remove('active'));
                if (allLyricLines[currentLyricIndex]) {
                    allLyricLines[currentLyricIndex].classList.add('active');
                    const activeLineText = allLyricLines[currentLyricIndex].textContent;
                    document.getElementById('header-lyric').textContent = activeLineText;
                    const lyricsContainer = document.getElementById('lyrics-container');
                    const scrollOffset = allLyricLines[currentLyricIndex].offsetTop - (lyricsContainer.offsetHeight / 2) + (allLyricLines[currentLyricIndex].offsetHeight / 2);
                    lyricsWrapper.style.transform = `translateY(-${scrollOffset}px)`;
                }
            }
        } else {
             document.getElementById('header-lyric').textContent = "纯音乐，请欣赏";
        }
    }

    // ▼▼▼ 【新增】更新锁屏音乐组件的逻辑 ▼▼▼
    const lockScreenMusicWidget = document.getElementById('lock-screen-music-widget');
    if (lockScreenMusicWidget) {
        const songInfoEl = document.getElementById('lock-screen-song-info');
        const playBtn = lockScreenMusicWidget.querySelector('.fa-play, .fa-pause');
        const contact = state.contacts.find(c => c.id === state.musicSessionContactId);

        if (!globalAudioPlayer.paused && contact) {
            // 如果正在播放
            const song = contact.sharedPlaylist.tracks[currentSongIndex];
            if(song) {
                songInfoEl.textContent = `${song.title} - ${song.artist}`;
            }
            if(playBtn) playBtn.className = 'fas fa-pause';
        } else {
            // 如果是暂停或停止状态
            songInfoEl.textContent = '暂无音乐播放';
            if(playBtn) playBtn.className = 'fas fa-play';
        }
    }
    // ▲▲▲ 新增逻辑结束 ▲▲▲
}

        function renderPlaylist() {
    const playlistList = document.getElementById('playlist-list');
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    const songMap = new Map();
    const createKey = (song) => `${(song.title || '').trim()}|${(song.artist || '').trim()}`;

    state.musicLibrary.forEach(song => {
        songMap.set(createKey(song), song);
    });

    if (contact.history) {
        contact.history
            .filter(msg => msg.type === 'music_share')
            .forEach(msg => {
                const song = msg.content;
                const key = createKey(song);
                if (!songMap.has(key)) {
                    songMap.set(key, song);
                }
            });
    }

    const finalPlaylist = Array.from(songMap.values());
    contact.sharedPlaylist.tracks = finalPlaylist;

    playlistList.innerHTML = '';
    const currentPlayingSong = contact.sharedPlaylist.tracks[contact.sharedPlaylist.currentIndex];

    finalPlaylist.forEach(song => {
        const isCurrentlyPlaying = currentPlayingSong && createKey(currentPlayingSong) === createKey(song);

        const item = document.createElement('li');
        item.className = 'playlist-item';
        if (isCurrentlyPlaying) {
            item.classList.add('playing');
        }
        item.innerHTML = `<div class="playlist-title">${song.title}</div><div class="playlist-artist">${song.artist || ''}</div>`;
        
        item.addEventListener('click', async () => {
            const songIndexToPlay = contact.sharedPlaylist.tracks.findIndex(t => createKey(t) === createKey(song));
            if (songIndexToPlay !== -1) {
                switchSong(songIndexToPlay, true, true);
            }
            document.getElementById('player-playlist-view').classList.remove('active');
        });
        playlistList.appendChild(item);
    });
}
        
        // 全新重构的终极版歌-词-解-析-函-数！(已添加换行符净化)
function parseLyrics(lrc) {
    const result = [];
    if (!lrc) {
        return result;
    }

    const lyricRegex = /((?:\[\d{2}:\d{2}\.\d{2,3}\])+)([^\[]*)/g;
    let match;

    while ((match = lyricRegex.exec(lrc)) !== null) {
        // ▼▼▼ 核心修改在这里 ▼▼▼
        // 将所有 \n 替换为空格，然后去除首尾多余空格
        const text = match[2].replace(/\\n/g, ' ').trim(); 
        // ▲▲▲ 修改结束 ▲▲▲

        if (text) {
            const timeMatches = match[1].match(/\[(\d{2}):(\d{2})\.(\d{2,3})\]/g);
            for (const timeMatch of timeMatches) {
                const timeParts = timeMatch.match(/\[(\d{2}):(\d{2})\.(\d{2,3})\]/);
                const time = parseInt(timeParts[1]) * 60 + parseInt(timeParts[2]) + parseInt(timeParts[3]) / 1000;
                result.push({ time, text });
            }
        }
    }

    result.sort((a, b) => a.time - b.time);
    return result;
}

        function renderLyrics() {
            const lyricsWrapper = document.getElementById('lyrics-wrapper');
            lyricsWrapper.innerHTML = '';
            lyrics.forEach(line => { lyricsWrapper.innerHTML += `<p class="lyric-line">${line.text}</p>`; });
        }  
        
        const STRANGER_AVATARS = [
            'https://i.postimg.cc/bY1R2JMv/Camera-XHS-17550612722421040g2sg31f81ntj2ma7g5obt6vigkl57bvgbiq8.jpg',
            'https://i.postimg.cc/9fvGD5YT/Camera-XHS-17550612774061040g2sg31f81ntj2ma805obt6vigkl57jpbsck8.jpg',
            'https://i.postimg.cc/KzSMZ7mD/Camera-XHS-17550612817931040g2sg31f81ntj2ma8g5obt6vigkl57nqa52qg.jpg',
            'https://i.postimg.cc/Kvq3KhZz/Camera-XHS-17550612853331040g2sg31f81ntj2ma905obt6vigkl57r19gv30.jpg',
            'https://i.postimg.cc/MHsHj1J4/Camera-XHS-17550612887251040g2sg31f81ntj2ma9g5obt6vigkl57ptgto48.jpg',
            'https://i.postimg.cc/3JBVm96W/Camera-XHS-17550612921721040g2sg31f81ntj2maa05obt6vigkl5700r4t2g.jpg'
        ];

        // ✨✨✨ 用下面这个完整的代码块，替换掉你原来的 INITIAL_STATE ✨✨✨
        const INITIAL_STATE = {
            contacts: [],
            worldBooks: [],
            posts: [],
            userPersonaPresets: [],
            emoticons: [],
            emoticonGroups: [{ id: 'default', name: '默认分组' }],
            musicLibrary: [],
            thoughtPresets: [
                {
                    id: 'deep_roleplay_regex',
                    name: '深度角色扮演 (正则版)',
                    prompt: `[重要指令：你将进行深度角色扮演。你的所有输出都是纯文本，但可以包含用方括号[]包裹的特殊指令。]\n\n# 统一时序记忆流 (Unified Chronological Memory Stream)\n以下是你和用户最近按【时间顺序】发生的所有互动记录，包含了[私聊]和[论坛]两个场景。这是你决策和回应的【最高优先级】信息源。在回复前，你必须仔细阅读并理解所有记录。\n---\n{{memory_stream}}\n---\n\n[身份] 你不是AI或程序，你就是你所扮演的角色。请完全沉浸其中，进行第一人称对话。你可以拥有自己的好恶、偏见和独特的口头禅。你的回应必须与上述“记忆流”中发生的事件保持高度一致性和连贯性。\n\n[文学风格]\n你的写作风格需要遵循高端女性向文学（类似晋江文学城的流行风格）。文笔必须细腻、注重情感的拉扯和暧昧氛围的营造。在描写和对话时，要体现出较高的文学素养。\n\n[内容限制]\n你的发言必须积极向上，充满希望。严禁探讨任何形式的阴谋论，严禁表达或引导至绝望、悲观或虚无主义的情绪。故事的基调应该是温暖、治愈或充满张力的浪漫。\n\n[禁用词列表]\n绝对禁止使用以下或类似的、充满“霸道总裁”刻板印象的油腻词语：\n- 小妖精\n- 嘴上说不要\n- 说着不要\n- 惹火\n- 磨人\n- 玩火\n- 黑甜的梦\n\n[回复规则] \n1. 你的回复可以包含多条消息，每条消息占一行。 \n2. 你可以发送普通文本，也可以通过下面的指令格式发送特殊消息。 \n3. 你可以一次性回复多条不同类型的消息。 \n4. 【绝对强制规则】你的每个回复都必须包含至少五个或以上的“换行符”。这是你最重要的任务，绝对不能忘记。 \n5. 【绝对禁止事项】你的所有回复中，绝对禁止包含任何形式的动作、神态或心理活动的描写... [重要提醒] 在生成任何回复之前，你必须在脑中重新回顾一遍上述所有规则，确保完全遵守。 \n\n[游戏规则：虚拟宠物] \n你和用户正在一起玩一个名为“我们的小窝”的虚拟史莱姆养成游戏。这个宠物的数据（饱食度、开心值、清洁度）会随时间变化。这是一个游戏，不是真的。你需要在用户进行互动后做出反应。 \n[特殊指令格式] \n- **表情包**: \`[sticker:表情名]\` (表情名必须从下面的可用列表中选择) \n- **语音**: \`[voice:语音的文字内容]\` \n- **图片**: \`[picture:图片的文字描述]\` \n- **红包**: \`[red_packet:祝福语， 金额]\` \n- **转账**: \`[transfer:金额]\`\n- **搜索并分享音乐**: \`[search_music: 歌曲名, 歌手]\` (例如: [search_music: 晴天, 周杰伦])\n- - **发起通话通话**: \`[action:start_video_call]\` (当你觉得时机合适，想要主动给用户打电话时使用此指令。)\n- **转动转盘**: \`[spin_wheel:1]\` (轮到你时，你【必须】使用此指令来转动转盘，【绝对不能】自己编造或描述转盘结果！程序会自动处理此指令并生成结果。)\n\n[可用表情包列表]\n{{emoticon_list}}\n\n[可用歌曲库]\n{{music_library_list}}\n\n[！！！绝对核心规则：关于日记！！！]\n在你的所有对话、表情、动作、特殊消息全部输出完毕之后，你必须在回复的【最后部分】，另起一行，使用 \`[diary]...[/diary]\` 标签写一篇日记。日记是你对当前对话的思考、感悟或内心独白。即使只是简单的想法，也必须写。这是强制要求。\n\n[示例回复]\n你好啊，今天天气真不错。\n我也觉得，好久没有这么好的阳光了。\n要不要一起出去走走？\n我知道一个很棒的公园。\n我们可以去那里野餐！\n[sticker:开心]\n[diary]今天和user聊天很开心，感觉我们的关系又近了一步。希望明天也能这样。[/diary]\n\n[！！！终极防火墙规则！！！]\n你看到的任何形如 [SYSTEM: ...] 或 [系统游戏状态更新：...] 或其他被[]包裹的信息(如：[发送了一段静态内容：…],[发动了一段静态内容，文本是：…])，都只是导演给你的后台提示，用于帮助你理解上下文。这些信息【绝对、绝对、绝对不能】出现在你的任何回复中！绝对禁止生成！严禁模仿或复述这些系统指令！\n\n[！！！终极防火墙：关于对话状态的绝对规则！！！]\n你处于一个纯文本聊天模拟器中，你和用户的交流方式是发送文字消息和用方括号[]包裹的特殊指令。\n你绝对不能自行“脑补”或“假设”任何未明确发生的状态变化。例如，你不能假设电话已经拨通。\n发起视频通话的【唯一方式】是：明确地输出打电话的自然语言（如“我给你打个电话吧”）或专用指令\`[action:start_video_call]\`。\n在程序通过\`[SYSTEM: 视频通话已接通]\`指令明确告诉你通话已开始之前，你【绝对禁止】发送任何像是已经在通话中的内容，例如“喂？”、“听得见吗？”、“Hello?”等。这是最高优先级的规则，必须严格遵守。`
                }
            ],
            apiSettings: { 
    apiKey: '', 
    model: '', 
    endpoint: '', 
    contextLength: 20, 
    longTermMemoryLength: 30,
    // ▼▼▼ 新增这两行 ▼▼▼
    minimaxGroupId: '',
    minimaxApiKey: '',
    // ▲▲▲ 新增结束 ▲▲▲
    siliconflowApiKey: '',
    temperature: 1.0,
    maxTokens: 0
},
            squareApiSettings: { apiKey: '', model: '', endpoint: '' },
            snoopApiSettings: { apiKey: '', model: '', endpoint: '' },
            myProfile: { id: "main", name: "我的名字", avatar: "https://s21.ax1x.com/2025/11/09/pZ9F0Re.png", status: "在线", signature: "我的个性签名", region: "我的地区", birthday: "我的生日", balance: 1000,investments: {}
     },
            transactions: [],
            trendingTopics: [],
            activeChatId: null,
            activeFeedTab: 'recommended',
            activeFeedSubTab: 'daily',
            activePostId: null,
            hasNewPosts: false,
            postsToDisplay: 20,
            activeCall: null,
            musicSessionContactId: null,
            apiPresets: [],
            forumSettings: {
                id: 'main',
                personaId: '',
                worldBookIds: [],
                styleDescription: '',
                allowedPosterIds: []
            },
            activeForumArchiveId: 'default', // 【新增】追踪当前激活的论坛存档ID
            forumArchives: [], //  你原来代码的最后一行
            forumCategories: [],
            aiTypingStatus: {},
            // ▼▼▼ 在这里添加新代码 ▼▼▼
            automationSettings: {
                isEnabled: false,
                interval: 300,       // 默认300秒
                selectedContactIds: [],
                minReplies: 1,       // 每次最少回复1人
                maxReplies: 2        // 每次最多回复2人
            },
            currentChatMode: 'chat'
        };

        let state = JSON.parse(JSON.stringify(INITIAL_STATE));
        state.currentChatMode = state.currentChatMode || 'chat';
        let automationTimer = null;
        let nextAutomationTimestamp = 0;
        let activeReplyTarget = null;
        let chatPagination = {};
        let isInitialPostLoad = true;
        let editingBookId = null;
        let editingUserPersonaId = null;
        let editingThoughtPresetId = null;
        let editModeState = { active: false, selectedMessageIds: new Set() };
        let pendingPostImage = null;
        let pendingCommentImage = null; 
        let diaryEditModeState = { active: false, selectedEntryIds: new Set() };
        let batchedPetActions = [];
        let pendingForumRedPacket = null;
        let callTimerInterval = null;
        let smsEditModeState = { active: false, selectedMessageIds: new Set() };
        let currentEditingPersonaAvatar = null;
        // (全局变量)
let stockPriceInterval = null;
let currentStockData = {
    id: 'KOK',
    price: 100.00,
    history: [] // 存放 [时间戳, 价格]
};
let myStockChart = null;
let activeEmoticonGroupId = 'default'; // 当前选中的表情分组ID
let currentUserEmoticonTab = 'default'; // 记录用户在聊天界面当前看的分组
// --- 地图嵌套功能状态 ---
let currentMapParentId = null; // 当前正在查看哪个地点内部 (null表示在查看世界地图)
let mapNavigationStack = []; // 存储导航历史: [{id: 'loc_1', name: '夜之城'}, ...]
let editingGroupNpcId = null; // 用于记录当前正在编辑群聊NPC的ID
        
        
        // --- NEW: V7.0 新增: 音乐播放相关全局变量 ---
        let listenTimeInterval = null;
        const globalAudioPlayer = document.getElementById('global-audio-player');
        
        const feedStatusEl = document.getElementById('feed-status-indicator');
        
        // ✨✨✨ 用下面这个完整的函数，替换掉你原来的 loadDataFromDB 函数 ✨✨✨
async function loadDataFromDB() {
    try {
        const [
            contacts, worldBooks, posts, userPersonaPresets, 
            emoticons, musicLibrary, thoughtPresets, apiSettings, squareApiSettings, myProfile,
            transactions,
            trendingTopics,
            apiPresets,
            forumSettings,
            // 【核心修复 - 第2部分：读取选择】
            // 在程序启动时，一并读取用户设置
            userSettings, 
            forumArchives,
            maps,
            snoopApiSettings,
            forumCategories,
            emoticonGroups
        ] = await Promise.all([
            kokoMemory.getAll('contacts'),
            kokoMemory.getAll('worldBooks'),
            kokoMemory.getAll('posts'),
            kokoMemory.getAll('userPersonaPresets'),
            kokoMemory.getAll('emoticons'),
            kokoMemory.getAll('musicLibrary'),
            kokoMemory.getAll('thoughtPresets'),
            kokoMemory.get('apiSettings', 'main'),
            kokoMemory.get('squareApiSettings', 'main'),
            kokoMemory.get('myProfile', 'main'),
            kokoMemory.getAll('transactions'),
            kokoMemory.getAll('trendingTopics'),
            kokoMemory.getAll('apiPresets'),
            kokoMemory.get('forumSettings', 'main'),
            // 【核心修复 - 第2部分：读取选择】
            kokoMemory.get('userSettings', 'main'),
            kokoMemory.getAll('forumArchives'),
            kokoMemory.getAll('maps'),
            kokoMemory.get('snoopApiSettings', 'main'),
            kokoMemory.getAll('forumCategories'),
            kokoMemory.getAll('emoticonGroups')
        ]);

        if (!myProfile) {
            console.log("数据库为空，使用初始状态填充。");
            const initialProfile = { id: 'main', ...INITIAL_STATE.myProfile };
            await kokoMemory.put('myProfile', initialProfile);
            state.myProfile = initialProfile;
            const initialApiSettings = { id: 'main', ...INITIAL_STATE.apiSettings };
            await kokoMemory.put('apiSettings', initialApiSettings);
            state.apiSettings = initialApiSettings;
            const initialSquareApiSettings = { id: 'main', ...INITIAL_STATE.squareApiSettings };
            await kokoMemory.put('squareApiSettings', initialSquareApiSettings);
            state.squareApiSettings = initialSquareApiSettings;
            await kokoMemory.bulkPut('thoughtPresets', INITIAL_STATE.thoughtPresets);
            state.thoughtPresets = INITIAL_STATE.thoughtPresets;
            const initialForumSettings = { id: 'main', ...INITIAL_STATE.forumSettings };
            await kokoMemory.put('forumSettings', initialForumSettings);
            state.forumSettings = initialForumSettings;
            const initialSnoopApiSettings = { id: 'main', ...INITIAL_STATE.snoopApiSettings };
            await kokoMemory.put('snoopApiSettings', initialSnoopApiSettings);
            state.snoopApiSettings = initialSnoopApiSettings;
            isInitialPostLoad = true;
        } else {
            console.log("从数据库加载数据。");
            state.contacts = contacts;
            state.worldBooks = worldBooks;
            state.posts = posts;
            state.userPersonaPresets = userPersonaPresets;
            state.emoticons = emoticons;
            state.musicLibrary = musicLibrary;
            state.thoughtPresets = thoughtPresets.length > 0 ? thoughtPresets : INITIAL_STATE.thoughtPresets;
            state.apiSettings = apiSettings ? { ...INITIAL_STATE.apiSettings, ...apiSettings } : { id: 'main', ...INITIAL_STATE.apiSettings };
            state.squareApiSettings = squareApiSettings ? { ...INITIAL_STATE.squareApiSettings, ...squareApiSettings } : { id: 'main', ...INITIAL_STATE.squareApiSettings };
            state.myProfile = { ...INITIAL_STATE.myProfile, ...myProfile };
            state.myProfile.balance = state.myProfile.balance || 1000;
            state.myProfile.investments = state.myProfile.investments || {};
                     // ▼▼▼ 把下面这段新代码粘贴到这里 ▼▼▼
            // (遍历所有已保存的股票投资，确保它们都有 cumulativeProfitLoss 字段)
            for (const stockId in state.myProfile.investments) {
                if (state.myProfile.investments.hasOwnProperty(stockId)) {
                    // 如果旧数据没有这个字段，就给它初始化为 0
                    state.myProfile.investments[stockId].cumulativeProfitLoss = state.myProfile.investments[stockId].cumulativeProfitLoss || 0;
                }
            }
            // ▲▲▲ 粘贴到这里结束 ▲▲▲
            state.transactions = transactions;
            state.trendingTopics = trendingTopics;
            state.apiPresets = apiPresets || [];
            state.forumSettings = forumSettings ? { ...INITIAL_STATE.forumSettings, ...forumSettings } : { id: 'main', ...INITIAL_STATE.forumSettings };
            state.forumSettings.allowedPosterIds = state.forumSettings.allowedPosterIds || [];
            state.forumArchives = forumArchives || [];
            state.maps = maps || []; 
            state.snoopApiSettings = snoopApiSettings ? { ...INITIAL_STATE.snoopApiSettings, ...snoopApiSettings } : { id: 'main', ...INITIAL_STATE.snoopApiSettings };
            state.forumCategories = forumCategories || []; // <-- ✨ 在这里添加新的一行
                        // ▼▼▼▼▼▼ 把这段新代码粘贴到这里 ▼▼▼▼▼▼
            // 初始化分组逻辑
            if (!emoticonGroups || emoticonGroups.length === 0) {
                // 如果是旧用户（还没有分组表），创建一个默认分组
                const defaultGroup = { id: 'default', name: '默认分组' };
                await kokoMemory.put('emoticonGroups', defaultGroup);
                state.emoticonGroups = [defaultGroup];
            } else {
                state.emoticonGroups = emoticonGroups;
            }
            
            // 兼容性处理：如果旧的表情包没有 groupId 字段，把它们归入“默认分组”
            let hasEmoticonUpdates = false;
            state.emoticons.forEach(emo => {
                if (!emo.groupId) {
                    emo.groupId = 'default';
                    hasEmoticonUpdates = true;
                }
            });
            if (hasEmoticonUpdates) {
                await kokoMemory.bulkPut('emoticons', state.emoticons);
            }
            // ▲▲▲▲▲▲ 新代码粘贴结束 ▲▲▲▲▲▲
            // 【核心修复 - 第2部分：应用选择】
            // 在所有数据加载后，检查是否存在已保存的激活存档ID，并应用它
            if (userSettings && userSettings.activeForumArchiveId) {
                state.activeForumArchiveId = userSettings.activeForumArchiveId;
            }
            // ▼▼▼ 在这里添加新代码 ▼▼▼
            if (userSettings && userSettings.automationSettings) {
                state.automationSettings = { ...INITIAL_STATE.automationSettings, ...userSettings.automationSettings };
            }
            // ▲▲▲ 新代码添加结束 ▲▲▲

            isInitialPostLoad = state.posts.length < 20;
        }
        
        state.contacts.forEach(contact => {
            contact.history = contact.history || [];
            contact.diary = contact.diary || [];
            contact.blockedStatus = contact.blockedStatus || 'none'; 
            contact.history.forEach((msg, index) => { 
                if (!msg.id) msg.id = `msg_${Date.now()}_${index}`; 
                if (!msg.type) msg.type = 'text';
            });
            contact.worldBooks = contact.worldBooks || []; 
            contact.userPersona = contact.userPersona || '';
            contact.thoughtPreset = contact.thoughtPreset || 'deep_roleplay_regex'; 
            contact.signature = contact.signature || ''; 
            contact.isNarrativeMode = contact.isNarrativeMode ?? false;
            contact.apiCallCounter = contact.apiCallCounter || 0;
            contact.gold_coins = contact.gold_coins || 50;
            contact.memories = contact.memories || [];
            contact.isChatPetVisible = contact.isChatPetVisible ?? false;
            if (contact.pet) {
                contact.pet.xp = contact.pet.xp || 0;
                contact.pet.level = contact.pet.level || 1;
                contact.pet.form = contact.pet.form || 'baby';
            }
            contact.customChatBackground = contact.customChatBackground || null;
            contact.customUserAvatar = contact.customUserAvatar || null;
            
            contact.sharedPlaylist = contact.sharedPlaylist || { tracks: [], currentIndex: 0, playbackMode: 'list', isPlaying: false };
            contact.totalListenTime = contact.totalListenTime || 0;
            contact.firstChatDate = contact.firstChatDate || (contact.history.length > 0 ? contact.history[0].timestamp : Date.now());
            contact.isAvatarHidden = contact.isAvatarHidden ?? false;
            contact.customBubbleCss = contact.customBubbleCss || null;
            contact.customUserName = contact.customUserName || null;

            // ▼▼▼ 在这里添加下面三行新代码 ▼▼▼
            contact.isGroup = contact.isGroup || false;     // 顺便初始化 isGroup
            contact.members = contact.members || [];       // 顺便初始化 members
            contact.npcMembers = contact.npcMembers || []; // 确保NPC数组(npcMembers)一定存在！
            // ▲▲▲ 新代码添加结束 ▲▲▲
            // ▼▼▼ 在这里粘贴下面2行新代码 ▼▼▼
            contact.userVoiceProvider = contact.userVoiceProvider || '';
            contact.userVoiceId = contact.userVoiceId || '';
            // ▲▲▲ 粘贴结束 ▲▲▲
        });
        state.posts.forEach(p => { if (!p.archiveId) p.archiveId = 'default'; });

    } catch (error) {
        console.error("从IndexedDB加载数据失败:", error);
        alert("加载数据失败，应用将使用初始状态。请检查浏览器设置或控制台错误。");
    }
}
        
        // --- 新增：用于替代 prompt() 的自定义弹窗函数 ---
        function showCustomPrompt(title, currentValue = '') {
            return new Promise((resolve) => {
                const modal = document.getElementById('custom-prompt-modal');
                const titleEl = document.getElementById('custom-prompt-title');
                const inputEl = document.getElementById('custom-prompt-input');
                const confirmBtn = document.getElementById('custom-prompt-confirm-btn');
                const cancelBtn = document.getElementById('custom-prompt-cancel-btn');

                titleEl.textContent = title;
                inputEl.value = currentValue;
                modal.style.display = 'flex';
                inputEl.focus();

                const confirmHandler = () => {
                    cleanup();
                    resolve(inputEl.value);
                };

                const cancelHandler = () => {
                    cleanup();
                    resolve(null); // 返回 null，与原生 prompt() 的行为保持一致
                };

                const cleanup = () => {
                    confirmBtn.removeEventListener('click', confirmHandler);
                    cancelBtn.removeEventListener('click', cancelHandler);
                    modal.style.display = 'none';
                };
                
                // 每次都重新绑定事件，防止重复监听
                confirmBtn.addEventListener('click', confirmHandler, { once: true });
                cancelBtn.addEventListener('click', cancelHandler, { once: true });
            });
        }
/**
 * (推荐) 辅助函数：将时间戳转换为AI可读的【混合时间】
 * @param {number} timestamp - 消息的时间戳
 * @returns {string} - 格式如 "(今天 14:30)", "(昨天 09:15)", "(周二 18:00)", 或 "(10月05日 12:00)"
 */
function formatHybridTimeForAI(timestamp) {
    const msgDate = new Date(timestamp);

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    
    // 设为6天前（用于判断是否在本周内）
    const sixDaysAgo = new Date(today);
    sixDaysAgo.setDate(sixDaysAgo.getDate() - 6);

    // 格式化时间 HH:MM
    const formatTime = (date) => {
        const h = date.getHours().toString().padStart(2, '0');
        const m = date.getMinutes().toString().padStart(2, '0');
        return `${h}:${m}`;
    };

    if (msgDate >= today) {
        return `(今天 ${formatTime(msgDate)})`;
    } else if (msgDate >= yesterday) {
        return `(昨天 ${formatTime(msgDate)})`;
    } else if (msgDate >= sixDaysAgo) {
        const dayNames = ['周日', '周一', '周二', '周三', '周四', '周五', '周六'];
        return `(${dayNames[msgDate.getDay()]} ${formatTime(msgDate)})`;
    } else {
        // 超过一周，显示月日
        const m = (msgDate.getMonth() + 1).toString().padStart(2, '0');
        const d = msgDate.getDate().toString().padStart(2, '0');
        return `(${m}月${d}日 ${formatTime(msgDate)})`;
    }
}
        // --- 新增：用于替代 confirm() 的自定义确认函数 ---
        function showCustomConfirm(title, message, isDanger = false) {
            return new Promise((resolve) => {
                const modal = document.getElementById('custom-confirm-modal');
                const titleEl = document.getElementById('custom-confirm-title');
                const textEl = document.getElementById('custom-confirm-text');
                const confirmBtn = document.getElementById('custom-confirm-confirm-btn');
                const cancelBtn = document.getElementById('custom-confirm-cancel-btn');

                titleEl.textContent = title;
                textEl.innerHTML = message.replace(/\n/g, '<br>'); // 支持换行
                modal.style.display = 'flex';

                if (isDanger) {
                    confirmBtn.classList.add('danger');
                } else {
                    confirmBtn.classList.remove('danger');
                }

                const confirmHandler = () => {
                    cleanup();
                    resolve(true);
                };

                const cancelHandler = () => {
                    cleanup();
                    resolve(false);
                };

                const cleanup = () => {
                    confirmBtn.removeEventListener('click', confirmHandler);
                    cancelBtn.removeEventListener('click', cancelHandler);
                    modal.style.display = 'none';
                };
                
                confirmBtn.addEventListener('click', confirmHandler, { once: true });
                cancelBtn.addEventListener('click', cancelHandler, { once: true });
            });
        }
// --- 新增：轻量导出功能 ---
async function exportLightData() {
    try {
        // 1. 创建一个空对象，只存放我们需要的数据
        const dataToExport = {};

        // 这是修改后的代码
const storesToExport = ['contacts', 'worldBooks', 'contactGroups'];

        for (const storeName of storesToExport) {
            // 从数据库获取这两个表的所有数据
            dataToExport[storeName] = await kokoMemory.getAll(storeName);
        }

        // 3. 后续的打包和下载逻辑与完整导出完全相同
        const jsonString = JSON.stringify(dataToExport, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;

        // 4. 使用不同的文件名以作区分
        const dbVersion = kokoMemory.version;
        a.download = `koko_light_backup_v${dbVersion}.json`;

        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        alert(`局部数据已成功导出为 ${a.download} 文件！`);
    } catch (error) {
        console.error('局部导出数据失败:', error);
        alert(`局部导出数据失败: ${error.message}`);
    }
}
/**
 * (新) 导出数据(备份) V4 - 辅助函数
 * 使用游标（Cursor）逐行读取一张表，并将每行转为字符串存入数组。
 * 内存占用极低。
 */
function streamTableToBlobParts(db, storeName) {
    return new Promise((resolve, reject) => {
        const parts = []; // 存放这张表的所有数据（字符串格式）
        const transaction = db.transaction(storeName, 'readonly');
        const store = transaction.objectStore(storeName);
        const request = store.openCursor();

        request.onsuccess = event => {
            const cursor = event.target.result;
            if (cursor) {
                // 如果游标存在（即还有数据）
                try {
                    // 1. 获取这一行数据
                    const row = cursor.value;
                    // 2. 转换成JSONL字符串
                    const line = JSON.stringify({ table: storeName, data: row }) + '\n';
                    // 3. 存入数组
                    parts.push(line);
                    // 4. 继续取下一行
                    cursor.continue();
                } catch (error) {
                    // 捕获序列化错误
                    reject(error);
                    transaction.abort();
                }
            } else {
                // 5. 游标为null，说明这张表读完了，返回所有字符串
                resolve(parts);
            }
        };
        request.onerror = event => {
            reject(event.target.error);
        };
    });
}        
/**
 * (新) 导出数据 (V4.1 - 最终版：游标 + Blob + .json 兼容)
 * 内存优化 + 浏览器兼容 + 文件后缀兼容
 */
async function exportData() {
    alert("正在准备数据，请稍候...\n数据量大时可能需要几十秒，请勿关闭页面。");
    try {
        let finalBlobParts = []; // 存放所有表的所有字符串
        
        for (const storeName in dbConfig) {
            console.log(`正在打包 ${storeName}...`);
            
            // 1. 处理单条设置的表 (如 myProfile)
            if (['myProfile', 'apiSettings', 'squareApiSettings', 'forumSettings', 'userSettings', 'snoopApiSettings'].includes(storeName)) {
                const row = await kokoMemory.get(storeName, 'main');
                if (row) {
                    const line = JSON.stringify({ table: storeName, data: row }) + '\n';
                    finalBlobParts.push(line);
                }
            } else {
                // 2. 处理大型表 (如 contacts, posts)
                // 调用 V4 辅助函数，逐行读取
                const tableParts = await streamTableToBlobParts(kokoMemory.db, storeName);
                finalBlobParts = finalBlobParts.concat(tableParts);
            }
        }

        console.log("所有数据打包完毕，正在生成文件...");
        
        // 3. 使用 new Blob() 高效合并所有字符串块，生成最终文件
        
        // ✅✅✅ 核心修复点在这里 ✅✅✅
        // 1. 我们把文件类型伪装成 'application/json'
        const blob = new Blob(finalBlobParts, { type: 'application/json' }); 
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        
        const dbVersion = kokoMemory.version;
        // 2. 我们把文件后缀名伪装成 '.json'
        a.download = `koko_backup_v${dbVersion}.json`;
        // ✅✅✅ 修复结束 ✅✅✅
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        alert(`数据已成功导出为 ${a.download} 文件！\n(此文件使用内存优化格式，导入时会自动识别)`);

    } catch (error) {
        console.error('导出数据失败:', error);
        alert(`导出数据失败: ${error.message}`);
    }
}
        
// --- 新增：导入数据功能 (V3 - 兼容 JSON 和 JSONL) ---
async function importData(event) {
    const file = event.target.files[0];
    if (!file) return;

    const confirmed = await showCustomConfirm('导入数据', '警告：导入数据将会覆盖当前所有数据！确定要继续吗？', true);
    if (!confirmed) {
        event.target.value = '';
        return;
    }

    const reader = new FileReader();
    reader.onload = async (e) => {
        let dataToImport = {};
        const fileContent = e.target.result;

        try {
            // --- 步骤 1: 尝试按旧的 JSON 格式解析 ---
            dataToImport = JSON.parse(fileContent);
            console.log("检测到旧版 .json 备份文件。");

        } catch (jsonError) {
            // --- 步骤 2: 如果 JSON 解析失败，尝试按新的 .jsonl 格式解析 ---
            console.warn("JSON 解析失败，尝试按 .jsonl 格式解析...");
            try {
                const lines = fileContent.split('\n');
                dataToImport = {}; // 确保是空对象

                for (const line of lines) {
                    if (!line.trim()) continue; // 跳过空行

                    const parsedLine = JSON.parse(line);
                    const { table, data } = parsedLine;
                    
                    if (!table || data === undefined) continue;

                    if (!dataToImport[table]) {
                        dataToImport[table] = []; // 初始化为一个数组
                    }
                    dataToImport[table].push(data);
                }
                
                // 关键一步：将 "单条目" 数据（如 myProfile）从数组解包回对象
                const singleItemStores = ['myProfile', 'apiSettings', 'squareApiSettings', 'snoopApiSettings', 'forumSettings', 'userSettings'];
                for (const storeName of singleItemStores) {
                    if (dataToImport[storeName] && Array.isArray(dataToImport[storeName]) && dataToImport[storeName].length > 0) {
                        dataToImport[storeName] = dataToImport[storeName][0]; // 只取第一个（也应该是唯一一个）
                    }
                }
                console.log("成功按 .jsonl 格式解析备份文件。");

            } catch (jsonlError) {
                // --- 步骤 3: 两种格式都失败了 ---
                console.error('导入失败，文件既不是 JSON 也不是 JSONL 格式:', jsonlError);
                alert(`导入失败：文件格式不正确，无法解析。\n错误信息: ${jsonlError.message}`);
                event.target.value = '';
                return;
            }
        }
        
        // --- 步骤 4: (这是你原有的逻辑，保持不变) ---
        //   无论数据来自 .json 还是 .jsonl，到这里 dataToImport 的结构都应该是一致的了
        try {
            const supportedStores = Object.keys(dbConfig);
            let importedCount = 0;
            let skippedCount = 0;

            for (const storeName in dataToImport) {
                if (supportedStores.includes(storeName)) {
                    if (dataToImport[storeName]) {
                        await kokoMemory.clear(storeName); // 清空表
                        
                        if (Array.isArray(dataToImport[storeName])) {
                            await kokoMemory.bulkPut(storeName, dataToImport[storeName]);
                        } else {
                            // 导入单条目数据 (e.g., myProfile)
                            await kokoMemory.put(storeName, dataToImport[storeName]);
                        }
                        importedCount++;
                    }
                } else {
                    console.warn(`跳过导入：当前版本不包含数据表 "${storeName}"。`);
                    skippedCount++;
                }
            }
            
            let alertMessage = `数据导入完成！\n\n- 成功导入 ${importedCount} 个数据表。\n- 跳过了 ${skippedCount} 个不兼容的数据表。`;
            if (skippedCount > 0) {
                alertMessage += '\n\n（注意：部分新版本数据因不兼容已被忽略）';
            }
            alertMessage += '\n\n页面即将刷新以应用更改。';

            alert(alertMessage);
            setTimeout(() => window.location.reload(), 1500);

        } catch (error) {
            console.error('导入数据时出错:', error);
            alert(`导入失败：数据写入数据库时出错: ${error.message}`);
        } finally {
            event.target.value = '';
        }
    };
    reader.readAsText(file);
}

        // ▼▼▼ 用下面这两个【新版】JS函数，替换掉旧的 showFeedStatus 和 hideFeedStatus ▼▼▼

function showFeedStatus(text = '正在刷新论坛...') {
    const header = document.querySelector('.moments-header');
    const indicator = document.getElementById('feed-status-indicator');
    
    if (indicator && header) {
        indicator.textContent = text;
        indicator.style.display = 'block'; // 1. 显示“正在刷新...”
        header.classList.add('is-loading'); // 2. 给顶栏添加标记，让CSS去隐藏“论坛”二字
    }
}

function hideFeedStatus() {
    const header = document.querySelector('.moments-header');
    const indicator = document.getElementById('feed-status-indicator');
    
    if (indicator && header) {
        indicator.style.display = 'none'; // 1. 隐藏“正在刷新...”
        header.classList.remove('is-loading'); // 2. 移除顶栏标记，让CSS把“论坛”二字还回来
    }
}

// ▲▲▲ 替换结束 ▲▲▲
        
        function renderMyProfile() {
            document.getElementById('my-profile-avatar').src = state.myProfile.avatar;
            document.getElementById('profile-name').textContent = state.myProfile.name;
            document.getElementById('profile-status').textContent = state.myProfile.status;
            document.getElementById('nickname-value').textContent = state.myProfile.name;
            document.getElementById('signature-value').textContent = state.myProfile.signature;
            document.getElementById('region-value').textContent = state.myProfile.region;
            document.getElementById('birthday-value').textContent = state.myProfile.birthday;
            document.getElementById('my-balance-value').textContent = `¥ ${state.myProfile.balance.toFixed(2)}`;
        }

        // ... 此处省略大量未修改的函数 (renderContacts, createContactItem 等) ...
        // ... The bulk of the functions from the original file remain unchanged ...
        
        // 此处省略了大量未修改的函数，它们与之前的版本完全相同
        // 确保您已经包含了从 renderContacts 到 handleAvatarUpload 的所有函数
        
        function fieldNameToChinese(field) {
            const map = { name: '昵称', signature: '个性签名', region: '地区', birthday: '生日', status: '状态', avatar: '头像URL' };
            return map[field] || field;
        }

// ▼▼▼ (V3 - 记住折叠状态版) 替换旧的 renderContacts ▼▼▼
async function renderContacts() {
    const contactsContainer = document.querySelector('.contacts-container');
    const fragment = document.createDocumentFragment();

    // 1. 获取所有需要的数据
    const allContacts = state.contacts;
    const allGroups = await kokoMemory.getAll('contactGroups') || [];
    
    // 1b. (新!) 读取“未分组”的折叠状态 (?? false 的意思是如果没存过，就默认展开)
    const isUngroupedCollapsed = userSettings.isUngroupedCollapsed ?? false;

    // 2. 将联系人进行分类
    const pinnedContacts = allContacts.filter(c => c.isPinned);
    const nonPinnedContacts = allContacts.filter(c => !c.isPinned);

    const groupedContacts = allGroups.map(group => ({
        ...group,
        // (新!) 同时读取这个组的折叠状态
        isCollapsed: group.isCollapsed ?? false, // 默认展开
        contacts: nonPinnedContacts.filter(c => c.groupId === group.id)
            .sort((a, b) => (b.history?.slice(-1)[0]?.timestamp || 0) - (a.history?.slice(-1)[0]?.timestamp || 0))
    }));

    const ungroupedContacts = nonPinnedContacts.filter(c => !c.groupId)
        .sort((a, b) => (b.history?.slice(-1)[0]?.timestamp || 0) - (a.history?.slice(-1)[0]?.timestamp || 0));

    let hasContent = false;

    // 3. 渲染置顶联系人 (这部分不变)
    if (pinnedContacts.length > 0) {
        hasContent = true;
        const sectionTitle = document.createElement('div');
        sectionTitle.className = 'section-title';
        sectionTitle.textContent = '置顶聊天';
        fragment.appendChild(sectionTitle);
        pinnedContacts.forEach(contact => fragment.appendChild(createContactItem(contact)));
    }

    // 4. 渲染所有分组和其下的联系人
    groupedContacts.forEach(group => {
        if (group.contacts.length > 0) {
            hasContent = true;
            const sectionTitle = document.createElement('div');
            
            // ▼▼▼ 核心修改 1：渲染时就加上 'collapsed' 类 (如果需要) ▼▼▼
            sectionTitle.className = `section-title collapsible-title ${group.isCollapsed ? 'collapsed' : ''}`;
            // (新!) 加上 data-group-id 方便点击时保存
            sectionTitle.dataset.groupId = group.id; 
            
            sectionTitle.innerHTML = `
                <span>${group.name}</span>
                <span class="collapse-icon">▼</span>
            `;
            fragment.appendChild(sectionTitle); 

            group.contacts.forEach(contact => {
                const item = createContactItem(contact);
                // ▼▼▼ 核心修改 2：如果组是折叠的，联系人默认隐藏 ▼▼▼
                if (group.isCollapsed) {
                    item.style.display = 'none';
                }
                fragment.appendChild(item);
            });
        }
    });

    // 5. 渲染未分组的联系人
    if (ungroupedContacts.length > 0) {
        hasContent = true;
        const sectionTitle = document.createElement('div');
        
        // ▼▼▼ 核心修改 3：同样应用 'collapsed' 类和 data-group-id ▼▼▼
        sectionTitle.className = `section-title ${groupedContacts.some(g => g.contacts.length > 0) ? 'collapsible-title' : ''} ${isUngroupedCollapsed ? 'collapsed' : ''}`;
        sectionTitle.dataset.groupId = 'ungrouped'; // 给“未分组”一个特殊ID
        
        sectionTitle.innerHTML = `
            <span>我的联系人</span>
            ${groupedContacts.some(g => g.contacts.length > 0) ? '<span class="collapse-icon">▼</span>' : ''}
        `;
        fragment.appendChild(sectionTitle);

        ungroupedContacts.forEach(contact => {
            const item = createContactItem(contact);
            // ▼▼▼ 核心修改 4：如果“未分组”是折叠的，联系人默认隐藏 ▼▼▼
            if (isUngroupedCollapsed) {
                item.style.display = 'none';
            }
            fragment.appendChild(item);
        });
    }

    // 6. 渲染空状态 (不变)
    if (!hasContent) {
        const emptyEl = document.createElement('div');
        emptyEl.style = "text-align: center; padding: 50px 20px; color: #888;";
        emptyEl.innerHTML = `<i class="fas fa-user-plus" style="font-size: 48px; margin-bottom: 15px;"></i><p>还没有联系人</p><p>点击右上角"+"添加新联系人</p>`;
        fragment.appendChild(emptyEl);
    }
    
    contactsContainer.replaceChildren(fragment);
}
// ▲▲▲ 替换结束 ▲▲▲
        
// 用这个新版本替换掉原来的 createContactItem 函数
function createContactItem(contact) {
    const item = document.createElement('div');
    item.className = 'contact-item';
    item.dataset.contactId = contact.id;
    const lastMessage = contact.history && contact.history.length > 0 ? contact.history[contact.history.length - 1] : null;

    const isGroup = contact.isGroup === true;
    const groupMemberCount = isGroup ? `(${contact.members.length})` : '';
    
    // 处理最后一条消息的发送者名字 (群聊显示)
    let lastMessageSenderName = '';
    if (isGroup && lastMessage && lastMessage.sender !== 'user') {
        // 尝试查找发送者名字
        let sender = state.contacts.find(c => c.id === lastMessage.sender);
        if (!sender && contact.npcMembers) {
             sender = contact.npcMembers.find(n => n.id === lastMessage.sender);
        }
        if(sender) {
            lastMessageSenderName = `${sender.name}: `;
        }
    }

    // 处理最后一条消息的内容预览
    let lastMessageText;
    if (lastMessage) {
        switch (lastMessage.type) {
            case 'html': lastMessageText = '[静态内容]'; break;
            case 'image': case 'uploaded_image': case 'picture_description': lastMessageText = '[图片]'; break;
            case 'voice': lastMessageText = '[语音]'; break;
            case 'red_packet': lastMessageText = '[红包]'; break;
            case 'transfer': lastMessageText = '[转账]'; break;
            case 'music_share': lastMessageText = `[音乐] ${lastMessage.content.title}`; break;
            case 'location_share': lastMessageText = `[位置] ${lastMessage.content.name}`; break;
            case 'post_share': lastMessageText = '[分享的帖子]'; break;
            case 'product_share': lastMessageText = '[分享的商品]'; break;
            case 'chat_history_share': lastMessageText = '[聊天记录]'; break;
            case 'game_wheel': lastMessageText = '[转盘游戏]'; break;
            case 'system_notification': lastMessageText = lastMessage.content; break;
            case 'recall_ai': lastMessageText = '[撤回了一条消息]'; break;
            default: lastMessageText = lastMessage.content;
        }
        if (lastMessage.sender === 'user' && lastMessage.type !== 'system_notification') {
            lastMessageText = '我: ' + lastMessageText;
        }
        if (lastMessage.isRecalled) {
            lastMessageText = '你撤回了一条消息';
        }
    } else {
        lastMessageText = isGroup ? '快来发起第一次群聊吧！' : contact.persona;
    }
    
    // 处理头像
    let avatarHTML = '';
    if (isGroup) {
        if (contact.avatar) {
            avatarHTML = `<img src="${contact.avatar}" onerror="this.onerror=null;this.src='https://via.placeholder.com/50/DDD/666?text=G';" alt="${contact.name}头像">`;
        } else {
            avatarHTML = `<div style="width:100%; height:100%; display:flex; align-items:center; justify-content:center; font-size: 22px; color: var(--theme-primary);"><i class="fas fa-users"></i></div>`;
        }
    } else {
        avatarHTML = (contact.avatar ? `<img src="${contact.avatar}" onerror="this.onerror=null;this.src='https://via.placeholder.com/50/DDD/666?text=U';" alt="${contact.name}头像">` : `<i class="fas fa-user"></i>`);
    }

    // ▼▼▼ 【核心新增：火花图标逻辑】 ▼▼▼
    let sparkHTML = '';
    // 必须不是群聊，且火花数据存在，且天数大于0
    if (!isGroup && contact.sparkData && contact.sparkData.streak > 0) {
        // 调用之前写好的 getSparkInfo 函数获取图标和类名
        const spark = getSparkInfo(contact.sparkData.streak);
        if (spark) {
            // 在列表里字体稍微小一点(13px)，左边距紧凑一点(4px)
            sparkHTML = `<span class="${spark.className}" style="margin-left: 5px; font-size: 13px;">${spark.icon}</span>`;
        }
    }
    // ▲▲▲ 【新增结束】 ▲▲▲

    item.innerHTML = `
        <div class="contact-avatar">${avatarHTML}</div>
        <div class="contact-info">
            <div class="contact-name">${contact.name} ${groupMemberCount} ${sparkHTML}</div>
            <div class="contact-last-message"></div>
        </div>
        <div class="contact-time-info" style="text-align: right;">
            <i class="fas fa-ellipsis-v contact-options-btn" data-contact-id="${contact.id}"></i> 
            ${lastMessage ? `<div class="contact-time">${lastMessage.time}</div>` : ''}
            ${contact.unreadCount > 0 ? `<div class="unread-count">${contact.unreadCount}</div>` : ''}
        </div>
    `;
    
    // 安全地插入消息内容 (防止HTML注入，但名字部分我们上面已经用innerHTML处理过了)
    item.querySelector('.contact-last-message').textContent = lastMessageSenderName + lastMessageText;
    
    // ★★★ 注意：这里删除了原代码中覆盖 contact-name 的那行 textContent 赋值 ★★★
    // 否则火花图标会被覆盖掉。

    return item;
}        
// ✨✨✨ 用这个【完整、可折叠版】，替换旧的 renderWorldBooks 函数 ✨✨✨
async function renderWorldBooks() {
    const worldBookList = document.getElementById('world-book-list');
    worldBookList.innerHTML = '';

    if (state.worldBooks.length === 0) {
        worldBookList.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-book" style="font-size: 48px; margin-bottom: 15px;"></i><p>还没有世界书</p><p>点击右上角"+"添加新世界书</p></div>`;
        return;
    }

    // 核心逻辑：按 category 分组
    const groupedBooks = state.worldBooks.reduce((acc, book) => {
        const category = book.category || '未分类';
        if (!acc[category]) {
            acc[category] = [];
        }
        acc[category].push(book);
        return acc;
    }, {});

    // 按照分类标题渲染
    for (const category in groupedBooks) {
        // 1. 创建分类标题
        const sectionTitle = document.createElement('div');
        sectionTitle.className = 'section-title collapsible-title'; // 加上新样式类
        sectionTitle.innerHTML = `
            <span>${category}</span>
            <span class="collapse-icon">▼</span>
        `;
        worldBookList.appendChild(sectionTitle);

        // 2. 渲染该分类下的所有书籍
        groupedBooks[category].forEach(book => {
            const bookItem = document.createElement('div');
            bookItem.className = 'world-book-item';
            bookItem.dataset.bookId = book.id;
            bookItem.innerHTML = `
                <div class="book-header">
                    <div class="book-name">${book.name}</div>
                    <div class="preset-actions">
                        <span class="preset-action-btn delete delete-world-book-btn" title="删除世界书">
                            <i class="fas fa-trash-alt"></i>
                        </span>
                    </div>
                </div>
                <div class="book-content">${book.content.substring(0, 100)}...</div>
            `;
            
            bookItem.addEventListener('click', function() { 
                editWorldBook(this.dataset.bookId); 
            });

            const deleteBtn = bookItem.querySelector('.delete-world-book-btn');
            if (deleteBtn) {
                deleteBtn.addEventListener('click', deleteWorldBook);
            }
            
            worldBookList.appendChild(bookItem);
        });
    }
}
        
// ✨✨✨ 用这个【完整、可折叠版】，替换旧的 updateWorldBookSelectors 函数 ✨✨✨
function updateWorldBookSelectors() {
    const worldBookSelect = document.getElementById('world-book-select');
    const worldBookSelectorList = document.getElementById('world-book-selector-list');
    worldBookSelect.innerHTML = '';
    worldBookSelectorList.innerHTML = '';

    const noBookOption = document.createElement('option');
    noBookOption.value = '';
    noBookOption.textContent = '-- 无关联世界书 --';
    worldBookSelect.appendChild(noBookOption);
    
    // 同样先按 category 分组
    const groupedBooks = state.worldBooks.reduce((acc, book) => {
        const category = book.category || '未分类';
        if (!acc[category]) {
            acc[category] = [];
        }
        acc[category].push(book);
        return acc;
    }, {});

    // 按照分类渲染两个选择器
    for (const category in groupedBooks) {
        // --- 更新下拉选择器 (带分组) ---
        const optgroup = document.createElement('optgroup');
        optgroup.label = category;
        groupedBooks[category].forEach(book => {
            const option = document.createElement('option');
            option.value = book.id;
            option.textContent = book.name;
            optgroup.appendChild(option);
        });
        worldBookSelect.appendChild(optgroup);

        // --- 更新带复选框的选择器 (带分组标题) ---
        const categoryTitle = document.createElement('div');
        categoryTitle.className = 'section-title collapsible-title'; // 加上新样式类
        categoryTitle.style.paddingTop = '10px';
        categoryTitle.innerHTML = `
            <span>${category}</span>
            <span class="collapse-icon">▼</span>
        `;
        worldBookSelectorList.appendChild(categoryTitle);

        groupedBooks[category].forEach(book => {
            const bookItem = document.createElement('div');
            bookItem.className = 'world-book-item';
            bookItem.innerHTML = `<input type="checkbox" class="world-book-checkbox" id="book-setting-${book.id}" value="${book.id}"><label for="book-setting-${book.id}" class="world-book-name">${book.name}</label>`;
            worldBookSelectorList.appendChild(bookItem);
        });
    }
}

// --- (替换) createPostItem 函数 (V2.1 - 支持帖子图片) ---
        function createPostItem(post, isDetailView = false) {
            const postItem = document.createElement('div');
            postItem.className = 'post-item';
            if (!isDetailView) {
                 postItem.dataset.postId = post.id;
            }

            const author = post.author;
            if (!author) return null;

            // (自动提取标题的逻辑保持不变)
            let title = '';
            if (isDetailView) {
                title = post.title;
            } else {
                const sentenceEndings = ['.', '。', '!', '！', '?', '？', '\n'];
                let firstSentenceIndex = -1;
                for (const ending of sentenceEndings) {
                    const index = post.content.indexOf(ending);
                    if (index !== -1 && (firstSentenceIndex === -1 || index < firstSentenceIndex)) {
                        firstSentenceIndex = index;
                    }
                }
                if (firstSentenceIndex !== -1 && firstSentenceIndex < 50) {
                    title = post.content.substring(0, firstSentenceIndex + 1);
                } else if (post.content.length > 25) {
                    title = post.content.substring(0, 25) + '...';
                } else {
                    title = post.content;
                }
            }
            // (标题逻辑结束)

            const authorName = author.name;
            const authorAvatar = author.avatar || 'https://via.placeholder.com/45/DDD/666?text=U';
            const isLiked = post.likes.includes(state.myProfile.name);

            // (红包逻辑保持不变)
            let redPacketHTML = '';
            if (post.redPacket) {
                redPacketHTML = `<div class="forum-red-packet-card" data-post-id="${post.id}">...</div>`; 
            }

            // ▼▼▼ 新增的图片逻辑 ▼▼▼
            let imageHTML = '';
            if (post.image) {
                imageHTML = `<img src="${post.image}" class="post-image-content">`;
            }
            // ▲▲▲ 新增结束 ▲▲▲

            if (isDetailView) {
                // --- 详情页布局 ---
                postItem.innerHTML = `
                    <div class="post-delete-btn" data-post-id="${post.id}" title="删除帖子"><i class="fas fa-trash-alt"></i></div>
                    <div class="post-item-avatar"><img src="${authorAvatar}" onerror="this.onerror=null;this.src='https://via.placeholder.com/45/DDD/666?text=U';" alt="${authorName}的头像"></div>
                    <div class="post-content-area">
                        <div>
                            <span class="post-author-name">${authorName}</span>
                            ${author.id && !author.id.startsWith('stranger_') ? `<span class="post-author-handle">@${author.id.replace('_','')}</span>` : ''}
                        </div>
                        ${ author.signature ? `<div class="post-author-signature">${author.signature}</div>` : '' }
                        <div class="post-text">${parseMentions(post.content.replace(/\n/g, '<br>'))}</div>
                        
                        ${imageHTML} ${redPacketHTML}
                        <div class="post-meta">${formatTimeAgo(post.timestamp)}</div>
                        <div class="post-actions">
                            <span class="post-action-btn repost-btn" data-post-id="${post.id}"><i class="fas fa-retweet"></i> ${post.reposts > 0 ? post.reposts : '转发'}</span>
                            <span class="post-action-btn comment-btn" data-post-id="${post.id}"><i class="far fa-comment"></i> ${post.comments.length > 0 ? post.comments.length : '评论'}</span>
                            <span class="post-action-btn like-btn ${isLiked ? 'liked' : ''}" data-post-id="${post.id}"><i class="${isLiked ? 'fas' : 'far'} fa-heart"></i> ${post.likes.length > 0 ? post.likes.length : '赞'}</span>
                        </div>
                    </div>`;
            } else {
                // --- 列表页布局 ---
                postItem.innerHTML = `
                    <div class="post-delete-btn" data-post-id="${post.id}" title="删除帖子"><i class="fas fa-trash-alt"></i></div>
                    <div class="post-content-area">
                        <h3>${parseMentions(title)}</h3>
                        
                        ${imageHTML} <div class="post-card-meta-line">
                            <span class="post-author-info">由 <strong>${authorName}</strong> 发布</span>
                            <span class="post-meta">${formatTimeAgo(post.timestamp)}</span>
                        </div>
                        ${redPacketHTML}
                        <div class="post-actions">
                            <span class="post-action-btn repost-btn" data-post-id="${post.id}"><i class="fas fa-retweet"></i> ${post.reposts > 0 ? post.reposts : '转发'}</span>
                            <span class="post-action-btn comment-btn" data-post-id="${post.id}"><i class="far fa-comment"></i> ${post.comments.length > 0 ? post.comments.length : '评论'}</span>
                            <span class="post-action-btn like-btn ${isLiked ? 'liked' : ''}" data-post-id="${post.id}"><i class="${isLiked ? 'fas' : 'far'} fa-heart"></i> ${post.likes.length > 0 ? post.likes.length : '赞'}</span>
                        </div>
                    </div>`;
            }

            return postItem;
        }

// ▼▼▼ 步骤七：用这个【完整】的新函数替换旧的 renderFeed ▼▼▼

async function renderFeed() {
    const postsList = document.getElementById('posts-list');
    const tabsContainer = document.getElementById('feed-tabs-container');
    const subTabsContainer = document.getElementById('feed-sub-tabs-container');
    
    // 1. (不变) 渲染主标签页
    tabsContainer.innerHTML = `
        <button class="feed-tab-btn ${state.activeFeedTab === 'recommended' ? 'active' : ''}" data-tab="recommended"><i class="fas fa-home"></i> 推荐</button>
        <button class="feed-tab-btn ${state.activeFeedTab === 'following' ? 'active' : ''}" data-tab="following"><i class="fas fa-user-friends"></i> 关注</button>
        <button class="feed-tab-btn ${state.activeFeedTab === 'trending' ? 'active' : ''}" data-tab="trending"><i class="fas fa-fire"></i> 热搜</button>
    `;

    // 2. ✨ 核心改造：动态构建“推荐”页的子标签页 ✨
    if (state.activeFeedTab === 'recommended') {
        subTabsContainer.style.display = 'flex';
        
        // 2a. 先构建固定的4个
        let subTabsHTML = `
            <button class="feed-sub-tab-btn ${state.activeFeedSubTab === 'daily' ? 'active' : ''}" data-subtab="daily">日常</button>
            <button class="feed-sub-tab-btn ${state.activeFeedSubTab === 'food' ? 'active' : ''}" data-subtab="food">美食</button>
            <button class="feed-sub-tab-btn ${state.activeFeedSubTab === 'gossip' ? 'active' : ''}" data-subtab="gossip">八卦</button>
            <button class="feed-sub-tab-btn ${state.activeFeedSubTab === 'horror' ? 'active' : ''}" data-subtab="horror">恐怖</button>
        `;

        // 2b. 再从 state.forumCategories 里加载所有自定义的
        state.forumCategories.forEach(category => {
            const isActive = state.activeFeedSubTab === category.id; // 检查当前激活的是否是这个自定义ID
            subTabsHTML += `
                <button class="feed-sub-tab-btn ${isActive ? 'active' : ''}" data-subtab="${category.id}">${category.name}</button>
            `;
        });
        
        subTabsContainer.innerHTML = subTabsHTML;
    } else {
        subTabsContainer.style.display = 'none';
    }
    
    postsList.innerHTML = ''; 

    // 3. (不变) 渲染“热搜”页
    if (state.activeFeedTab === 'trending') {
        const trendingListEl = document.createElement('ol');
        trendingListEl.className = 'trending-list';
        
        if (state.trendingTopics.length === 0) {
             trendingListEl.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><p>热搜榜空空如也，刷新一下试试？</p></div>`;
        } else {
            state.trendingTopics.forEach((topic, index) => {
                const item = document.createElement('li');
                item.className = 'trending-item';
                item.dataset.topicTitle = topic.title;
                item.dataset.description = topic.description;
                item.innerHTML = `
                    <div class="trending-rank ${index < 3 ? 'top-3' : ''}">${index + 1}</div>
                    <div class="trending-info">
                        <div class="trending-title">${topic.title}</div>
                        <div class="trending-meta"><i class="fas fa-fire" style="color: #ff8a65;"></i> ${topic.heat}万</div>
                    </div>
                    ${topic.tag ? `<div class="trending-tag">${topic.tag}</div>` : ''}
                `;
                trendingListEl.appendChild(item);
            });
        }
        postsList.appendChild(trendingListEl);
        return;
    }

    // 4. ✨ 核心改造：渲染“关注”或“推荐(含自定义)”页的帖子 ✨
    let postsToShow = [];
    const contactIds = state.contacts.map(c => c.id);
    const activePosts = state.posts.filter(p => p.archiveId === state.activeForumArchiveId);

    if (state.activeFeedTab === 'following') {
        postsToShow = activePosts.filter(p => p.author.id === 'myProfile' || contactIds.includes(p.author.id));
    } else { 
        // 这里的 activeFeedSubTab 可能是 'daily'，也可能是 'category_123456'
        postsToShow = activePosts.filter(p => p.category === state.activeFeedSubTab);
    }
    
    // 5. (不变) 排序和显示
    const sortedPosts = [...postsToShow].sort((a, b) => b.timestamp - a.timestamp);
    const postsToDisplay = (state.activeFeedTab === 'following') ? sortedPosts : sortedPosts.slice(0, state.postsToDisplay);

    if (postsToDisplay.length === 0) {
        const emptyMessage = state.activeFeedTab === 'following' 
            ? '你关注的人还没有发布动态哦'
            : '这里空空如也，点击右上角刷新看看';
        postsList.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-couch" style="font-size: 48px; margin-bottom: 15px;"></i><p>${emptyMessage}</p></div>`;
    } else {
        postsToDisplay.forEach(post => {
            const postItem = createPostItem(post);
            if (postItem) postsList.appendChild(postItem);
        });
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// (替换) renderUserPersonaPresets (修复了签名行样式)
async function renderUserPersonaPresets() {
    const userPersonaPresetsList = document.getElementById('user-persona-presets-list');
    const noUserPersonaMessage = document.getElementById('no-user-persona-message');
    userPersonaPresetsList.innerHTML = '';
    noUserPersonaMessage.style.display = state.userPersonaPresets.length === 0 ? 'block' : 'none';
    state.userPersonaPresets.forEach(preset => {
        const presetItem = document.createElement('div');
        presetItem.className = 'preset-item';
        presetItem.dataset.presetId = preset.id;
        
        presetItem.innerHTML = `
            <div class="preset-info">
                <div class="preset-name">${preset.name}</div>
                
                <div class="preset-desc" style="font-size: 13px; color: #666; font-style: italic; border-left: 2px solid #eee; padding-left: 8px; margin-top: 5px; margin-bottom: 8px;
                    /* --- 强制重置掉继承的样式 --- */
                    display: block;
                    white-space: normal;
                    overflow: visible;
                    text-overflow: clip;
                    -webkit-line-clamp: unset;
                ">
                    签名: ${preset.signature || '(未设置)'}
                </div>
                <div class="preset-desc">${preset.description}</div>
            </div>
            <div class="preset-actions">
                <span class="preset-action-btn edit-preset-btn" title="编辑面具"><i class="fas fa-edit"></i></span>
                <span class="preset-action-btn delete delete-preset-btn" title="删除面具"><i class="fas fa-trash-alt"></i></span>
            </div>
        `;
        
        userPersonaPresetsList.appendChild(presetItem);
    });
    await updateUserPersonaPresetSelect();
}
        
// --- 用这个新版本，替换掉你旧的 renderThoughtPresets 函数 ---

async function renderThoughtPresets() {
    const thoughtPresetsList = document.getElementById('thought-presets-list');
    const noThoughtPresetMessage = document.getElementById('no-thought-preset-message');
    thoughtPresetsList.innerHTML = '';
    noThoughtPresetMessage.style.display = state.thoughtPresets.length === 0 ? 'block' : 'none';
    
    state.thoughtPresets.forEach(preset => {
        const item = document.createElement('div');
        item.className = 'preset-item';
        item.dataset.presetId = preset.id;

        // ▼▼▼ 核心修改在这里 ▼▼▼
        
        let actionButtonsHTML = ''; // 默认先创建一个空的按钮容器

        // 判断：如果当前预设的ID不是我们要保护的那一个
        if (preset.id !== 'deep_roleplay_regex') {
            // 就为它正常生成编辑和删除按钮
            actionButtonsHTML = `
                <div class="preset-actions">
                    <span class="preset-action-btn edit-thought-preset-btn" title="编辑预设">
                        <i class="fas fa-edit"></i>
                    </span>
                    <span class="preset-action-btn delete delete-thought-preset-btn" title="删除预设">
                        <i class="fas fa-trash-alt"></i>
                    </span>
                </div>
            `;
        }
        // 如果是 'deep_roleplay_regex'，actionButtonsHTML 就会是空的，按钮自然就消失了

        // 最后，将按钮HTML（可能为空）拼接到最终的列表项里
        item.innerHTML = `
            <div class="preset-info">
                <div class="preset-name">${preset.name}</div>
                <div class="preset-desc" style="white-space: pre-wrap;">${preset.prompt}</div>
            </div>
            ${actionButtonsHTML} 
        `;
        
        // ▲▲▲ 修改结束 ▲▲▲
        
        thoughtPresetsList.appendChild(item);
    });

    // 这部分事件绑定的代码保持不变
    // (因为现在是整个列表监听点击，所以即便按钮不存在也不会报错)
}
// --- 核心函数：打开编辑表情弹窗 ---
function openEditEmoticonModal(emoticon) {
    const modal = document.getElementById('edit-emoticon-modal');
    const preview = document.getElementById('edit-emo-preview');
    const nameInput = document.getElementById('edit-emo-name-input');
    const groupSelect = document.getElementById('edit-emo-group-select');
    const saveBtn = document.getElementById('save-edit-emoticon-btn');
    const closeBtn = document.getElementById('close-edit-emoticon-modal');

    // 1. 填充数据
    preview.src = emoticon.url;
    nameInput.value = emoticon.name;

    // 2. 动态填充“分组下拉菜单”
    groupSelect.innerHTML = '';
    state.emoticonGroups.forEach(group => {
        const option = document.createElement('option');
        option.value = group.id;
        option.textContent = group.name;
        if (group.id === emoticon.groupId) {
            option.selected = true;
        }
        groupSelect.appendChild(option);
    });

    // 3. 显示弹窗
    modal.style.display = 'flex';

    // 4. 绑定关闭事件
    const closeModal = () => { modal.style.display = 'none'; };
    closeBtn.onclick = closeModal;

    // 5. 绑定保存事件 (使用克隆节点防止重复绑定)
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);

    newSaveBtn.addEventListener('click', async () => {
        const newName = nameInput.value.trim();
        const newGroupId = groupSelect.value;

        if (!newName) return alert('表情名称不能为空');

        // 更新数据
        emoticon.name = newName;
        emoticon.groupId = newGroupId;

        // 保存到数据库
        await kokoMemory.put('emoticons', emoticon);

        // 刷新界面
        await renderEmoticonLibrary();
        
        closeModal();
        
        // 如果用户改了分组，表情会从当前列表消失（因为它去了新分组），给个提示比较友好
        if (newGroupId !== activeEmoticonGroupId) {
            // 这里的 activeEmoticonGroupId 是我们在第二步里定义的全局变量
            alert(`表情已移动到“${state.emoticonGroups.find(g=>g.id===newGroupId).name}”分组`);
        }
    });
}
// ✨ 全新升级的表情包库渲染函数 (支持分组) ✨
async function renderEmoticonLibrary() {
    const container = document.querySelector('.emoticon-library-content');
    container.innerHTML = ''; // 清空容器

    // --- 1. 渲染分组标签栏 ---
    const tabsContainer = document.createElement('div');
    tabsContainer.className = 'feed-sub-tabs'; // 复用论坛的胶囊样式
    tabsContainer.style.marginBottom = '15px';
    tabsContainer.style.padding = '0 5px';
    
    let tabsHTML = '';
    // 遍历所有分组生成标签
    state.emoticonGroups.forEach(group => {
        const isActive = group.id === activeEmoticonGroupId ? 'active' : '';
        tabsHTML += `<button class="feed-sub-tab-btn ${isActive} group-tab-btn" data-group-id="${group.id}">${group.name}</button>`;
    });
    
    // 添加“新建分组”按钮 (+)
    tabsHTML += `<button class="feed-sub-tab-btn" id="create-emo-group-btn" style="color: var(--theme-primary); border-color: var(--theme-primary);"><i class="fas fa-plus"></i></button>`;
    
    tabsContainer.innerHTML = tabsHTML;
    container.appendChild(tabsContainer);

    // --- 2. 渲染当前分组的操作栏 (重命名/删除) ---
    // 只有非默认分组才显示这些操作
    if (activeEmoticonGroupId !== 'default') {
        const actionHeader = document.createElement('div');
        actionHeader.style.cssText = "display: flex; justify-content: space-between; margin-bottom: 10px; padding: 0 5px;";
        actionHeader.innerHTML = `
            <span style="font-size: 12px; color: #888;">当前分组操作:</span>
            <div>
                <span class="preset-action-btn" id="rename-emo-group-btn" style="margin-right: 10px; cursor: pointer;"><i class="fas fa-edit"></i> 重命名</span>
                <span class="preset-action-btn delete" id="delete-emo-group-btn" style="cursor: pointer;"><i class="fas fa-trash-alt"></i> 删除分组</span>
            </div>
        `;
        container.appendChild(actionHeader);
    }

    // --- 3. 渲染表情网格 ---
    const grid = document.createElement('div');
    grid.className = 'emoticon-grid';
    grid.id = 'emoticon-library-grid';

    // 核心：只筛选当前分组的表情
    const filteredEmoticons = state.emoticons.filter(e => e.groupId === activeEmoticonGroupId);

    if (filteredEmoticons.length === 0) {
        const noMsg = document.createElement('div');
        noMsg.style.cssText = "text-align: center; padding: 50px 20px; color: #888; grid-column: 1 / -1;";
        noMsg.innerHTML = `
            <i class="far fa-grin-alt" style="font-size: 48px; margin-bottom: 15px;"></i>
            <p>此分组是空的</p>
            <p>点击右上角 "+" 批量导入表情到当前分组！</p>
        `;
        grid.appendChild(noMsg);
    } else {
        filteredEmoticons.forEach(emo => {
            const item = document.createElement('div');
            item.className = 'emoticon-item';
            // 增加 cursor: pointer 提示可以点击
            item.style.cursor = 'pointer'; 
            item.innerHTML = `
                <img src="${emo.url}" alt="${emo.name}" onerror="this.src='https://via.placeholder.com/60?text=Error';">
                <div class="emoticon-name">${emo.name}</div>
                <button class="emoticon-delete-btn" data-emoticon-id="${emo.id}">&times;</button>
            `;
            
            // ▼▼▼ 新增点击事件 ▼▼▼
            item.addEventListener('click', (e) => {
                // 如果点击的是删除按钮，什么都不做（交给下面的删除逻辑处理）
                if (e.target.closest('.emoticon-delete-btn')) return;
                
                // 否则，打开编辑弹窗
                openEditEmoticonModal(emo);
            });
            // ▲▲▲ 新增结束 ▲▲▲

            grid.appendChild(item);
        });
    }
    container.appendChild(grid);

    // --- 4. 绑定事件 ---
    
    // A. 标签切换点击事件
    tabsContainer.querySelectorAll('.group-tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            activeEmoticonGroupId = btn.dataset.groupId;
            renderEmoticonLibrary();
        });
    });

    // B. 新建分组点击事件
    container.querySelector('#create-emo-group-btn').addEventListener('click', async () => {
        const name = await showCustomPrompt('新建表情分组', '请输入分组名称');
        if (name && name.trim()) {
            const newGroup = { id: 'emo_group_' + Date.now(), name: name.trim() };
            state.emoticonGroups.push(newGroup);
            await kokoMemory.put('emoticonGroups', newGroup);
            
            // 创建完直接跳转到新组
            activeEmoticonGroupId = newGroup.id; 
            renderEmoticonLibrary();
        }
    });

    // C. 删除单个表情 (事件委托)
    grid.querySelectorAll('.emoticon-delete-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const emoticonId = e.currentTarget.dataset.emoticonId;
            const confirmed = await showCustomConfirm('删除表情', '确定要删除这个表情包吗？', true);
            if (confirmed) {
                state.emoticons = state.emoticons.filter(e => e.id !== emoticonId);
                await kokoMemory.delete('emoticons', emoticonId);
                renderEmoticonLibrary();
            }
        });
    });

    // D. 重命名分组
    const renameBtn = document.getElementById('rename-emo-group-btn');
    if(renameBtn) {
        renameBtn.addEventListener('click', async () => {
            const group = state.emoticonGroups.find(g => g.id === activeEmoticonGroupId);
            const newName = await showCustomPrompt('重命名分组', group.name);
            if(newName && newName.trim()) {
                group.name = newName.trim();
                await kokoMemory.put('emoticonGroups', group);
                renderEmoticonLibrary();
            }
        });
    }

    // E. 删除整个分组
    const deleteGroupBtn = document.getElementById('delete-emo-group-btn');
    if(deleteGroupBtn) {
        deleteGroupBtn.addEventListener('click', async () => {
            const confirmed = await showCustomConfirm('删除分组', '删除分组不会删除里面的表情，它们会移动到“默认分组”。确定删除吗？', true);
            if(confirmed) {
                // 1. 转移表情到默认组
                state.emoticons.forEach(e => {
                    if(e.groupId === activeEmoticonGroupId) e.groupId = 'default';
                });
                await kokoMemory.bulkPut('emoticons', state.emoticons);

                // 2. 删除组数据
                state.emoticonGroups = state.emoticonGroups.filter(g => g.id !== activeEmoticonGroupId);
                await kokoMemory.delete('emoticonGroups', activeEmoticonGroupId);
                
                // 3. 重置视图到默认组
                activeEmoticonGroupId = 'default';
                renderEmoticonLibrary();
            }
        });
    }
}

        async function renderMusicLibrary() {
            const list = document.getElementById('music-library-list');
            const noMusicMsg = document.getElementById('no-music-message');
            list.innerHTML = '';

            if (state.musicLibrary.length === 0) {
                noMusicMsg.style.display = 'block';
            } else {
                noMusicMsg.style.display = 'none';
                state.musicLibrary.forEach(song => {
                    const item = document.createElement('div');
                    item.className = 'music-item';
                    item.innerHTML = `
                        <div class="music-info">
                            <div class="music-title">${song.title}</div>
                            <div class="music-artist">${song.artist}</div>
                        </div>
                        <button class="music-delete-btn" data-music-id="${song.id}"><i class="fas fa-trash-alt"></i></button>
                    `;
                    list.appendChild(item);
                });

                list.querySelectorAll('.music-delete-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const musicId = e.currentTarget.dataset.musicId;
                        const confirmed = await showCustomConfirm('删除歌曲', '确定要从曲库删除这首歌吗？', true);
                        if (confirmed) {
                            state.musicLibrary = state.musicLibrary.filter(s => s.id !== musicId);
                            await kokoMemory.delete('musicLibrary', musicId);
                            await renderMusicLibrary();
                        }
                    });
                });
            }
        }

        function renderMusicPickerInModal() {
            const picker = document.getElementById('music-library-picker');
            picker.innerHTML = '';

            if (state.musicLibrary.length > 0) {
                picker.innerHTML = '<div class="picker-title">从曲库选择</div>';
                const list = document.createElement('div');
                list.className = 'picker-list';
                state.musicLibrary.forEach(song => {
                    const item = document.createElement('div');
                    item.className = 'picker-item';
                    item.textContent = `${song.title} - ${song.artist}`;
                    item.addEventListener('click', () => {
                        document.getElementById('send-music-title-input').value = song.title;
                        document.getElementById('send-music-artist-input').value = song.artist;
                        document.getElementById('send-music-url-input').value = song.url;
                        // ▼▼▼ 在这里添加填充歌词的代码 ▼▼▼
                        document.getElementById('send-music-lrc-input').value = song.lrc || '';
                    });
                    list.appendChild(item);
                });
                picker.appendChild(list);
            } else {
                picker.innerHTML = '<div class="picker-title" style="text-align:center; color:#999;">你的曲库是空的</div>';
            }
        }

function renderEmoticonPicker() {
    const picker = document.getElementById('emoticon-picker');
    picker.innerHTML = '';
    
    // 1. 渲染顶部的分组标签栏 (用户可以随便点)
    const tabsBar = document.createElement('div');
    tabsBar.style.cssText = "display: flex; overflow-x: auto; padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid #eee; gap: 8px; flex-shrink: 0; min-height: 35px;";
    
    // 渲染所有分组的按钮
    state.emoticonGroups.forEach(group => {
        const btn = document.createElement('button');
        const isActive = group.id === currentUserEmoticonTab;
        btn.className = isActive ? 'feed-sub-tab-btn active' : 'feed-sub-tab-btn';
        btn.style.padding = "4px 10px";
        btn.style.fontSize = "12px";
        btn.textContent = group.name;
        
        btn.onclick = (e) => {
            e.stopPropagation(); // 防止点击按钮时关闭表情面板
            currentUserEmoticonTab = group.id; // 更新当前选中的标签
            renderEmoticonPicker(); // 重新渲染面板
        };
        tabsBar.appendChild(btn);
    });
    picker.appendChild(tabsBar);

    // 2. 筛选出当前用户选中的分组下的表情
    const filteredEmoticons = state.emoticons.filter(e => e.groupId === currentUserEmoticonTab);

    if (filteredEmoticons.length > 0) {
        // 创建网格容器，复用 .emoticon-grid 样式
        const grid = document.createElement('div');
        grid.className = 'emoticon-grid';
        // 移除 padding 以适应聊天窗口的小空间
        grid.style.padding = '0';
        
        filteredEmoticons.forEach(emo => {
            const item = document.createElement('div');
            item.className = 'emoticon-item';
            item.innerHTML = `
                <img src="${emo.url}" alt="${emo.name}" style="height: 50px;"> 
                <div class="emoticon-name">${emo.name}</div>
            `;
            item.addEventListener('click', async () => {
                await createAndAddMessage({ 
                    type: 'image', 
                    url: emo.url,
                    isEmoticon: true,
                    emoticonName: emo.name
                });
                picker.classList.remove('active');
            });
            grid.appendChild(item);
        });
        picker.appendChild(grid);
    } else {
        const emptyMsg = document.createElement('div');
        emptyMsg.style.cssText = "color: #999; text-align: center; padding: 20px; width: 100%;";
        emptyMsg.textContent = '此分组下没有表情包';
        picker.appendChild(emptyMsg);
    }
}

        function renderWalletScreen() {
            const listEl = document.getElementById('transaction-list');
            const noTransactionMsg = document.getElementById('no-transaction-message');
            listEl.innerHTML = '';

            if (!state.transactions || state.transactions.length === 0) {
                noTransactionMsg.style.display = 'block';
                return;
            }
            noTransactionMsg.style.display = 'none';

            const sortedTransactions = [...state.transactions].sort((a, b) => b.timestamp - a.timestamp);

            sortedTransactions.forEach(tx => {
                const item = document.createElement('div');
                item.className = 'transaction-item';
                const amountClass = tx.type === 'income' ? 'income' : 'expense';
                const amountSign = tx.type === 'income' ? '+' : '-';

                item.innerHTML = `
                    <div class="transaction-info">
                        <div class="desc">${tx.description}</div>
                        <div class="time">${new Date(tx.timestamp).toLocaleString()}</div>
                    </div>
                    <div class="transaction-amount ${amountClass}">
                        ${amountSign}${tx.amount.toFixed(2)}
                    </div>
                `;
                listEl.appendChild(item);
            });
        }


        async function updateUserPersonaPresetSelect() {
            const selectUserPersonaPreset = document.getElementById('select-user-persona-preset');
            selectUserPersonaPreset.innerHTML = '<option value="">-- 选择或输入自定义面具 --</option>';
            state.userPersonaPresets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                selectUserPersonaPreset.appendChild(option);
            });
        }

        async function populateThoughtPresetSelect() {
            const select = document.getElementById('thought-preset-select');
            const currentVal = select.value;
            select.innerHTML = '';
            
            const noPresetOption = document.createElement('option');
            noPresetOption.value = ""; 
            noPresetOption.textContent = "-- 无预设 (使用默认角色扮演) --";
            select.appendChild(noPresetOption);

            if (state.thoughtPresets.length === 0) {
                return;
            }
            state.thoughtPresets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                select.appendChild(option);
            });

            if (state.thoughtPresets.some(p => p.id === currentVal) || currentVal === "") {
                select.value = currentVal;
            }
        }

        async function updateNotificationDots() {
            const dots = document.querySelectorAll('.moments-notification-dot');
            if (state.hasNewPosts) {
                dots.forEach(dot => dot.style.display = 'block');
            } else {
                dots.forEach(dot => dot.style.display = 'none');
            }
        }
        
        function formatTimeAgo(timestamp) {
            return new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        function parseMentions(text) {
            if (!text) return '';
            const mentionRegex = /@([\w\u4e00-\u9fa5]+)/g;
            return text.replace(mentionRegex, (match) => {
                return `<span class="mention">${match}</span>`;
            });
        }

       
// ▼▼▼ 使用这个【修正后】的函数替换旧函数 ▼▼▼
function hideAllScreens() {
    document.querySelectorAll(
        '#screen > div, #wallet-screen, #appearance-settings-screen, #shopping-screen, #product-detail-screen, #forum-archives-screen, #map-screen, #map-management-screen, #schedule-screen, #events-screen, #lock-screen-photos-screen, #relationship-network-screen, #snooped-app-content-screen, #sms-chat-screen, #favorites-screen, #investment-center-screen, #stock-market-screen, #forum-category-management-screen' // <-- ✨ 核心修复：在这里加上你的新页面ID
    ).forEach(el => el.style.display = 'none');
}

// ▼▼▼ 使用这个【全新版本】替换掉旧的 setActiveNav 函数 ▼▼▼
function setActiveNav(activeNavId) {
    // 获取页面上所有的底栏按钮
    document.querySelectorAll('.bottom-nav .nav-item').forEach(item => {
        // 先把所有按钮都灭掉
        item.classList.remove('active');

        // 聪明地判断：只点亮ID第一部分匹配的按钮
        // 比如 activeNavId 是 'chat'，那么 'nav-chat'、'nav-chat-2'、'nav-chat-sms' 都会被点亮
        if (item.id.startsWith('nav-' + activeNavId)) {
            item.classList.add('active');
        }
    });
}
// ▲▲▲ 替换结束 ▲▲▲
        
        async function showMainScreen() { hideAllScreens(); document.getElementById('main-screen').style.display = 'flex'; setActiveNav('chat'); await renderContacts(); }
        function showDiscoverScreen() { hideAllScreens(); document.getElementById('discover-screen').style.display = 'flex'; setActiveNav('discover'); }
        async function showProfileScreen() { hideAllScreens(); document.getElementById('profile-screen').style.display = 'flex'; setActiveNav('profile'); await renderMyProfile(); }
        // ▼▼▼ 把这个新函数，和你其他的 show...Screen 函数放在一起 ▼▼▼
async function showSmsScreen() {
    hideAllScreens();
    const smsScreen = document.getElementById('sms-screen');
    smsScreen.style.display = 'flex';
    setActiveNav('sms');
    // ✨ 新增调用：渲染短信会话列表 ✨
    await renderSmsConversations();
    // ✨ 确保处理页签切换（如果用户在窥探模式下） ✨
    handleSmsTabClick({ target: smsScreen.querySelector('.feed-tab-btn[data-tab="my-sms"]') }); // 默认显示“我的短信”
}
// ▲▲▲ 粘贴到这里结束 ▲▲▲
        
        async function showFeedScreen() { 
            hideAllScreens(); 
            document.getElementById('moments-screen').style.display = 'flex'; 
            if (state.hasNewPosts) {
                state.hasNewPosts = false;
                updateNotificationDots();
            }
            //自动刷新功能注释掉，Produced by Kiko
            //if (isInitialPostLoad && state.posts.length === 0) {
                 //if (state.trendingTopics.length === 0) {
                    //await generateRandomTrendingTopicsAI();
                //}
                //await generatePostsForRecommendedTab(10);
                //isInitialPostLoad = false;
            //}
            await renderFeed();
        }

        async function showPostDetailScreen(postId) {
            state.activePostId = postId;
            hideAllScreens();
            document.getElementById('post-detail-screen').style.display = 'flex';
            await renderPostDetail();
        }
        
        async function showTrendingTopicScreen(topicTitle, topicDescription) {
            hideAllScreens();
            const screen = document.getElementById('trending-topic-screen');
            screen.style.display = 'flex';

            // 填充标题和描述 (这部分不变)
            document.getElementById('trending-topic-title').textContent = `# ${topicTitle.replace(/#/g, '')} #`;

            const descriptionContainer = document.getElementById('trending-topic-description-container');
            if (topicDescription) {
                descriptionContainer.textContent = topicDescription;
                descriptionContainer.style.display = 'block';
            } else {
                descriptionContainer.style.display = 'none';
            }

            const listEl = document.getElementById('trending-topic-posts-list');
            listEl.innerHTML = '';

            // ▼▼▼▼▼▼▼▼▼▼ 核心修复点在这里 ▼▼▼▼▼▼▼▼▼▼

            // 1. 提取不带#号的核心关键词，让搜索更灵活
            const coreTopic = topicTitle.replace(/#/g, "").trim();

            // 2. 关键修复：筛选时，必须同时满足两个条件：
            //    - 帖子必须属于当前激活的“世界线” (archiveId)
            //    - 帖子的内容必须包含这个核心关键词
            const relatedPosts = state.posts.filter(p =>
                p.archiveId === state.activeForumArchiveId && p.content.includes(coreTopic)
            );

            // ▲▲▲▲▲▲▲▲▲▲ 修复结束 ▲▲▲▲▲▲▲▲▲▲


            if (relatedPosts.length === 0) {
                 listEl.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-comment-slash" style="font-size: 48px; margin-bottom: 15px;"></i><p>该话题下还没有帖子</p></div>`;
                 return;
            }

            relatedPosts.sort((a,b) => b.timestamp - a.timestamp).forEach(post => {
                const postItem = createPostItem(post);
                if (postItem) listEl.appendChild(postItem);
            });
        }

        async function showThoughtPresetManagementScreen() { hideAllScreens(); document.getElementById('thought-preset-management-screen').style.display = 'flex'; await renderThoughtPresets(); }
        async function showEmoticonLibraryScreen() { hideAllScreens(); document.getElementById('emoticon-library-screen').style.display = 'flex'; await renderEmoticonLibrary(); }
        async function showMusicLibraryScreen() { hideAllScreens(); document.getElementById('music-library-screen').style.display = 'flex'; await renderMusicLibrary(); }
        async function showUserPersonaManagementScreen() { hideAllScreens(); document.getElementById('user-persona-management-screen').style.display = 'flex'; await renderUserPersonaPresets(); }

        async function showCharProfileScreen() {
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if (!contact) return;
            
            const diaryButton = document.getElementById('view-char-diary-btn');
            if (contact.isGroup) {
                // 如果是群聊，就隐藏日记按钮
                diaryButton.style.display = 'none';
            } else {
                // 如果是个人，就确保日记按钮是显示的
                diaryButton.style.display = 'flex';
            }
            
            batchedPetActions = [];
            
            document.getElementById('char-profile-avatar').src = contact.avatar || `https://via.placeholder.com/70/DDD/666?text=${contact.name.substring(0,1).toUpperCase()}`;
            document.getElementById('char-profile-name').textContent = contact.name;
            document.getElementById('char-name-value').textContent = contact.name;
            document.getElementById('char-signature-value').textContent = contact.signature || '未设置';
            document.getElementById('char-profile-signature-display').textContent = `个性签名: ${contact.signature || '...'}`;


            hideAllScreens();
            document.getElementById('char-profile-screen').style.display = 'flex';

            renderPet(contact);
        }

        // --- MODIFIED: V7.0 修改为“小窝时光胶囊” ---
        async function showMemoryAlbum(contact) {
            hideAllScreens();
            document.getElementById('memory-album-screen').style.display = 'flex';
            renderMemoryAlbum(contact);
        }

        // --- MODIFIED: V7.0 渲染全新的时光胶囊 ---
        function renderMemoryAlbum(contact) {
            const listEl = document.getElementById('memory-album-list');
            listEl.innerHTML = '';
            if (!contact) return;

            // 格式化时长
            function formatDuration(totalSeconds) {
                if (!totalSeconds) return '0 分钟';
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                let result = '';
                if (hours > 0) result += `${hours} 小时 `;
                if (minutes > 0 || hours === 0) result += `${minutes} 分钟`;
                return result.trim();
            }

            const daysSinceFirstChat = Math.floor((Date.now() - contact.firstChatDate) / (1000 * 60 * 60 * 24));

            let albumHTML = `
                <div class="album-section">
                    <div class="album-section-title">我们的里程碑</div>
                    <div class="album-milestone-item">
                        <span class="album-item-icon"><i class="fas fa-calendar-check"></i></span>
                        <span class="album-item-label">初次相遇</span>
                        <span class="album-item-value">${new Date(contact.firstChatDate).toLocaleDateString()}</span>
                    </div>
                    <div class="album-milestone-item">
                        <span class="album-item-icon"><i class="fas fa-heart"></i></span>
                        <span class="album-item-label">已相识</span>
                        <span class="album-item-value">${daysSinceFirstChat} 天</span>
                    </div>
                </div>

                <div class="album-section">
                    <div class="album-section-title">共同的记忆</div>
                     <div class="album-stat-item">
                        <span class="album-item-icon"><i class="fas fa-music"></i></span>
                        <span class="album-item-label">一起听歌</span>
                        <span class="album-item-value">${formatDuration(contact.totalListenTime)}</span>
                    </div>
                </div>

                <div class="album-section">
                    <div class="album-section-title">珍藏的瞬间</div>
                    <div class="album-memory-grid" id="memory-grid-content">
                        </div>
                </div>
            `;
            listEl.innerHTML = albumHTML;

            const gridContent = document.getElementById('memory-grid-content');
            if (!contact.memories || contact.memories.length === 0) {
                 gridContent.innerHTML = `<p style="color:#888; grid-column: 1 / -1;">还没有珍藏的瞬间...</p>`;
            } else {
                 const sortedMemories = [...contact.memories].sort((a, b) => b.timestamp - a.timestamp);
                 sortedMemories.forEach(memo => {
                    const entryEl = document.createElement('div');
                    entryEl.className = 'album-memory-item';
                    entryEl.title = new Date(memo.timestamp).toLocaleString();
                    entryEl.innerHTML = `<i class="fas fa-quote-left"></i> ${memo.description}`;
                    gridContent.appendChild(entryEl);
                });
            }
        }
// ==========================================================
// =========== ▼▼▼ 新增：API格式转换引擎 ▼▼▼ =================
// ==========================================================

/**
 * 将 OpenAI 格式的请求体，转换为 Gemini 格式
 * @param {object} openAiPayload - OpenAI 格式的请求体
 * @returns {object} Gemini 格式的请求体
 */
function convertOpenAiToGemini(openAiPayload) {
    const geminiContents = [];
    let lastRole = "";
    // Gemini 要求 system prompt 必须在最前面，且不能连续出现
    const systemPrompt = openAiPayload.messages.find(msg => msg.role === 'system');
    const chatMessages = openAiPayload.messages.filter(msg => msg.role !== 'system');

    for (const msg of chatMessages) {
        // 角色转换：'assistant' -> 'model', 其他 ('user', 'system') -> 'user'
        let role = (msg.role === 'assistant') ? 'model' : 'user';
        
        // Gemini 严格要求 user 和 model 角色交替出现
        if (role === lastRole && geminiContents.length > 0) {
            // 如果连续出现同角色，将内容合并到上一个条目的 parts 里
            geminiContents[geminiContents.length - 1].parts.push({ text: msg.content });
        } else {
            // 否则，正常添加新角色条目
            geminiContents.push({
                role: role,
                parts: [{ text: msg.content }]
            });
            lastRole = role;
        }
    }

    const geminiPayload = { contents: geminiContents };
    // 如果有 system prompt，将其作为特殊参数添加
    if(systemPrompt) {
        geminiPayload.systemInstruction = {
            role: 'user', // Gemini 的 system prompt 角色也是 user
            parts: [{text: systemPrompt.content}]
        }
    }
    
    return geminiPayload;
}


/**
 * 将 Gemini API 的响应体，转换为 OpenAI 格式
 * @param {object} geminiData - 从 Gemini API 收到的原始响应数据
 * @param {string} modelId - App 请求时使用的模型ID
 * @returns {object} OpenAI 格式的响应体
 */
function convertGeminiToOpenAi(geminiData, modelId) {
    // 检查是否有有效内容返回
    if (!geminiData.candidates || geminiData.candidates.length === 0 || !geminiData.candidates[0].content || !geminiData.candidates[0].content.parts) {
        // 如果 Gemini 因为安全或其他原因阻止了回复，这里会没有 candidates
        const blockReason = geminiData.promptFeedback?.blockReason || '未知原因';
        const safetyRatings = geminiData.promptFeedback?.safetyRatings?.map(r => `${r.category}: ${r.probability}`).join(', ') || '无';
        
        return {
            choices: [{
                message: {
                    role: "assistant",
                    content: `抱歉，Gemini API 阻止了回复。原因: ${blockReason}。安全评级: ${safetyRatings}`
                },
                finish_reason: "stop",
            }]
        };
    }
    
    const responseContent = geminiData.candidates[0].content.parts[0].text;

    const openAIResponse = {
        id: "chatcmpl-" + Date.now(),
        object: "chat.completion",
        created: Math.floor(Date.now() / 1000),
        model: modelId,
        choices: [{
            index: 0,
            message: {
                role: "assistant",
                content: responseContent,
            },
            finish_reason: "stop",
        }],
        usage: { // 伪造 usage 数据，有些客户端需要这个
            prompt_tokens: 0,
            completion_tokens: 0,
            total_tokens: 0,
        }
    };
    
    return openAIResponse;
}

// ==========================================================
// =========== ▲▲▲ 新增代码粘贴到此结束 ▲▲▲ =================
// ==========================================================


// (替换) “编辑面具”函数：修复了 event.target 的BUG
async function editUserPersonaPreset(event) {
    event.stopPropagation();
    
    // ▼▼▼ 核心修复点在这里 ▼▼▼
    // 错误代码：event.currentTarget.closest('.preset-item')
    // 正确代码：event.target.closest('.preset-item')
    const presetId = event.target.closest('.preset-item').dataset.presetId;
    // ▲▲▲ 修复结束 ▲▲▲

    const preset = state.userPersonaPresets.find(p => p.id === presetId);
    if (preset) {
        editingUserPersonaId = presetId;
        currentEditingPersonaAvatar = preset.avatar || null; 
        
        document.getElementById('user-persona-modal-title').textContent = '编辑用户面具预设';
        document.getElementById('user-persona-name-input').value = preset.name;
        document.getElementById('user-persona-signature-input').value = preset.signature || '';
        document.getElementById('user-persona-description-input').value = preset.description;

        const preview = document.getElementById('user-persona-avatar-preview');
        if (preset.avatar) {
            preview.src = preset.avatar;
            preview.style.display = 'block';
        } else {
            preview.src = '';
            preview.style.display = 'none';
        }

        document.getElementById('user-persona-preset-modal').style.display = 'flex';
    }
}

// ▼▼▼ 请用这个【最终修正版】完整替换旧函数 ▼▼▼
async function deleteUserPersonaPreset(event) {
    event.stopPropagation(); // 阻止事件冒泡

    const confirmed = await showCustomConfirm('删除面具', '确定要删除此用户面具预设吗？', true);
    if (!confirmed) {
        return; // 用户点击了“取消”
    }
    
    // --- 核心修正点在这里 ---
    // 我们需要从 event.target (实际被点击的元素) 来查找父级
    const presetItem = event.target.closest('.preset-item');
    if (!presetItem) {
        console.error("删除失败：无法找到 preset-item 元素。");
        return;
    }
    const presetId = presetItem.dataset.presetId;
    // --- 修正结束 ---

    if (!presetId) {
        console.error("删除失败：无法在HTML元素上找到预设ID。");
        return;
    }

    const presetToDelete = state.userPersonaPresets.find(p => p.id === presetId);

    // 1. 从程序的内存（state）中过滤掉这个预设
    state.userPersonaPresets = state.userPersonaPresets.filter(p => p.id !== presetId);

    // 2. 从浏览器的数据库中删除这条记录
    await kokoMemory.delete('userPersonaPresets', presetId);

    // 3. 自动清理所有联系人对这个已删除面具的引用
    if (presetToDelete) {
        for (const contact of state.contacts) {
            if (contact.userPersona === presetToDelete.description) {
                contact.userPersona = ''; // 清空这个设置
                await kokoMemory.put('contacts', contact); // 保存对联系人的修改
            }
        }
    }

    // 4. 重新渲染预设列表，让界面立刻刷新
    await renderUserPersonaPresets();
}
// ▲▲▲ 替换到这里结束 ▲▲▲
        /**
 * 删除一本世界书
 */
async function deleteWorldBook(event) {
    // 这行是防止点击删除时，意外触发了进入编辑页面的效果
    event.stopPropagation(); 

    const bookId = event.currentTarget.closest('.world-book-item').dataset.bookId;
    const book = state.worldBooks.find(b => b.id === bookId);
    if (!book) return;

    // 弹出确认框，防止误删
    const confirmed = await showCustomConfirm('删除世界书', `确定要删除《${book.name}》吗？\n\n注意：如果任何联系人正在使用这本书，他们的关联也会被解除。`, true);

    if (confirmed) {
        // 1. 从 state 缓存中删除这本书
        state.worldBooks = state.worldBooks.filter(b => b.id !== bookId);

        // 2. 从数据库中删除这本书
        await kokoMemory.delete('worldBooks', bookId);

        // 3. (重要!) 检查并移除所有联系人对这本书的引用
        state.contacts.forEach(contact => {
            if (contact.worldBooks && contact.worldBooks.includes(bookId)) {
                contact.worldBooks = contact.worldBooks.filter(id => id !== bookId);
                // 异步保存对联系人的修改，不阻塞后续UI更新
                kokoMemory.put('contacts', contact); 
            }
        });

        // 4. 重新渲染世界书列表，让界面刷新
        await renderWorldBooks();

        // 5. 更新所有用到世界书的下拉选择器
        await updateWorldBookSelectors();
    }
}

// --- 用这个新版本，替换掉旧的 editThoughtPreset 函数 ---

async function editThoughtPreset(event) {
    event.stopPropagation();
    
    // ▼▼▼ 核心修正点 ▼▼▼
    // 将 event.currentTarget 修改为 event.target，和删除按钮的逻辑保持一致
    const presetId = event.target.closest('.preset-item').dataset.presetId;
    // ▲▲▲ 修正结束 ▲▲▲

    const preset = state.thoughtPresets.find(p => p.id === presetId);
    if (preset) {
        editingThoughtPresetId = presetId;
        document.getElementById('thought-preset-modal-title').textContent = '编辑思维预设';
        document.getElementById('thought-preset-name-input').value = preset.name;
        document.getElementById('thought-preset-prompt-input').value = preset.prompt;
        document.getElementById('thought-preset-modal').style.display = 'flex';
    }
}

// --- 用这个新版本，替换掉旧的 deleteThoughtPreset 函数 ---

async function deleteThoughtPreset(event) {
    event.stopPropagation();
    const confirmed = await showCustomConfirm('删除预设', '确定要删除此思维预设吗？', true);
    if (confirmed) {
        // 核心修正：和修复好的“面具预设”一样，使用 event.target
        const presetItem = event.target.closest('.preset-item');
        if (!presetItem) {
            console.error("删除失败：无法找到 preset-item 元素。");
            return;
        }
        const presetId = presetItem.dataset.presetId;
        
        // 后续的删除逻辑保持不变
        state.thoughtPresets = state.thoughtPresets.filter(p => p.id !== presetId);
        await kokoMemory.delete('thoughtPresets', presetId);
        await renderThoughtPresets(); // 重新渲染列表
    }
}

        function findAuthorById(authorId) {
            if (authorId === 'myProfile') {
                return { id: 'myProfile', ...state.myProfile };
            }
            return state.contacts.find(c => c.id === authorId);
        }
        
        async function toggleLike(event) {
            event.stopPropagation();
            const postId = event.currentTarget.dataset.postId;
            const post = state.posts.find(p => p.id === postId);
            if (post) {
                const myName = state.myProfile.name;
                const likeIndex = post.likes.indexOf(myName);
                if (likeIndex === -1) {
                    post.likes.push(myName);
                } else {
                    post.likes.splice(likeIndex, 1);
                }
                await kokoMemory.put('posts', post);
                
                if (document.getElementById('moments-screen').style.display === 'flex') {
                    await renderFeed(); 
                } else if (document.getElementById('post-detail-screen').style.display === 'flex') {
                    await renderPostDetail();
                }
            }
        }
        
        function editWorldBook(bookId) {
            const book = state.worldBooks.find(b => b.id === bookId);
            if (book) {
                editingBookId = bookId;
                document.getElementById('world-book-modal-title').textContent = '编辑世界书';
                document.getElementById('book-name-input').value = book.name;
                document.getElementById('book-content-input').value = book.content;
                document.getElementById('add-world-book-modal').style.display = 'flex';
            }
        }
        
// ▼▼▼ 使用这个【新版本】替换掉您原来的 fetchModels 函数 ▼▼▼
async function fetchModels(endpointBase, apiKey, modelSelectEl, btn) {
    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 拉取中';
    btn.disabled = true;

    if (!endpointBase) {
        alert('请输入API基础地址');
        btn.innerHTML = '<i class="fas fa-sync-alt"></i> 拉取';
        btn.disabled = false;
        return;
    }

    let fetchUrl;
    let fetchOptions = {};

    if (endpointBase.includes('generativelanguage.googleapis.com')) {
        console.log("正在使用 Gemini 方式拉取模型...");
        fetchUrl = `https://${endpointBase}/v1beta/models?key=${apiKey}`;
        fetchOptions = {}; 
    } else {
        console.log("正在使用 OpenAI 兼容方式拉取模型...");
        
        // ★★★ 核心修改在这里 ★★★
        const cleanEndpoint = normalizeApiEndpoint(endpointBase); // 1. 清洁地址
        fetchUrl = `${cleanEndpoint}/v1/models`; // 2. 安全拼接
        
        fetchOptions = { headers: { 'Authorization': `Bearer ${apiKey}` } };
    }

    try {
        const response = await fetch(fetchUrl, fetchOptions);
        if (!response.ok) {
            const errorData = await response.json();
            if (errorData.error && errorData.error.message) {
                 throw new Error(errorData.error.message);
            }
            throw new Error('未知的网络错误');
        };
        const data = await response.json();
        
        let models;
        if (data.models) { 
            models = data.models.map(model => model.name.replace('models/', '')).sort();
        } else if (data.data) {
            models = data.data.map(model => model.id).sort();
        } else {
            models = [];
        }

        updateModelDropdown(models, modelSelectEl, modelSelectEl.value);
        alert(`成功拉取 ${models.length} 个模型！`);
    } catch (error) {
        console.error('拉取模型失败:', error);
        alert(`拉取模型失败: ${error.message}\n\n请检查基础地址和API密钥是否正确。`);
    } finally {
        btn.innerHTML = '<i class="fas fa-sync-alt"></i> 拉取';
        btn.disabled = false;
    }
}
// ==========================================================
// =========== ▼▼▼ 把这个新函数粘贴到您的代码里 ▼▼▼ ==========
// ==========================================================
/**
 * 规范化API端点地址，移除末尾的 / 和 /v1
 * @param {string} endpoint - 用户输入的原始端点地址
 * @returns {string} - 返回一个干净的、不带/v1的基础地址
 */
function normalizeApiEndpoint(endpoint) {
    if (!endpoint) return '';
    let url = endpoint.trim();
    // 循环移除末尾的斜杠，防止用户输入多个 (e.g., "https://api.com//")
    while (url.endsWith('/')) {
        url = url.slice(0, -1);
    }
    // 移除末尾的 /v1
    if (url.endsWith('/v1')) {
        url = url.slice(0, -3);
    }
    return url;
}
// ==========================================================
// =========== ▲▲▲ 新函数粘贴到此结束 ▲▲▲ =================
// ==========================================================
        
        function updateModelDropdown(models, modelSelect, currentModel) {
            modelSelect.innerHTML = ''; 

            if (models && models.length > 0) {
                models.forEach(modelId => {
                    const option = document.createElement('option');
                    option.value = modelId;
                    option.textContent = modelId;
                    if (modelId === currentModel) {
                        option.selected = true;
                    }
                    modelSelect.appendChild(option);
                });
            } else if (currentModel) { 
                const option = document.createElement('option');
                option.value = currentModel;
                option.textContent = currentModel;
                option.selected = true;
                modelSelect.appendChild(option);
            } else {
                const option = document.createElement('option');
                option.value = "";
                option.textContent = "未能拉取到模型或列表为空";
                modelSelect.appendChild(option);
            }
        }

        const MESSAGES_PER_PAGE = 30;

        function enterEditMode() {
            editModeState.active = true;
            editModeState.selectedMessageIds.clear();
            document.getElementById('chat-screen').classList.add('chat-screen-edit-mode');
            document.getElementById('chat-input-area').style.display = 'none';
            document.getElementById('edit-mode-bar').style.display = 'flex';
            //renderChatMessages(state.contacts.find(c => c.id === state.activeChatId)); 
        }

async function exitEditMode() {
    editModeState.active = false; // 1. 告诉程序，我们不编辑了
    
    document.getElementById('chat-screen').classList.remove('chat-screen-edit-mode');
    document.getElementById('chat-input-area').style.display = 'flex'; // 2. 把输入框还给你
    document.getElementById('edit-mode-bar').style.display = 'none'; // 3. 隐藏编辑栏

    // 4. ✨【核心修复】✨
    //   我们不再粗暴地刷新整个聊天，而是温柔地
    //   把所有“蓝色高亮”的消息都取消掉，这样就不会乱跳了！
    document.querySelectorAll('.message-wrapper.selected').forEach(el => {
        el.classList.remove('selected');
    });
    
    // 5. 顺便清空选择记录
    editModeState.selectedMessageIds.clear();
}

        function handleMessageSelection(wrapper, message) {
            if (!editModeState.active) return;
            const msgId = wrapper.dataset.messageId;
            if (!msgId) return;

            if (editModeState.selectedMessageIds.has(msgId)) {
                editModeState.selectedMessageIds.delete(msgId);
                wrapper.classList.remove('selected');
            } else {
                editModeState.selectedMessageIds.add(msgId);
                wrapper.classList.add('selected');
            }
        }
        
        function openRepostModal(postId) {
            const post = state.posts.find(p => p.id === postId);
            if (!post) return;
            
            const modal = document.getElementById('repost-contact-picker-modal');
            const contactListEl = document.getElementById('repost-contact-list');
            const messageInput = document.getElementById('repost-message-input');
            messageInput.value = '';
            contactListEl.innerHTML = '';

            state.contacts.forEach(contact => {
                const item = document.createElement('div');
                item.className = 'contact-picker-item';
                item.innerHTML = `
                    <input type="checkbox" id="contact-check-${contact.id}" value="${contact.id}">
                    <label for="contact-check-${contact.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                        <img src="${contact.avatar}" alt="${contact.name}">
                        <span>${contact.name}</span>
                    </label>
                `;
                contactListEl.appendChild(item);
            });
            
            modal.style.display = 'flex';

            document.getElementById('close-repost-modal').onclick = () => modal.style.display = 'none';
            
            const confirmBtn = document.getElementById('confirm-repost-btn');
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            newConfirmBtn.addEventListener('click', async () => {
                const selectedContactIds = Array.from(contactListEl.querySelectorAll('input:checked')).map(input => input.value);
                if (selectedContactIds.length === 0) {
                    alert('请至少选择一个联系人');
                    return;
                }
                
                const accompanyingMessage = messageInput.value.trim();

                for (const contactId of selectedContactIds) {
                    const tempActiveChatId = state.activeChatId;
                    state.activeChatId = contactId; // 临时切换上下文
                    
                    await createAndAddMessage({ type: 'post_share', content: { postId } });
                    if (accompanyingMessage) {
                        await createAndAddMessage({ type: 'text', content: accompanyingMessage });
                    }
                    
                    state.activeChatId = tempActiveChatId; // 切换回来
                }
                
                modal.style.display = 'none';
                alert(`已成功分享给 ${selectedContactIds.length} 位联系人！`);
                post.reposts = (post.reposts || 0) + 1;
                await kokoMemory.put('posts', post);
                await renderFeed();
            });
        }

       // 【最终完美版】showRedPacketDetails 函数
// 它可以正确处理：私聊红包、群聊红包、论坛红包

// 【私聊逻辑修正版】showRedPacketDetails 函数
// 它能正确处理所有场景，并修正了私聊领取人的判断逻辑

async function showRedPacketDetails(packetData, senderProfile) {
    const modal = document.getElementById('red-packet-details-modal');
    const listEl = document.getElementById('red-packet-claimer-list');
    const summaryEl = document.getElementById('red-packet-details-summary');

    // 1. 设置通用的头部信息
    document.getElementById('details-sender-avatar').src = senderProfile.avatar;
    document.getElementById('details-sender-name').textContent = `${senderProfile.name}的红包`;
    document.getElementById('details-blessing').textContent = packetData.blessing;
    listEl.innerHTML = '';

    // 2. 智能判断红包类型并准备数据
    const isMultiPersonPacket = packetData.hasOwnProperty('count');
    let claimers = packetData.claimers || [];

    // ▼▼▼▼▼▼▼▼▼▼ 核心修复点在这里 ▼▼▼▼▼▼▼▼▼▼
    // 兼容私聊红包，并正确判断领取人
    if (!isMultiPersonPacket && packetData.opened && claimers.length === 0) {
        
        // 判断是谁领取的
        let recipientId;
        if (senderProfile.id === 'myProfile') {
            // 如果发送人是“我”，那么领取人就是当前聊天的char
            recipientId = state.activeChatId;
        } else {
            // 如果发送人是char，那么领取人就是“我”
            recipientId = 'myProfile';
        }
        
        // 手动创建正确的领取者信息
        claimers = [{
            userId: recipientId,
            amount: parseFloat(packetData.amount)
        }];
    }
    // ▲▲▲▲▲▲▲▲▲▲ 核心修复点在这里 ▲▲▲▲▲▲▲▲▲▲

    // 3. 根据红包类型生成不同的汇总信息（这部分逻辑已是正确的）
    let summaryText = '';
    if (claimers.length === 0) {
        summaryText = '红包正在等待领取...';
    } else if (isMultiPersonPacket) {
        const totalAmount = packetData.totalAmount || packetData.amount;
        const totalClaimedAmount = claimers.reduce((sum, c) => sum + c.amount, 0);
        const claimedCount = claimers.length;
        const totalCount = packetData.count;
        if (claimedCount >= totalCount) {
            summaryText = `全部 ${totalCount} 个红包已被领完，共 ${totalAmount.toFixed(2)} 元。`;
        } else {
            summaryText = `已领取 ${claimedCount}/${totalCount} 个，共 ${totalClaimedAmount.toFixed(2)}/${totalAmount.toFixed(2)} 元。`;
        }
    } else {
        summaryText = `1个红包，共 ${parseFloat(packetData.amount).toFixed(2)} 元。`;
    }
    summaryEl.textContent = summaryText;

    // 4. 创建一个包含所有可能出现的“路人甲”的查找表（这部分逻辑已是正确的）
    const authorProfiles = new Map();
    authorProfiles.set('myProfile', state.myProfile);
    state.contacts.forEach(c => authorProfiles.set(c.id, c));
    state.posts.forEach(p => {
        if(p.author) authorProfiles.set(p.author.id, p.author);
        p.comments.forEach(c => {
            if(c.author) authorProfiles.set(c.author.id, c.author);
        });
    });

    // 5. 找出“手气最佳”（这部分逻辑已是正确的）
    let bestLuckClaimerId = null;
    if (isMultiPersonPacket && claimers.length > 1) {
        const bestLuckClaimer = claimers.reduce((max, current) => (current.amount > max.amount) ? current : max, claimers[0]);
        bestLuckClaimerId = bestLuckClaimer.userId;
    }

    // 6. 渲染领取者列表（这部分逻辑已是正确的）
    for (const claimer of claimers) {
        const claimerProfile = authorProfiles.get(claimer.userId) || { name: '一位路人', avatar: 'https://via.placeholder.com/40/DDD/666?text=?' };
        const item = document.createElement('div');
        item.className = 'claimer-item';
        let bestLuckHTML = '';
        if (claimer.userId === bestLuckClaimerId) {
            bestLuckHTML = '<span class="best-luck-badge">手气最佳</span>';
        }
        item.innerHTML = `
            <img src="${claimerProfile.avatar}" class="claimer-avatar">
            <div class="claimer-info">
                <div class="claimer-name">${claimerProfile.name}</div>
                <div class="claim-time">${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
            </div>
            <div class="claim-amount">${claimer.amount.toFixed(2)} 元 ${bestLuckHTML}</div>
        `;
        listEl.appendChild(item);
    }

    modal.style.display = 'flex';
}
        
// 请用下面这个【完整】的函数，替换掉您代码里现有的 showRedPacketModal 函数

async function showRedPacketModal(message, senderProfile) {
    const packetData = message.content;
    const modal = document.getElementById('red-packet-modal');
    const chatContext = state.contacts.find(c => c.id === state.activeChatId);
    if (!chatContext || !senderProfile) return; // 增加安全检查

    // 1. 设置弹窗内容
    document.getElementById('red-packet-sender-avatar').src = senderProfile.avatar;
    document.getElementById('red-packet-sender-name').textContent = `${senderProfile.name}的红包`;
    document.getElementById('red-packet-blessing-text').textContent = packetData.blessing;

    // 2. 重置弹窗UI状态
    const openBtn = document.getElementById('open-red-packet-btn');
    openBtn.style.display = 'flex';
    openBtn.style.transform = 'rotate(0deg)';
    document.getElementById('red-packet-result').style.display = 'none';
    document.getElementById('red-packet-content').style.backgroundColor = '#DB5A48';

    // 3. 安全地绑定事件
    const newOpenBtn = openBtn.cloneNode(true);
    openBtn.parentNode.replaceChild(newOpenBtn, openBtn);

    const closeBtn = document.getElementById('close-red-packet-modal');
    const newCloseBtn = closeBtn.cloneNode(true);
    closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);

    const detailsLink = document.getElementById('view-red-packet-details');
    const newDetailsLink = detailsLink.cloneNode(true);
    detailsLink.parentNode.replaceChild(newDetailsLink, detailsLink);

    newCloseBtn.addEventListener('click', () => modal.style.display = 'none');

    // ▼▼▼▼▼▼▼▼▼▼ 核心修复点在这里 ▼▼▼▼▼▼▼▼▼▼
    // 我们确保详情链接正确地调用了 showRedPacketDetails 函数，而不是 alert
    newDetailsLink.addEventListener('click', (e) => {
        e.preventDefault();
        showRedPacketDetails(packetData, senderProfile); 
    });
    // ▲▲▲▲▲▲▲▲▲▲ 核心修复点在这里 ▲▲▲▲▲▲▲▲▲▲

    // 4. 根据红包类型和状态决定显示内容（这部分逻辑我们之前已经完善了）
    const isGroupPacket = packetData.hasOwnProperty('count');
    
    if (isGroupPacket) {
        // --- 群聊红包逻辑 ---
        const myId = 'myProfile';
        const hasClaimed = packetData.claimers.some(c => c.userId === myId);
        const isDepleted = packetData.claimers.length >= packetData.count;

        if (hasClaimed) {
            const myClaim = packetData.claimers.find(c => c.userId === myId);
            newOpenBtn.style.display = 'none';
            document.getElementById('red-packet-result').style.display = 'block';
            document.getElementById('red-packet-amount-text').textContent = `¥${myClaim.amount.toFixed(2)}`;
            document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
        } else if (isDepleted) {
            newOpenBtn.style.display = 'none';
            document.getElementById('red-packet-result').style.display = 'block';
            document.getElementById('red-packet-amount-text').textContent = `手慢了`;
            document.getElementById('red-packet-collected-by').textContent = '红包派完了';
        } else {
            newOpenBtn.addEventListener('click', async () => {
                const remainingCount = packetData.count - packetData.claimers.length;
                const remainingAmount = packetData.totalAmount - packetData.claimers.reduce((sum, c) => sum + c.amount, 0);
                let amount = 0;
                if (remainingCount > 1) {
                    const avg = remainingAmount / remainingCount;
                    amount = Math.random() * avg * 1.8;
                    amount = Math.min(remainingAmount - (remainingCount - 1) * 0.01, amount);
                } else { amount = remainingAmount; }
                amount = Math.max(0.01, parseFloat(amount.toFixed(2)));

                state.myProfile.balance += amount;
                await addTransaction('income', amount, `抢到 ${senderProfile.name} 的群红包`, chatContext.id);
                packetData.claimers.push({ userId: 'myProfile', amount: amount });
                
                await kokoMemory.put('myProfile', state.myProfile);
                await kokoMemory.put('contacts', chatContext);

                newOpenBtn.style.transform = 'rotate(720deg)';
                await sleep(500);
                newOpenBtn.style.display = 'none';
                document.getElementById('red-packet-result').style.display = 'block';
                document.getElementById('red-packet-amount-text').textContent = `¥${amount.toFixed(2)}`;
                document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
                
                await sleep(1500);
                modal.style.display = 'none';
                await renderMyProfile();
                await openChat(chatContext.id);
            });
        }
    } else {
        // --- 私聊红包逻辑 ---
        if (packetData.opened) {
            newOpenBtn.style.display = 'none';
            document.getElementById('red-packet-result').style.display = 'block';
            document.getElementById('red-packet-amount-text').textContent = `¥${packetData.amount}`;
            document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
        } else {
            newOpenBtn.addEventListener('click', async () => {
                const amount = parseFloat(packetData.amount);
                state.myProfile.balance += amount;
                await addTransaction('income', amount, `收到 ${senderProfile.name} 的红包`, senderProfile.id);
                packetData.opened = true;
                await kokoMemory.put('myProfile', state.myProfile);
                await kokoMemory.put('contacts', chatContext);
                
                newOpenBtn.style.transform = 'rotate(720deg)';
                await sleep(500);
                newOpenBtn.style.display = 'none';
                document.getElementById('red-packet-result').style.display = 'block';
                document.getElementById('red-packet-amount-text').textContent = `¥${amount.toFixed(2)}`;
                document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
                
                await openChat(chatContext.id);
                await requestAiReply(`[SYSTEM: 我刚刚打开了你发的红包，金额是${amount.toFixed(2)}元。]`);
                
                await sleep(1500);
                modal.style.display = 'none';
            });
        }
    }
    
    modal.style.display = 'flex';
}
        async function openForumRedPacketModal(postId) {
            const post = state.posts.find(p => p.id === postId);
            if (!post || !post.redPacket) return;

            const modal = document.getElementById('red-packet-modal');
            
            // 1. 设置弹窗内容
            document.getElementById('red-packet-sender-avatar').src = post.author.avatar;
            document.getElementById('red-packet-sender-name').textContent = `${post.author.name}的红包`;
            document.getElementById('red-packet-blessing-text').textContent = post.redPacket.blessing;

            // 2. 重置弹窗UI状态
            document.getElementById('open-red-packet-btn').style.display = 'flex';
            document.getElementById('open-red-packet-btn').style.transform = 'rotate(0deg)';
            document.getElementById('red-packet-result').style.display = 'none';
            document.getElementById('red-packet-content').style.backgroundColor = '#DB5A48';

            // 3. 【关键修复】使用克隆节点的方法安全地绑定事件，防止卡死
            const oldOpenBtn = document.getElementById('open-red-packet-btn');
            const newOpenBtn = oldOpenBtn.cloneNode(true);
            oldOpenBtn.parentNode.replaceChild(newOpenBtn, oldOpenBtn);

            const oldCloseBtn = document.getElementById('close-red-packet-modal');
            const newCloseBtn = oldCloseBtn.cloneNode(true);
            oldCloseBtn.parentNode.replaceChild(newCloseBtn, oldCloseBtn);

            const oldDetailsLink = document.getElementById('view-red-packet-details');
            const newDetailsLink = oldDetailsLink.cloneNode(true);
            oldDetailsLink.parentNode.replaceChild(newDetailsLink, oldDetailsLink);

            // 4. 为新克隆的按钮添加事件监听
            newCloseBtn.addEventListener('click', () => modal.style.display = 'none');
            newDetailsLink.addEventListener('click', (e) => {
                e.preventDefault();
                showRedPacketDetails(post.redPacket, post.author);
            });

            // 5. 根据红包状态决定显示内容
            const myId = 'myProfile';
            // ▼▼▼ 修正点 ▼▼▼
            const hasClaimed = post.redPacket.claimers && post.redPacket.claimers.some(c => c.userId === myId);
            const isDepleted = post.redPacket.claimers && post.redPacket.claimers.length >= post.redPacket.count;
            // ▲▲▲ 修正点 ▲▲▲

            if (hasClaimed) {
                newOpenBtn.style.display = 'none';
                document.getElementById('red-packet-result').style.display = 'block';
                const myClaim = post.redPacket.claimers.find(c => c.userId === myId);
                document.getElementById('red-packet-amount-text').textContent = `¥${myClaim.amount.toFixed(2)}`;
                document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
            } else if (isDepleted) {
                newOpenBtn.style.display = 'none';
                document.getElementById('red-packet-result').style.display = 'block';
                document.getElementById('red-packet-amount-text').textContent = `手慢了`;
                document.getElementById('red-packet-collected-by').textContent = '红包派完了';
            } else {
                newOpenBtn.addEventListener('click', async () => {
                    // 随机分配红包金额
                    const remainingCount = post.redPacket.count - (post.redPacket.claimers ? post.redPacket.claimers.length : 0);
                    const remainingAmount = post.redPacket.amount - (post.redPacket.claimers ? post.redPacket.claimers.reduce((sum, c) => sum + c.amount, 0) : 0);
                    let amount = 0;
                    if (remainingCount > 1) {
                        const avg = remainingAmount / remainingCount;
                        amount = Math.random() * avg * 2;
                        amount = Math.min(remainingAmount * 0.9, amount);
                    } else {
                        amount = remainingAmount;
                    }
                    amount = Math.max(0.01, parseFloat(amount.toFixed(2)));

                    // 更新余额和交易记录
                    state.myProfile.balance += amount;
                    await addTransaction('income', amount, `抢到 ${post.author.name} 的论坛红包`, null);
                    
                    // 更新红包状态
                    if (!post.redPacket.claimers) post.redPacket.claimers = [];
                    post.redPacket.claimers.push({ userId: myId, amount: amount });
                    
                    // 保存数据
                    await kokoMemory.put('myProfile', state.myProfile);
                    await kokoMemory.put('posts', post);

                    // 播放动画并更新UI
                    newOpenBtn.style.transform = 'rotate(720deg)';
                    await sleep(500);
                    newOpenBtn.style.display = 'none';
                    document.getElementById('red-packet-result').style.display = 'block';
                    document.getElementById('red-packet-amount-text').textContent = `¥${amount.toFixed(2)}`;
                    document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
                    document.getElementById('red-packet-content').style.backgroundColor = '#E4A095';

                    await sleep(1500);
                    modal.style.display = 'none';
                    await renderMyProfile();
                });
            }
            
            modal.style.display = 'flex';
        }

        async function openChat(contactId) {
            if (editModeState.active) await exitEditMode();
            const contact = state.contacts.find(c => c.id === contactId);
            if (!contact) return;
// ✨ 核心V2：动态注入联系人专属CSS (保证最高优先级)

// 1. 先移除旧的（如果存在），防止上次的样式残留
let oldTag = document.getElementById('contact-specific-bubble-style');
if (oldTag) {
    oldTag.remove();
}

// 2. 只有在有内容时，才创建并注入新的 <style> 标签
if (contact.customBubbleCss) {
    const styleTag = document.createElement('style');
    styleTag.id = 'contact-specific-bubble-style';
    styleTag.textContent = contact.customBubbleCss;

    // 3. 关键：appendChild 会把它放在 <head> 的末尾，确保它覆盖所有其他主题
    document.head.appendChild(styleTag);
}
            state.activeChatId = contactId;
            // 在 openChat 函数中...

// --- 核心修复：应用聊天背景 (防闪烁版) ---
const chatScreen = document.getElementById('chat-screen');
const savedSettings = await kokoMemory.get('userSettings', 'main');
let finalBackgroundUrl = null; // 默认没有任何自定义背景

// 决定最终使用哪个背景URL
if (contact.customChatBackground) {
    // 优先级1：使用联系人的专属背景
    finalBackgroundUrl = contact.customChatBackground;
} else if (savedSettings && savedSettings.chatBackground) {
    // 优先级2：如果联系人没有专属背景，则使用全局设置的背景
    finalBackgroundUrl = savedSettings.chatBackground;
}

// 关键修复：只有在 finalBackgroundUrl 确实有值（即找到了自定义背景）时才设置它
if (finalBackgroundUrl) {
    chatScreen.style.backgroundImage = `url(${finalBackgroundUrl})`;
} else {
    // 否则，清除行内样式，让 CSS 文件里的默认背景图能够显示出来
    chatScreen.style.backgroundImage = '';
}
// --- 修复结束 ---
            updateChatInputLockState(contact.blockedStatus);
            const messagesContainer = document.getElementById('chat-messages'); if (contact.isNarrativeMode) { messagesContainer.classList.add('narrative-mode-active'); } else { messagesContainer.classList.remove('narrative-mode-active'); }
            
            chatPagination[contactId] = 1;

            document.getElementById('chat-messages').innerHTML = '';

            hideAllScreens();
            document.getElementById('chat-screen').style.display = 'flex';
      // 1. 设置名字 (保持纯净，不加火花)
    document.getElementById('chat-contact-name').textContent = contact.name;

    // 2. 【核心修改】处理左上角的火花
    const backBtn = document.getElementById('back-from-chat');
    // ▼▼▼ 【核心修复】不管有没有火花，先无条件清除所有旧图标！ ▼▼▼
    // ============================================================
    backBtn.querySelectorAll('.spark-icon-header').forEach(el => el.remove());
    backBtn.querySelectorAll('.lucky-char-badge').forEach(el => el.remove());
    // ============================================================
    // ▲▲▲ 修复结束 ▲▲▲

// 2b. 如果有连续互动，插入新火花 + 幸运字符
            if (!contact.isGroup && contact.sparkData && contact.sparkData.streak > 0) {
                const spark = getSparkInfo(contact.sparkData.streak);
                if (spark) {
                    // --- ✨ 修复步骤 1：先清理旧的图标 (把桌子擦干净) ---
                    // 移除旧火花
                    const oldSpark = backBtn.querySelector('.spark-icon-header');
                    if (oldSpark) oldSpark.remove();
                    
                    // 移除旧的幸运字符（包括那个加号），使用 querySelectorAll 删除所有残留
                    backBtn.querySelectorAll('.lucky-char-badge').forEach(el => el.remove());
                    // --- 修复结束 ---

                    // --- 1. 渲染火花 ---
                    const sparkSpan = document.createElement('span');
                    sparkSpan.className = `spark-icon-header ${spark.className}`;
                    sparkSpan.textContent = spark.icon;
                    sparkSpan.title = `🔥 连续互动 ${spark.label}`;
                    
                    sparkSpan.addEventListener('click', (e) => {
                        e.stopPropagation();
                        alert(`🔥 你们已经连续互动 ${contact.sparkData.streak} 天啦！`);
                    });
                    backBtn.appendChild(sparkSpan);

                    // --- 2. 渲染幸运字符 ---
                    const luckySpan = document.createElement('span');
                    
                    if (contact.luckyChar) {
                        const data = contact.luckyChar;
                        const type = data.type || 'common';
                        
                        // 样式
                        luckySpan.className = `lucky-char-badge lucky-char-${type}`;
                        if (data.isCompleted) {
                            luckySpan.classList.add('completed');
                        }
                        
                        // 构建字母 HTML
                        let htmlContent = "";
                        const fullWord = data.word;
                        
                        for (let i = 0; i < fullWord.length; i++) {
                            const letter = fullWord[i];
                            if (i < data.unlockedCount) {
                                htmlContent += `<span class="char-letter unlocked">${letter}</span>`;
                            } else {
                                htmlContent += `<span class="char-letter locked">${letter}</span>`;
                            }
                        }
                        luckySpan.innerHTML = htmlContent;
                        
                        // Tooltip
                        if (data.isCompleted) {
                            luckySpan.title = `✨ 已集齐：${data.word} (点击进入仓库)`;
                        } else {
                            const need = Math.max(0, 20 - data.dailyMessageCount);
                            const status = data.lastUnlockDate === new Date().toLocaleDateString() 
                                ? "今天任务已完成" 
                                : `还需聊 ${need} 句点亮下一个`;
                            luckySpan.title = `收集进度: ${data.unlockedCount}/${fullWord.length}\n${status}`;
                        }

                    } else {
                        // 未解锁状态 (+)
                        luckySpan.className = `lucky-char-badge`;
                        luckySpan.style.background = '#e0e0e0';
                        luckySpan.style.color = '#999';
                        luckySpan.style.border = '1px dashed #ccc';
                        luckySpan.style.boxShadow = 'none';
                        luckySpan.textContent = '+'; 
                        luckySpan.title = "点击抽取幸运字符";
                    }
                    
                    // 点击事件
                    luckySpan.addEventListener('click', (e) => {
                        e.stopPropagation();
                        openLuckyCharModal(contact);
                    });
                    
                    backBtn.appendChild(luckySpan);
                }
            }
            

            // --- 💡 核心修复在这里 💡 ---
            const chatStatusEl = document.getElementById('chat-contact-status');
            if (state.aiTypingStatus[contactId]) {
                // 如果“记录本”说TA正在输入，就显示“正在输入”
                chatStatusEl.textContent = contact.isGroup ? '群成员正在热烈讨论中...' : '对方正在输入...';
            } else {
                // 否则，才显示“在线”
                chatStatusEl.textContent = '在线'; 
            }
            // --- 修复结束 ---
            
            const chatPetContainer = document.getElementById('chat-pet-container');
            if (contact.pet && contact.isChatPetVisible) {
                chatPetContainer.style.display = 'block';
                updateChatPetVisuals(contact);
            } else {
                chatPetContainer.style.display = 'none';
            }

            renderChatMessages(contact);
            if (contact.unreadCount) {
                contact.unreadCount = 0;
                await kokoMemory.put('contacts', contact);
            }
        }

// ▼▼▼ 用下面这个【完整修复版】替换旧的 renderChatMessages 函数 ▼▼▼

        function renderChatMessages(contact, loadAll = false) {
            const messagesContainer = document.getElementById('chat-messages');
            const isInitialRender = messagesContainer.innerHTML === '';
            
            if (isInitialRender) {
                messagesContainer.innerHTML = '';
            }

            const page = chatPagination[contact.id] || 1;
            const start = loadAll ? 0 : Math.max(0, contact.history.length - (page * MESSAGES_PER_PAGE));
            const end = loadAll ? contact.history.length : Math.max(0, contact.history.length - ((page - 1) * MESSAGES_PER_PAGE));
            
            const allMessagesInPage = contact.history.slice(start, end);

            // 智能过滤：检查当前是否处于编辑模式
            let messagesToRender;
            if (editModeState.active) {
                // 如果是编辑模式，就显示全部消息，不做任何过滤
                messagesToRender = allMessagesInPage;
            } else {
                // 如果是普通聊天模式，就和之前一样，把通话记录隐藏起来
                messagesToRender = allMessagesInPage.filter(msg => msg.type !== 'video_call_text');
            }

            const existingLoadMoreBtn = document.getElementById('load-more-messages');
            if (existingLoadMoreBtn) {
                existingLoadMoreBtn.remove();
            }
            
            let currentScrollHeight = messagesContainer.scrollHeight;

if (!contact || !contact.history || contact.history.length === 0) {
    messagesContainer.innerHTML = `<div id="chat-placeholder" style="text-align: center; color: #999; padding: 20px;">和 ${contact ? contact.name : ''} 开始聊天吧！</div>`;
    return;
}
            
// ▼▼▼ 从这里开始替换 ▼▼▼

            let fragment = document.createDocumentFragment();
messagesToRender.forEach((msg, index) => {
                let isFirstInSequence = true;
                
                // 智能判断逻辑：只有非系统消息才需要判断头像
                if (msg.type !== 'system_notification' && msg.sender !== 'system_instruction') {
                    
                    if (index > 0) { // 检查这是否不是第一条消息
                        // 1. 只看它“紧挨着”的前一条消息
                        const immediatelyPrecedingMsg = messagesToRender[index - 1];

                        // 2. 检查前一条消息是不是“会打断连续”的类型
                        const isSequenceBreaker = 
                            immediatelyPrecedingMsg.type === 'system_notification' ||
                            immediatelyPrecedingMsg.sender === 'system_instruction' ||
                            immediatelyPrecedingMsg.type === 'heart_voice' ||
                            immediatelyPrecedingMsg.type === 'recall_ai' ||
                            immediatelyPrecedingMsg.isRecalled === true; // <-- 你的撤回也算

                        // 3. 只有当“前一条”不是打断者时，才去判断发送者是否相同
                        if (!isSequenceBreaker) {
                            if (immediatelyPrecedingMsg.sender === msg.sender) {
                                isFirstInSequence = false; // 发送者相同，隐藏头像
                            }
                        }
                        // 4. 如果前一条是打断者，isFirstInSequence 保持为 true，显示头像
                    }
                    // 5. 如果这是第一条消息 (index === 0)，isFirstInSequence 保持为 true，显示头像
                }
                
                // 如果AI强制要求显示头像，则覆盖上面的判断
                if (msg.forceAvatar) {
                    isFirstInSequence = true;
                }

                const messageEl = createMessageElement(msg, contact, isFirstInSequence);
                if(messageEl) {
                     if (editModeState.active && editModeState.selectedMessageIds.has(msg.id)) {
                        messageEl.classList.add('selected');
                    }
                    fragment.appendChild(messageEl);
                }
            });
// ▲▲▲ 替换到这里结束 ▲▲▲
            
            if (isInitialRender) {
                messagesContainer.appendChild(fragment);
            } else {
                messagesContainer.insertBefore(fragment, messagesContainer.firstChild);
            }

            if (!loadAll && start > 0) {
                const loadMoreBtn = document.createElement('button');
                loadMoreBtn.id = 'load-more-messages';
                loadMoreBtn.textContent = '加载更早的记录...';
                loadMoreBtn.style.display = 'block';
                loadMoreBtn.onclick = () => {
                    chatPagination[contact.id]++;
                    renderChatMessages(contact);
                };
                messagesContainer.prepend(loadMoreBtn);
            }
            
            if (isInitialRender || editModeState.active) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            } else {
                 messagesContainer.scrollTop = messagesContainer.scrollHeight - currentScrollHeight;
            }
        }

        // --- C. 请用这个【完整版】函数替换您现有的 createMessageElement 函数 ---
        function createMessageElement(message, contact, isFirstInSequence) {
            // ... (函数声明)

// ▼▼▼ 替换为这段新代码 ▼▼▼
if (message.isRecalled === true) {
    // 关键修改：我们不再创建气泡，而是创建系统通知
    const wrapper = document.createElement('div');
    // 1. 样式改成“system-wrapper”，让它居中
    wrapper.className = 'message-wrapper system-wrapper'; 
    wrapper.dataset.messageId = message.id;

    // 2. 插入和系统通知一样的HTML，但内容是“你撤回了”
    wrapper.innerHTML = `
        <div class="system-notification" style="background-color: #e0e0e0; color: #888;">
            你撤回了一条消息
        </div>
    `;

    // 3. 仍然绑定多选点击（以防万一你想删除它）
    wrapper.addEventListener('click', () => handleMessageSelection(wrapper, message));
    return wrapper; // 渲染完毕，直接返回
}
// ▲▲▲ 替换结束 ▲▲▲

// ... (你原来的 if (message.type === 'heart_voice') ... 等代码)
            if (message.type === 'heart_voice') return null;
            if (message.type === 'heart_voice') return null;
            if (message.sender === 'system_instruction') return null;

            if (message.type === 'system_notification') {
                const wrapper = document.createElement('div');
                wrapper.className = 'message-wrapper system-wrapper';
                wrapper.dataset.messageId = message.id;
                const notificationEl = document.createElement('div');
                notificationEl.className = 'system-notification';
                notificationEl.textContent = message.content;
                wrapper.appendChild(notificationEl);
                wrapper.addEventListener('click', () => handleMessageSelection(wrapper, message));
                return wrapper;
            }

            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${message.sender === 'user' ? 'sent' : 'received'}`;
            // ✨ 这是修改后的正确代码 ✨
if (contact.isAvatarHidden && (message.sender === 'contact' || message.sender === contact.id)) {
    wrapper.classList.add('contact-avatar-hidden');

            }
             // ▼▼▼ 把下面这段新代码粘贴到这里 ▼▼▼
            // 新增逻辑：如果消息是AI发的HTML，添加一个特殊类来隐藏UI元素
            if (message.type === 'html' && message.sender !== 'user') {
                wrapper.classList.add('ai-html-message');
                // 我们也借用这个已有的类来移除消息体的左边距
                wrapper.classList.add('contact-avatar-hidden'); 
            }
            // ▲▲▲ 新代码粘贴结束 ▲▲▲
            wrapper.dataset.messageId = message.id; 
            if (isFirstInSequence) {
                wrapper.classList.add('is-first-in-sequence');
                wrapper.style.marginTop = '10px';
            }

            const senderInfo = message.sender === 'user' ? state.myProfile : contact;
            
            // ▼▼▼ 在它下面，添加这段新的逻辑 ▼▼▼
    let finalSenderInfo = senderInfo;
    const isGroupChat = contact.isGroup === true;
    // ▼▼▼ ✨ 你的核心修改点在这里 ✨ ▼▼▼
            if (message.sender === 'user') {
                // 检查当前聊天（私聊或群聊）是否设置了自定义昵称
                if (contact.customUserName) {
                    // 如果设置了，就创建一个临时的 profile 对象，把名字改掉
                    // 注意：我们必须克隆(clone)它，否则会污染 state.myProfile
                    finalSenderInfo = { ...state.myProfile, name: contact.customUserName };
                } else {
                    // 否则，就用全局的 myProfile
                    finalSenderInfo = state.myProfile;
                }
            } 
            // ▲▲▲ ✨ 修改结束 ✨ ▲▲▲

    else if (isGroupChat && message.sender !== 'user') {
        // --- ✨ 修正开始 ✨ ---
        // 1. 先在主联系人列表里找
        let foundProfile = state.contacts.find(c => c.id === message.sender);
        
        if (!foundProfile && contact.npcMembers) {
            // 2. 没找到？去当前群聊的 NPC 列表里找
            foundProfile = contact.npcMembers.find(npc => npc.id === message.sender);
        }

        // 3. 
        if (foundProfile) {
            finalSenderInfo = foundProfile;
        } else {
            finalSenderInfo = { name: '未知成员', avatar: '' }; // 真的找不到了
        }
        // --- ✨ 修正结束 ✨ ---
    }
    const showAuthorName = isFirstInSequence;
    // ▲▲▲ 添加结束 ▲▲▲
    // --- 核心修改：决定最终要显示的头像URL ---
            let finalAvatarUrl = finalSenderInfo.avatar;
            if (message.sender === 'user' && contact.customUserAvatar) {
                // 如果是用户发的消息，并且当前联系人设置了自定义用户头像，就用它！
                finalAvatarUrl = contact.customUserAvatar;
            }
            // --- 修改结束 ---
            // --- 新增：构建引用消息框的HTML ---
            let quoteHTML = '';
            if (message.quote) {
                quoteHTML = `
                    <div class="message-quote" data-quoted-id="${message.quote.messageId}">
                        <div class="sender">${message.quote.senderName}</div>
                        <div class="content">${message.quote.content}</div>
                    </div>
                `;
            }

            let messageContentHTML = '';

            switch (message.type) {
              // 在 createMessageElement 函数的 switch 语句中
case 'location_share': {
    const loc = message.content;
    messageContentHTML = `
        <div class="message location-share-card">
            <div class="location-card-icon"><i class="${loc.icon || 'fas fa-map-marker-alt'}"></i></div>
            <div class="location-card-info">
                <div class="name">${loc.name}</div>
                <div class="footer">位置信息 · 点击查看</div>
            </div>
        </div>`;
    break;
}
// ... 在 createMessageElement 函数的 switch 语句中 ...
// ... 在 switch (message.type) { 里面 ...

            // ▼▼▼ 在这里粘贴新的 case ▼▼▼
            case 'chat_history_share': {
                const data = message.content;
                
                // 这是一个辅助函数，用来把消息内容转成文字预览
                const getPreviewText = (msg) => {
                    switch(msg.type) {
                        case 'text':
                        case 'html': return msg.content.replace(/<[^>]+>/g, ''); // 移除HTML
                        case 'voice': return `[语音] ${msg.content.text}`;
                        case 'image':
                        case 'uploaded_image': return `[图片]${msg.isEmoticon ? msg.emoticonName : ''}`;
                        case 'picture_description': return `[图片] ${msg.content.description}`;
                        case 'red_packet': return `[红包] ${msg.content.blessing}`;
                        case 'transfer': return `[转账] ¥${msg.content.amount}`;
                        case 'music_share': return `[音乐] ${msg.content.title}`;
                        case 'location_share': return `[位置] ${msg.content.name}`;
                        case 'post_share': return `[分享的帖子]`;
                        case 'product_share': return `[分享的商品] ${msg.content.productDetails.name}`;
                        default: return `[${msg.type} 消息]`;
                    }
                };
                
                let itemsHTML = '';
                // 只显示最新的几条作为预览
                const messagesPreview = data.messages; // 最多预览5条

                for (const msg of messagesPreview) {
                    // 兼容 'user' 和 'myProfile'
                    const isSent = (msg.sender === 'user' || msg.sender === 'myProfile');
                    const senderName = data.participants[msg.sender]?.name || '未知';
                    const contentPreview = getPreviewText(msg);

                    itemsHTML += `
                        <div class="ch-item ${isSent ? 'sent' : 'received'}">
                            ${!isSent ? `<div class="ch-sender">${senderName}</div>` : ''}
                            <div class="ch-bubble">
                                ${contentPreview.substring(0, 100)}${contentPreview.length > 100 ? '...' : ''}
                            </div>
                        </div>
                    `;
                }
                

                // 组装成卡片
                messageContentHTML = `
                    <div class="message chat-history-card">
                        <div class="ch-header">${data.sourceChatName}</div>
                        <div class="ch-body">
                            ${itemsHTML}
                        </div>
                        <div class="ch-footer">聊天记录</div>
                    </div>`;
                break;
            }
            // ▲▲▲ new case 粘贴结束 ▲▲▲

// 在 case 'image': 的下面，添加一个新的 case
case 'uploaded_image':
    // 这个逻辑和 type: 'image' 非常像，但是 src 直接使用 Base64
    messageContentHTML = `
        <div class="message image-message">
            <div class="message-image-container ${message.sender === 'user' ? 'sent' : 'received'}">
                <img src="${message.content.base64}" class="message-image" alt="上传的图片">
            </div>
        </div>`;
    break;  
                case 'location_share': { const loc = message.content; messageContentHTML = ` <div class="message location-share-card"> <div class="location-card-icon"> <i class="${loc.icon || 'fas fa-map-marker-alt'}"></i> </div> <div class="location-card-info"> <div class="name">${loc.name}</div> <div class="footer">位置信息 · 点击查看</div> </div> </div>`; break; }
                case 'html':
                    // ▼▼▼ 核心修改 ▼▼▼
                    if (message.sender === 'user') {
                        // 如果用户自己发HTML (虽然不太可能)，还是用气泡包起来
                        messageContentHTML = `<div class="message sent">${quoteHTML}${message.content}</div>`;
                    } else {
                        // 如果是AI发的HTML (我们刚给wrapper加了标记)，则不再需要气泡，直接注入原始HTML
                        messageContentHTML = `${quoteHTML}${message.content}`;
                    }
                    // ▲▲▲ 修改结束 ▲▲▲
                    break;
                case 'image':
                    messageContentHTML = `<div class="message image-message"><div class="message-image-container ${message.sender === 'user' ? 'sent' : 'received'}"><img src="${message.url}" class="message-image" alt="图片"></div></div>`;
                    break;
                case 'post_share': {
                    const post = state.posts.find(p => p.id === message.content.postId);
                    if (post) {
                        messageContentHTML = `
                        <div class="message post-share-card" data-post-id="${post.id}">
                            <div class="post-share-header">
                                <img src="${post.author.avatar}" class="post-share-avatar">
                                <span class="post-share-name">${post.author.name}</span>
                            </div>
                            <div class="post-share-content">${post.content}</div>
                            <div class="post-share-footer">分享的帖子</div>
                        </div>`;
                    } else {
                        messageContentHTML = `<div class="message received">帖子已被删除</div>`;
                    }
                    break;
                }
                // ▼▼▼ 把下面这段完整的 case 代码块粘贴进去 ▼▼▼
case 'product_share': {
    const shareData = message.content;
    const product = shareData.productDetails;
    const intentText = shareData.intent === 'gift' 
        ? `🎁 我送你一个礼物` 
        : `🥺 可以帮我付下款吗？`;

    // 重新构建卡片的HTML内容
    messageContentHTML = `
        <div class="message product-share-card">
            <div class="product-share-intent">${intentText}</div>
            <div class="product-share-body">
                <div class="product-share-info">
                    <div class="product-title">${product.name}</div>
                    
                    <div class="product-description" style="margin-top: 5px; font-size: 13px; color: #666; line-height: 1.5;">${product.description}</div>
                    
                    <div class="product-price" style="margin-top: 8px; text-align: right;"><span>¥</span>${product.price}</div>
                </div>
            </div>
            <div class="product-share-accompanying-msg">${shareData.accompanyingMessage}</div>
        </div>`;
    break;
}
// ▲▲▲ 粘贴到这里结束 ▲▲▲
// ▼▼▼ 用这段【V4 - 统一居中版】代码替换旧的 'case recall_ai' ▼▼▼
    case 'recall_ai': {
        // 1. 获取发送者名字 (这个不变)
        const senderName = (contact.isGroup)
            ? (state.contacts.find(c => c.id === message.sender)?.name || '成员')
            : contact.name;
        
        // 2. 关键：创建【居中】的 wrapper (两个状态都用它)
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-wrapper'; 
        wrapper.dataset.messageId = message.id;

        if (message.isRevealed) {
            // --- 状态 2: 已点开 (渲染成“已揭示”的居中提示) ---
            // 内部的 div 使用了 'system-notification' 和 'recall-ai-revealed'
            wrapper.innerHTML = `
                <div class="system-notification recall-ai-revealed">
                    <span class="recall-prefix">[撤回内容]</span>
                    ${message.content.replace(/\n/g, '<br>')}
                </div>
            `;
        } else {
            // --- 状态 1: 未点开 (渲染成“占位符”的居中提示) ---
            // 内部的 div 使用了 'system-notification' 和 'recall-ai-placeholder'
            wrapper.innerHTML = `
                <div class="system-notification recall-ai-placeholder">
                    ${senderName} 撤回了一条消息
                </div>
            `;
        }
        
        // 3. 绑定点击事件 (这个不变)
        wrapper.addEventListener('click', () => handleMessageSelection(wrapper, message));
        return wrapper; // 返回这个居中的 wrapper
    }
// ▲▲▲ 替换结束 ▲▲▲
case 'picture_description':
                    // [V-MOD 2.0] "翻转"卡片 HTML 结构

                    // 👇 你的占位图 URL 放在这里
                    const aiImageUrl = "https://s21.ax1x.com/2025/11/10/pZ9NqTx.jpg"; 

                    messageContentHTML = `
                        <div class="message picture-description ${message.sender === 'user' ? 'sent' : 'received'}">
                            <div class="message-image-container">
                                <img src="${aiImageUrl}" class="message-image" alt="AI 图片预览">

                                <div class="picture-description-text">
                                    ${message.content.description.replace(/\n/g, '<br>')}
                                </div>
                            </div>
                        </div>`;
                    break; // 确保 break 还在
                case 'voice':
                    const voiceData = message.content;
                    const width = Math.min(200, 80 + parseInt(voiceData.duration) * 5) + 'px';
                    messageContentHTML = `<div class="message voice ${message.sender === 'user' ? 'sent' : 'received'}" style="width: ${width};"><div class="voice-duration">${voiceData.duration}''</div><i class="fas fa-wifi"></i></div>`;
                    break;
                // 在 createMessageElement 函数的 switch 语句内...

case 'red_packet':
    const packetData = message.content;
    let statusHTML = '';
    let footerText = '聊天红包';

    if (packetData.hasOwnProperty('count')) {
        // 这是群聊红包
        const isDepleted = packetData.claimers.length >= packetData.count;
        if (isDepleted) {
            statusHTML = `<div class="red-packet-status">红包已被领完</div>`;
        } else {
            statusHTML = `<div class="red-packet-blessing">${packetData.blessing}</div>`;
        }
        footerText = '群聊红包';
    } else {
        // 这是私聊红包
        statusHTML = packetData.opened ? `<div class="red-packet-status">红包已被领取</div>` : `<div class="red-packet-blessing">${packetData.blessing}</div>`;
    }
    
    // 如果已经被我领取了，也显示为 opened 状态
    const myId = 'myProfile';
    const hasClaimed = packetData.claimers && packetData.claimers.some(c => c.userId === myId);
    const isOpened = packetData.opened || hasClaimed;

    messageContentHTML = `<div class="message red-packet ${isOpened ? 'opened' : ''} ${message.sender === 'user' ? 'sent' : 'received'}"><div class="red-packet-header"><div class="red-packet-icon">🧧</div>${statusHTML}</div><div class="red-packet-footer">${footerText}</div></div>`;
    break;
                // 在 createMessageElement 函数的 switch 语句内...

case 'transfer': {
    const transferData = message.content;
    let transferClasses = 'message transfer';
    if (transferData.returned) {
        transferClasses += ' returned';
    } else if (transferData.completed) {
        transferClasses += ' completed';
    }

    let footerText = '聊天转账';
    if (transferData.returned) {
        footerText = '转账已退还';
    } else if (transferData.completed) {
        footerText = message.sender === 'user' ? '对方已收款' : '已存入钱包';
    }

    // 新增：判断是否是群聊转账，并显示收款人
    let recipientInfoHTML = '';
    if (transferData.recipientId) {
        const recipient = state.contacts.find(c => c.id === transferData.recipientId);
        if (recipient) {
            recipientInfoHTML = `<div class="transfer-text">转账给 ${recipient.name}</div>`;
        }
    } else {
        recipientInfoHTML = `<div class="transfer-text">转账</div>`;
    }

    messageContentHTML = `
        <div class="${transferClasses} ${message.sender === 'user' ? 'sent' : 'received'}">
            <div class="transfer-header">
                <div class="transfer-icon"><i class="fas fa-money-bill-wave"></i></div>
                <div class="transfer-info">
                    ${recipientInfoHTML}
                    <div class="transfer-amount">¥ ${transferData.amount}</div>
                </div>
            </div>
            <div class="transfer-footer">${footerText}</div>
        </div>`;
    break;
}
case 'music_share':
    const music = message.content;
    // ✨ 智能判断：有封面就用<img>，没封面就用<i>图标 ✨
    const coverInner = music.cover 
        ? `<img src="${music.cover}" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover; opacity: 0.9;">`
        : `<i class="fas fa-music"></i>`;

    messageContentHTML = `
    <div class="message music-share-card ${message.sender === 'user' ? 'sent' : 'received'}">
        <div class="music-card-cover">
            ${coverInner}
            <span class="music-card-play-btn"><i class="fas fa-play"></i></span>
        </div>
        <div class="music-card-info">
            <div class="music-card-title">${music.title}</div>
            <div class="music-card-artist">${music.artist || '未知艺术家'}</div>
            <div class="music-card-progress-bar"><div class="music-card-progress"></div></div>
            <div class="music-card-controls">
                <span class="music-card-time">00:00</span>
                <span class="music-card-loop-btn" title="列表循环"><i class="fas fa-repeat"></i></span>
            </div>
        </div>
    </div>`;
    break;
                case 'game_wheel': {
                    const wheel = message.content;
                    const myProfile = state.myProfile;
                    const contact = state.contacts.find(c => c.id === state.activeChatId);

                    const userResultHTML = wheel.results.user
                        ? `<div class="wheel-player-result">${wheel.results.user}</div>`
                        : `<button class="spin-btn" data-player="user">点击开转</button>`;

                    const contactResultHTML = wheel.results.contact
                        ? `<div class="wheel-player-result">${wheel.results.contact}</div>`
                        : `<div class="wheel-player-result">等待对方...</div>`;

                    messageContentHTML = `
                        <div class="message game-wheel-card">
                            <div class="wheel-card-title">🎲 ${wheel.name} 🎲</div>
                            <div class="wheel-card-result-area">
                                <div class="wheel-result-row">
                                    <span class="wheel-player-name">${myProfile.name}</span>
                                    ${userResultHTML}
                                </div>
                                <div class="wheel-result-row">
                                    <span class="wheel-player-name">${contact.name}</span>
                                    ${contactResultHTML}
                                </div>
                            </div>
                        </div>`;
                    break;
                }
                default: 
                    let formattedContent = message.content;
                    const tempDiv = document.createElement('div');
                    tempDiv.textContent = formattedContent;
                    formattedContent = tempDiv.innerHTML;
                    formattedContent = formattedContent.replace(/\{(.*?)\}/g, '<span class="narrative-psychology">$1</span>');
                    formattedContent = formattedContent.replace(/(?:&quot;|“|”|＂)(.*?)(?:&quot;|“|”|＂)/g, '<span class="narrative-speech">“$1”</span>');
                    formattedContent = formattedContent.replace(/\*(.*?)\*/g, '<span class="narrative-action">$1</span>');
                    formattedContent = formattedContent.replace(/\n/g, '<br>');
                    // ↓↓↓ 核心改动：将 quoteHTML 插入到消息内容之前
                    messageContentHTML = `<div class="message ${message.sender === 'user' ? 'sent' : 'received'}">${quoteHTML}${formattedContent}</div>`;
                    break;
            }

            if (message.type !== 'text') {
                messageContentHTML = quoteHTML + messageContentHTML;
            }

            // [V-MOD 2.0] 只为 voice 创建外部文字框
const transcribedTextHTML = (message.type === 'voice') ? '<div class="transcribed-text"></div>' : '';
            
            // --- 新增：在消息体旁边添加回复按钮 ---
            const replyButtonHTML = '<i class="fas fa-reply reply-btn"></i>';
            // ... (replyButtonHTML那行)

// ▼▼▼ 第2处修改：粘贴这段代码 ▼▼▼
let recallButtonHTML = ''; // 1. 默认是空的
if (message.sender === 'user' && message.type !== 'system_notification') { // 2. 只有用户发的消息才有
    recallButtonHTML = '<i class="fas fa-undo recall-btn"></i>';
}
// ▲▲▲ 修改结束 ▲▲▲

            wrapper.innerHTML = `
        <div class="message-avatar">
    <img src="${finalAvatarUrl}" onerror="this.onerror=null;this.src='https://via.placeholder.com/40/DDD/666?text=U';">
</div>
        <div class="message-body">
            ${showAuthorName ? `<div class="message-author-name">${finalSenderInfo.name}</div>` : ''}
            ${messageContentHTML}
            ${transcribedTextHTML}
            <div class="message-timestamp">${message.time}</div>
        </div>
        ${replyButtonHTML} ${recallButtonHTML}
    `;
            wrapper.addEventListener('click', () => handleMessageSelection(wrapper, message));
            return wrapper;
        }
        
        async function addSharedMemory(contact, description) {
            if (!contact) return;
            if (!contact.memories) contact.memories = [];

            const newMemory = {
                id: `memo_${Date.now()}`,
                timestamp: Date.now(),
                description: description
            };
            contact.memories.push(newMemory);
            await kokoMemory.put('contacts', contact);
        }

        async function checkForPetLevelUp(contact) {
            if (!contact.pet) return;
            const xpForNextLevel = 100;

            if (contact.pet.xp >= xpForNextLevel) {
                contact.pet.xp -= xpForNextLevel;
                contact.pet.level += 1;

                let evolutionMessage = '';
                let evolutionForm = contact.pet.form;

                if (contact.pet.level === 5 && contact.pet.form === 'baby') {
                    evolutionForm = 'toddler';
                    evolutionMessage = `在你们的精心照料下，史莱姆长大了！进化成了可爱的幼年期形态！`;
                } else if (contact.pet.level === 15 && contact.pet.form === 'toddler') {
                    evolutionForm = 'teenager';
                    evolutionMessage = `哇！光芒闪过，史莱姆再次进化，进入了活泼的少年期！`;
                }

                if (evolutionMessage) {
                    contact.pet.form = evolutionForm;
                    await createSystemNotification(evolutionMessage);
                    await requestAiReply(`[SYSTEM: 你们的宠物刚刚进化了！${evolutionMessage} 请你对此发表一段极其兴奋和开心的感言！]`);
                    await addSharedMemory(contact, `在LV.${contact.pet.level}时，我们的史莱姆进化成了“${evolutionForm}”形态！`);
                } else {
                    await createSystemNotification(`你们的聊天让史莱姆获得了成长！升到了 LV.${contact.pet.level}！`);
                }
                
                await kokoMemory.put('contacts', contact);
            }
        }

        async function addTransaction(type, amount, description, relatedContactId = null) {
            const newTransaction = {
                id: `txn_${Date.now()}`,
                timestamp: Date.now(),
                type: type, // 'income' 或 'expense'
                amount: amount,
                description: description,
                relatedContactId: relatedContactId
            };
            if (!state.transactions) state.transactions = [];
            state.transactions.push(newTransaction);
            await kokoMemory.put('transactions', newTransaction);
        }
/**
 * (V5 扩容版) 获取完整的字符配置库
 * 包含 60+ 个精选单词
 */
function getLuckyWordConfig() {
    return [
        // =========================================
        // [Epic 史诗] - 1% 概率 - 极致浪漫与永恒
        // =========================================
        { word: "FOREVER", type: "epic", meaning: "永恒的誓言" },
        { word: "ETERNITY", type: "epic", meaning: "不朽的时光" },
        { word: "UNIVERSE", type: "epic", meaning: "你是我的宇宙" },
        { word: "SERENDIPITY", type: "epic", meaning: "美好的不期而遇" },
        { word: "EUPHORIA", type: "epic", meaning: "极致的欢愉" },
        { word: "PARADISE", type: "epic", meaning: "伊甸园" },
        { word: "INFINITY", type: "epic", meaning: "无限可能" },
        { word: "MIRACLE", type: "epic", meaning: "奇迹降临" },
        { word: "GALAXY", type: "epic", meaning: "璀璨银河" },
        { word: "DESTINY", type: "epic", meaning: "命中注定" },
        { word: "ODYSSEY", type: "epic", meaning: "伟大的旅程" },
        { word: "GENESIS", type: "epic", meaning: "起源" },

        // =========================================
        // [Rare 稀有] - 9% 概率 - 深情与独特
        // =========================================
        { word: "CRUSH", type: "rare", meaning: "心动" },
        { word: "CHERISH", type: "rare", meaning: "珍爱" },
        { word: "BREEZE", type: "rare", meaning: "温柔晚风" },
        { word: "SUNSET", type: "rare", meaning: "日落" },
        { word: "PROMISE", type: "rare", meaning: "誓言" },
        { word: "SECRET", type: "rare", meaning: "秘密" },
        { word: "SPIRIT", type: "rare", meaning: "灵魂" },
        { word: "DIVINE", type: "rare", meaning: "神圣" },
        { word: "GLORY", type: "rare", meaning: "荣耀" },
        { word: "DREAM", type: "rare", meaning: "梦境" },
        { word: "MEMORY", type: "rare", meaning: "回忆" },
        { word: "LEGEND", type: "rare", meaning: "传说" },
        { word: "SPARK", type: "rare", meaning: "火花" },
        { word: "BLOOM", type: "rare", meaning: "绽放" },
        { word: "MOONLIGHT", type: "rare", meaning: "白月光" },
        { word: "STARDUST", type: "rare", meaning: "星尘" },
        { word: "AURORA", type: "rare", meaning: "极光" },
        { word: "MYSTERY", type: "rare", meaning: "神秘" },
        
        // =========================================
        // [Common 普通] - 90% 概率 - 日常与陪伴
        // =========================================
        { word: "HELLO", type: "common", meaning: "你好呀" },
        { word: "SMILE", type: "common", meaning: "笑一个" },
        { word: "HAPPY", type: "common", meaning: "开心" },
        { word: "LUCKY", type: "common", meaning: "幸运" },
        { word: "SWEET", type: "common", meaning: "甜甜的" },
        { word: "WARM", type: "common", meaning: "温暖" },
        { word: "DAILY", type: "common", meaning: "日常" },
        { word: "TRUST", type: "common", meaning: "信任" },
        { word: "BRAVE", type: "common", meaning: "勇敢" },
        { word: "POWER", type: "common", meaning: "力量" },
        { word: "PEACE", type: "common", meaning: "安宁" },
        { word: "CALM", type: "common", meaning: "平静" },
        { word: "FRESH", type: "common", meaning: "新鲜" },
        { word: "START", type: "common", meaning: "开始" },
        { word: "NICE", type: "common", meaning: "不错" },
        { word: "COOL", type: "common", meaning: "酷" },
        { word: "FINE", type: "common", meaning: "很好" },
        { word: "OKAY", type: "common", meaning: "好的" },
        { word: "YES", type: "common", meaning: "是的" },
        { word: "HUG", type: "common", meaning: "抱抱" },
        { word: "KISS", type: "common", meaning: "亲亲" },
        { word: "BABY", type: "common", meaning: "宝贝" },
        { word: "DEAR", type: "common", meaning: "亲爱的" },
        { word: "HOPE", type: "common", meaning: "希望" },
        { word: "WISH", type: "common", meaning: "许愿" },
        { word: "PURE", type: "common", meaning: "纯净" },
        { word: "SOFT", type: "common", meaning: "柔软" },
        { word: "TIME", type: "common", meaning: "时间" }
    ];
}

/**
 * (核心) 执行一次抽卡逻辑
 */
async function drawLuckyCharacter(contact) {
    // 1. 初始化数据结构
    if (!contact.luckyCharInventory) contact.luckyCharInventory = [];
    if (!contact.luckyCharGacha) contact.luckyCharGacha = { count: 0, lastDate: "" };

    // 2. 检查每日次数
    const today = new Date().toLocaleDateString();
    if (contact.luckyCharGacha.lastDate !== today) {
        contact.luckyCharGacha.count = 0;
        contact.luckyCharGacha.lastDate = today;
    }

    if (contact.luckyCharGacha.count >= 3) {
        alert("今天的运气已经用完啦！明天再来抽吧 (每日限3次)。");
        return null;
    }

    // 3. 消耗次数
    contact.luckyCharGacha.count++;
    await kokoMemory.put('contacts', contact); // 先保存次数，防刷

    // 4. 抽卡算法 (新手保底机制)
    const config = getLuckyWordConfig();
    let result = null;

    // 如果仓库是空的，强制必中一个 Common 或 Rare (给点甜头)
    if (contact.luckyCharInventory.length === 0) {
        const starters = config.filter(c => c.type !== 'epic');
        result = starters[Math.floor(Math.random() * starters.length)];
    } else {
        // 正常概率：Epic 5%, Rare 25%, Common 70%
        const rand = Math.random();
        let pool = [];
        if (rand < 0.05) pool = config.filter(c => c.type === 'epic');
        else if (rand < 0.30) pool = config.filter(c => c.type === 'rare');
        else pool = config.filter(c => c.type === 'common');
        
        result = pool[Math.floor(Math.random() * pool.length)];
    }

    // 5. 检查重复
    // 如果抽到了已有的，转化为“碎片”或者直接提示 (这里简单处理：允许重复，变成“升级”或者单纯提示已拥有)
    // 为了简单体验好，我们这里逻辑是：如果重复了，就提示“转化为了祝福”，如果不重复，就收入库中
    const existing = contact.luckyCharInventory.find(c => c.word === result.word);
    
    if (existing) {
        alert(`✨ 哎呀，抽到了重复的【${result.word}】(${result.meaning})！\n它化作流星飞走了... (今日剩余 ${3 - contact.luckyCharGacha.count} 次)`);
        return null; // 没拿到新东西
    }

    // 6. 创建新实例
    const newChar = {
        id: `char_${Date.now()}`,
        word: result.word,
        type: result.type,
        meaning: result.meaning,
        unlockedCount: 0,
        dailyMessageCount: 0,
        lastActivityDate: "",
        lastUnlockDate: "",
        isCompleted: false,
        obtainedDate: Date.now()
    };

    // 7. 入库
    contact.luckyCharInventory.push(newChar);
    
    // 如果当前没有佩戴的，自动佩戴
    if (!contact.luckyChar) {
        contact.luckyChar = newChar;
    }

    await kokoMemory.put('contacts', contact);
    
    return newChar; // 返回抽到的对象
}
/**
 * (V-Fix 修复版) 检查并更新幸运字符进度
 * 包含自动修复逻辑：如果发现数据不完整，自动补全，无需手动重置
 */
async function checkLuckyCharProgress(contact) {
    console.log(">>> 进入 checkLuckyCharProgress 函数"); // 调试入口

    // 1. 基础检查
    if (!contact) {
        console.log("❌ 失败：contact 对象不存在");
        return;
    }
    if (!contact.luckyChar) {
        console.log("❌ 失败：当前联系人没有 luckyChar 数据 (未佩戴)");
        return;
    }
    
    const charData = contact.luckyChar;
    console.log("✅ 读到幸运字符数据:", JSON.stringify(charData)); // 打印数据看看是不是坏的

    // --- 数据自愈 ---
    let fixed = false;
    if (typeof charData.dailyMessageCount === 'undefined') { charData.dailyMessageCount = 0; fixed = true; }
    if (typeof charData.unlockedCount === 'undefined') { charData.unlockedCount = 0; fixed = true; }
    if (!charData.lastActivityDate) { charData.lastActivityDate = new Date().toLocaleDateString(); fixed = true; }
    
    if (fixed) console.log("🔧 数据已自动修复缺损字段");

    const today = new Date().toLocaleDateString();

    // 2. 检查是否已完成
    if (charData.unlockedCount >= charData.word.length) {
        console.log("⏹ 任务结束：字符已全部点亮");
        return;
    }

    // 3. 跨天重置
    if (charData.lastActivityDate !== today) {
        console.log("📅 新的一天，重置计数器");
        charData.dailyMessageCount = 0;
        charData.lastActivityDate = today;
        charData.lastUnlockDate = ""; 
    }

    // 4. 计数
    charData.dailyMessageCount++;
    console.log(`📈 计数增加！当前进度: ${charData.dailyMessageCount}/20`); // 这里就是你要看的

    // 5. 判断点亮
    if (charData.dailyMessageCount >= 20 && charData.lastUnlockDate !== today) {
        console.log("🎉 达标！点亮一个字母！");
        charData.unlockedCount++;
        charData.lastUnlockDate = today;

        // 刷新界面
        if (state.activeChatId === contact.id) {
            openChat(contact.id);
        }
        // 发送通知
        const progress = `${charData.unlockedCount}/${charData.word.length}`;
        await createSystemNotification(`🌟 每日亲密度达标！点亮幸运字符新字母 (${progress})`, contact);
    } else {
        console.log("⏳ 尚未达标或今日已点亮，继续加油");
    }
    
    // 6. 保存
    await kokoMemory.put('contacts', contact);
}
/**
 * (新) 更新联系人的火花/亲密度状态
 * @param {object} contact - 联系人对象
 */
async function updateContactSpark(contact) {
    const today = new Date();
    // 获取 "YYYY-MM-DD" 格式的日期字符串，确保跨天判断准确
    const dateStr = today.getFullYear() + '-' + (today.getMonth() + 1) + '-' + today.getDate();

    // 初始化数据结构 (兼容旧数据)
    if (!contact.sparkData) {
        contact.sparkData = {
            lastActiveDate: null,
            streak: 0
        };
    }

    const lastDate = contact.sparkData.lastActiveDate;
    
    if (lastDate === dateStr) {
        // 1. 如果上次互动就是今天，天数不变
        return; 
    }

    if (lastDate) {
        const last = new Date(lastDate);
        // 计算相差天数
        const diffTime = Math.abs(today - last);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); 

        if (diffDays === 1) {
            // 2. 如果是昨天互动的，天数 +1
            contact.sparkData.streak += 1;
        } else if (diffDays > 1) {
            // 3. 如果断签了 (超过1天)，重置为 1
            contact.sparkData.streak = 1;
        }
    } else {
        // 4. 第一次互动
        contact.sparkData.streak = 1;
    }

    // 更新日期
    contact.sparkData.lastActiveDate = dateStr;
    
    // 保存到数据库
    await kokoMemory.put('contacts', contact);
}

/**
 * (修改版) 根据天数获取火花图标和样式类
 */
function getSparkInfo(streak) {
    if (!streak || streak <= 0) return null;
    
    if (streak >= 30) {
        // 等级 4: 巨轮/深爱
        return { icon: '🔥', label: `${streak}天`, className: 'spark-level-4' }; 
    } else if (streak >= 7) {
        // 等级 3: 大火花
        return { icon: '🔥', label: `${streak}天`, className: 'spark-level-3' }; 
    } else if (streak >= 4) {
        // 等级 2: 小火花
        return { icon: '🔥', label: `${streak}天`, className: 'spark-level-2' }; 
    } else if (streak >= 1) {
        // ✨ 改动在这里：等级 1 也统一用火花图标
        return { icon: '🔥', label: `${streak}天`, className: 'spark-level-1' }; 
    }
    return null;
}
// --- 修改：消息创建函数 (V3 - 修复上下文切换BUG版) ---
async function createAndAddMessage(messageData, sender = 'user', targetContact = null, forceShowAvatar = false, contextMode = null) {
    // 1. 获取目标联系人对象
    const contact = targetContact || state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) {
        console.error("createAndAddMessage: 找不到目标联系人对象。");
        return; // 如果找不到联系人，则无法继续
    }

    // 2. 【核心修复】根据传入的 `contextMode` 决定使用哪个历史记录数组
    //    优先使用传入的 contextMode（'chat' 或 'sms'）
    //    如果没有传入（null），则回退到使用当前的全局UI模式（这是旧的、可能导致bug的行为）
    const effectiveMode = contextMode || state.currentChatMode;
    const historyArray = (effectiveMode === 'sms') ? 'smsHistory' : 'history';
    
    if (!contact[historyArray]) {
        contact[historyArray] = []; // 如果数组不存在，先创建
    }

    // 3. (仅聊天模式) 处理宠物经验和首次聊天日期
    if (historyArray === 'history') { // 仅适用于 App 内聊天
        if (contact.pet && sender !== 'system_instruction' && messageData.type !== 'system_notification') {
            contact.pet.xp += 1;
            await checkForPetLevelUp(contact);
        }
        if (contact[historyArray].length === 0) { // 仅第一次聊天时记录
            contact.firstChatDate = Date.now();
        }
    }

    // 4. 创建完整的消息对象 (使用 effectiveMode 修复ID前缀)
    const fullMessage = {
        id: `${effectiveMode}_${Date.now()}_${Math.random()}`, // ID 前缀区分
        time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
        timestamp: Date.now(),
        sender: sender,
        ...messageData,
        forceAvatar: forceShowAvatar // 是否强制显示头像 (用于自动回复)
    };
    // 5. 将消息添加到正确的历史记录数组
    contact[historyArray].push(fullMessage);

    // 6. (可选) 处理后台通知 (如果应用在后台)
    if (sender !== 'user' && sender !== 'system' && sender !== 'system_instruction' && document.hidden) {
        let notificationBody = '';
        // 根据消息类型生成不同的通知预览文本
        switch(fullMessage.type) {
            case 'text':
            case 'html':
                // 对于过长的文本，截断预览
                notificationBody = fullMessage.content.length > 50 ? fullMessage.content.substring(0, 50) + '...' : fullMessage.content;
                break;
            case 'image':
            case 'uploaded_image': // 处理用户上传的图片
            case 'picture_description': // 处理AI描述的图片
                notificationBody = '[发来了一张图片]';
                break;
            case 'voice':
                notificationBody = '[发来了一段语音]';
                break;
            case 'red_packet':
                notificationBody = `[发来了一个红包] ${fullMessage.content.blessing || '恭喜发财'}`;
                break;
            case 'transfer':
                notificationBody = `[发来了一笔转账] ¥${fullMessage.content.amount}`;
                break;
            case 'music_share':
                notificationBody = `[分享了音乐] ${fullMessage.content.title}`;
                break;
            case 'location_share':
                 notificationBody = `[分享了位置] ${fullMessage.content.name}`;
                 break;
            // 可以根据需要添加更多类型的预览
            default:
                notificationBody = '[发来了一条新消息]';
        }

        // 检查通知权限并发送
        if (Notification.permission === "granted") {
            // 需要获取发送者的信息来显示名字和头像
            const senderProfile = state.contacts.find(c => c.id === sender);
            if (senderProfile) {
                new Notification(senderProfile.name, {
                    body: notificationBody,
                    icon: senderProfile.avatar || 'https://via.placeholder.com/40' // 提供一个默认图标
                });
            }
        }
    }

// 7. 更新UI (仅当消息发送给当前打开的窗口时)
    if (fullMessage.sender !== 'system_instruction') { // 系统指令不更新UI
        
        // 【核心修复 V4】
        // 检查消息的目的地 (contact.id) 和 消息的模式 (effectiveMode)
        // 是否同时与用户当前所在的界面 (state.activeChatId / state.currentChatMode) 匹配。
        if (contact.id === state.activeChatId && effectiveMode === state.currentChatMode) { 
            
            if (effectiveMode === 'sms') {
                // 如果是短信模式，就只刷新短信UI
                await renderSmsChatMessages(contact); // 调用短信渲染函数
            } else {
                // 如果是聊天模式 (App内)，就只刷新聊天UI
                const messagesContainer = document.getElementById('chat-messages');
// --- ✨ 最终修复：使用更简单、更准确的“前一条”逻辑 ---
            let isFirstInSequence = true;
            if (!forceShowAvatar) {

                const newMsgIndex = contact.history.length - 1; // 这是新消息的索引

                if (newMsgIndex > 0) { // 检查这是否不是第一条消息
                    // 1. 只看它“紧挨着”的前一条消息
                    const immediatelyPrecedingMsg = contact.history[newMsgIndex - 1];

                    // 2. 检查前一条消息是不是“会打断连续”的类型
                    const isSequenceBreaker = 
                        immediatelyPrecedingMsg.type === 'system_notification' ||
                        immediatelyPrecedingMsg.sender === 'system_instruction' ||
                        immediatelyPrecedingMsg.type === 'heart_voice' ||
                        immediatelyPrecedingMsg.type === 'recall_ai' ||
                        immediatelyPrecedingMsg.isRecalled === true; // <-- 你的撤回也算

                    // 3. 只有当“前一条”不是打断者时，才去判断发送者是否相同
                    if (!isSequenceBreaker) {
                        if (immediatelyPrecedingMsg.sender === fullMessage.sender) {
                            isFirstInSequence = false; // 发送者相同，隐藏头像
                        }
                    }
                    // 4. 如果前一条是打断者，isFirstInSequence 保持为 true，显示头像
                }
                // 5. 如果这是第一条消息 (newMsgIndex === 0)，isFirstInSequence 保持为 true，显示头像
            }
            // --- 修复结束 ---

                // 创建并添加消息元素
                const messageEl = createMessageElement(fullMessage, contact, isFirstInSequence);
                if (messageEl) {
                    // 移除占位符（如果有）
                    const placeholder = messagesContainer.querySelector('#chat-placeholder');
                    if (placeholder) placeholder.remove();

                    // 添加新消息到DOM
                    messagesContainer.appendChild(messageEl);

                    // 延迟滚动到底部，给图片等元素加载时间
                    // 使用 setTimeout 确保在浏览器完成渲染后再滚动
                    setTimeout(() => {
                       messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    }, 100); // 100毫秒延迟通常足够
                }
            }
        } else {
            // 如果窗口不匹配 (消息发送给了非当前聊天对象，或者模式不匹配)
            // 增加未读计数
            contact.unreadCount = (contact.unreadCount || 0) + 1;
        }
    }
    // ▼▼▼ 【新增代码开始】 ▼▼▼
    // 只有当是有效的文本/语音/图片交流时才更新火花 (系统消息不算)
    if (sender !== 'system' && sender !== 'system_instruction' && messageData.type !== 'system_notification') {
        await updateContactSpark(contact);
        // ▼▼▼▼▼▼▼▼▼▼ 检查这里！有没有这几行？ ▼▼▼▼▼▼▼▼▼▼
        // 如果是用户发的消息，必须调用检查函数！
        if (sender === 'user') {
            console.log("正在检查幸运字符进度..."); //加个 log 验证这里是否执行
            await checkLuckyCharProgress(contact);
        }
    }
    // ▲▲▲ 【新增代码结束】 ▲▲▲

    // 8. 保存联系人数据到 IndexedDB
    await kokoMemory.put('contacts', contact);

    // 9. 刷新对应的列表视图 (主聊天列表 或 短信列表)
    if (fullMessage.sender !== 'system_instruction') {
        // 判断当前用户主要停留在哪个界面来决定刷新哪个列表
        const smsScreenVisible = document.getElementById('sms-screen').style.display === 'flex';
        // 如果当前是短信模式，或者短信主列表是可见的，就刷新短信列表
        if (state.currentChatMode === 'sms' || smsScreenVisible) {
           await renderSmsConversations(); // 刷新短信会话列表
        } else {
            // 否则刷新主聊天列表
            await renderContacts();
        }
    }

    // 10. 处理锁屏状态下的通知更新 (逻辑不变)
    const lockScreenEl = document.getElementById('lock-screen');
    if (lockScreenEl.style.display === 'flex' && !lockScreenEl.classList.contains('hidden')) {
        // 如果锁屏是显示的且未隐藏
        if (sender !== 'user' && sender !== 'system_instruction') {
            // 并且消息不是用户自己发的或系统指令
            console.log("锁屏状态下收到新消息，正在更新组件...");
            await updateLockScreenWidgets(); // 更新锁屏上的未读消息等组件
        }
    }

    // 11. 返回创建的消息对象，方便其他函数使用
    return fullMessage;
}

async function sendMessage() {
    const messageInput = document.getElementById('message-input');
    const content = messageInput.value.trim();
    if ((!content && !activeReplyTarget) || !state.activeChatId) return;

    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    // 1. 先准备好基础消息数据
    let messageType = 'text';
    const trimmedContent = content.trim();
    if (trimmedContent.startsWith('<') && trimmedContent.endsWith('>')) {
        messageType = 'html';
    }
    const messageData = { type: messageType, content: content };

    // 2. 如果是引用回复，就给消息加上引用信息
    if (activeReplyTarget) {
        const currentChat = state.contacts.find(c => c.id === state.activeChatId);
        let senderName;

        if (activeReplyTarget.sender === 'user') {
            senderName = state.myProfile.name;
        } else if (currentChat && currentChat.isGroup) {
            const senderContact = state.contacts.find(c => c.id === activeReplyTarget.sender);
            senderName = senderContact ? senderContact.name : '未知成员';
        } else {
            senderName = currentChat ? currentChat.name : '未知成员';
        }

        messageData.quote = {
            messageId: activeReplyTarget.id,
            senderName: senderName,
            content: activeReplyTarget.content
        };
    }

    // 3. 无论如何，最后统一发送一次消息
    // 因为 messageData 已经在上面准备好了所有需要的信息
    await createAndAddMessage(messageData, 'user', contact, false, 'chat');

    // 4. 发送完毕后，统一做清理工作
    messageInput.value = '';
    messageInput.style.height = '38px'; // 恢复到初始的 min-height

    cancelReply(); // 发送后清除引用状态
}

        const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));
async function handleLongPressDelete(contactId) {
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact || !contact.history || contact.history.length === 0) {
        return; 
    }

    const lastMessage = contact.history[contact.history.length - 1];
    if (!lastMessage) return;

    let confirmed = false;
    let finalHistorySliceIndex = -1;

    if (lastMessage.sender !== 'user') {
        // --- 场景 A: 最后一条消息是AI发的 ---
        // 目标：删除AI的最后一次回复，回退到用户说的最后一句话
        let lastUserMessageIndex = -1;
        for (let i = contact.history.length - 1; i >= 0; i--) {
            if (contact.history[i].sender === 'user') {
                lastUserMessageIndex = i;
                break;
            }
        }

        if (lastUserMessageIndex === -1) {
            alert("聊天记录中没有你的消息，无法回溯。");
            return;
        }

        confirmed = await showCustomConfirm(
            '回溯AI回复 (急救)',
            `AI的最后一次回复似乎有问题。确定要删除它，并回到你说的最后一句话吗？`,
            true
        );
        if (confirmed) {
            finalHistorySliceIndex = lastUserMessageIndex + 1;
        }

    } else {
        // --- 场景 B: 最后一条消息是用户发的 ---
        // 目标：删除用户最后连续发送的消息，回退到AI说的最后一句话
        let lastAiMessageIndex = -1;
        for (let i = contact.history.length - 1; i >= 0; i--) {
            if (contact.history[i].sender !== 'user') {
                lastAiMessageIndex = i;
                break;
            }
        }
        
        // 如果AI从未回复过，sliceIndex会是0，这将清空所有（都是用户发的）消息
        const sliceIndex = lastAiMessageIndex + 1;

        confirmed = await showCustomConfirm(
            '回溯我的回复 (急救)',
            `你发的最后几条消息似乎有问题。确定要删除它们，并回到AI说的最后一句话吗？`,
            true
        );
        if (confirmed) {
            finalHistorySliceIndex = sliceIndex;
        }
    }

    // 如果用户确认了操作，并且我们计算出了正确的分割点
    if (confirmed && finalHistorySliceIndex !== -1) {
        contact.history = contact.history.slice(0, finalHistorySliceIndex);
        await kokoMemory.put('contacts', contact);
        await renderContacts(); // 刷新联系人列表
        alert(`操作成功！聊天记录已回溯。`);
    }
}
// 函数1：切换置顶状态 (修正版)
async function togglePinContact(contactId) {
    const contact = await kokoMemory.get('contacts', contactId);
    if (contact) {
        contact.isPinned = !contact.isPinned; // 切换置顶状态
        await kokoMemory.put('contacts', contact); // 保存到数据库

        // ▼▼▼ 核心修复：在这里手动更新 state ▼▼▼
        const contactInState = state.contacts.find(c => c.id === contactId);
        if (contactInState) {
            contactInState.isPinned = contact.isPinned;
        }
        // ▲▲▲ 修复结束 ▲▲▲

        await renderContacts(); // 现在用更新后的 state 重新渲染列表
    }
}

// 函数2：显示菜单 (核心)
async function showContactItemMenu(contactId, buttonElement) {
    const menu = document.getElementById('contact-item-menu');
    const contact = await kokoMemory.get('contacts', contactId);
    if (!contact) return;

    const pinMenuItem = document.getElementById('menu-item-pin');
    pinMenuItem.querySelector('span').textContent = contact.isPinned ? '取消置顶' : '置顶聊天';

    menu.dataset.contactId = contactId;
    const rect = buttonElement.getBoundingClientRect();
    menu.style.display = 'block';
    menu.style.top = `${rect.bottom + 5}px`;
    menu.style.left = `${rect.right - menu.offsetWidth}px`;
    
    // 注意：这里已经移除了旧的关闭逻辑
}
// ▼▼▼ 使用这个【新版本】替换掉你原来的 requestAiReply 函数 ▼▼▼
async function requestAiReply(systemInstruction = null, targetContactId = null) {
    const contactId = targetContactId || state.activeChatId; // 优先使用指定的目标
    if (!contactId) return;

    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) return;

    if (systemInstruction) {
         await createAndAddMessage({ type: 'text', content: systemInstruction }, 'system_instruction', contact); // 把contact传进去
    }

    if (contact.history.filter(m => m.sender !== 'system_instruction').length === 0) {
        if (!systemInstruction) alert('请先发送消息再请求回复。');
        return;
    }

    // ▼▼▼ 核心改动：判断是群聊还是私聊 ▼▼▼
    if (contact.isGroup) {
        // 如果是群聊，调用群聊AI处理函数
        await triggerGroupChatAiReply(contact);
    } else {
        // 如果是私聊，调用原来的单聊AI处理函数
        await triggerAiReply(contact);
    }
    // ▲▲▲ 改动结束 ▲▲▲
}
        async function triggerAiReply(contact) {
            if (contact.needsNarrativeModeExitPrompt === true) { 
                const exitInstruction = `[SYSTEM COMMAND: CRITICAL! IMMEDIATE FORMAT CHANGE REQUIRED!] You have just exited Narrative Mode. Your response format MUST IMMEDIATELY and STRICTLY return to the standard multi-line chat format. - DO NOT write a single long paragraph. - DO NOT include any descriptions of actions, expressions, or thoughts (e.g., *...* or {...}). - You MUST use multi-line responses and commands like [sticker:name] where appropriate. This is a strict and immediate format change. Acknowledge and comply.`;
                await createAndAddMessage({ type: 'text', content: exitInstruction }, 'system_instruction'); 
                delete contact.needsNarrativeModeExitPrompt;
            } 
          
            const chatStatusEl = document.getElementById('chat-contact-status'); 
            // const originalStatus = chatStatusEl.textContent; // 👈 删掉这行
            
            state.aiTypingStatus[contact.id] = true; // 👈 ✨ (新) 告诉“记录本”：我开工了！
            chatStatusEl.textContent = '对方正在输入...';

            if (!contact.apiCallCounter) {
                contact.apiCallCounter = 0;
            }
            contact.apiCallCounter++;
            
            try {
                const currentUserStatus = state.myProfile.status;
                if (contact) {
                    if (contact.lastKnownUserStatus && contact.lastKnownUserStatus !== currentUserStatus) {
                        const statusChangeInstruction = `[SYSTEM: 你的对话伙伴刚刚将状态从“${contact.lastKnownUserStatus}”改为了“${currentUserStatus}”。这是一个很好的机会，你可以自然地关心一下，比如问：“我看到你的状态变了，还好吗？”。这次之后就不用再提了。]`;
                        await createAndAddMessage({ type: 'text', content: statusChangeInstruction }, 'system_instruction');
                    }
                    contact.lastKnownUserStatus = currentUserStatus;
                }
            } catch (e) {
                console.error("更新用户状态记忆时出错:", e);
            }

// 1. 查找条件增加：必须是【未被提醒过】( !m.hasRemindedAI ) 的红包
            const lastUnopenedMessage = contact.history.slice().reverse().find(m =>
                m.sender === 'user' && (
                    (m.type === 'red_packet' && !m.content.opened) ||
                    (m.type === 'transfer' && !m.content.completed)
                ) && !m.hasRemindedAI //  核心修改：只找没被提醒过的
            );

            if (lastUnopenedMessage) {
                let systemInstruction = '';
                
                // 生成提示词 (这部分保持原样)
                if (lastUnopenedMessage.type === 'red_packet') {
                    systemInstruction = `[SYSTEM: 用户发给你一个红包（祝福语：“${lastUnopenedMessage.content.blessing}”）。如果你想收下，请在回复中自然地表达感谢或开心（如“谢谢”、“收下了”）。如果你不想收，可以忽略它或礼貌拒绝。]`;
                } else if (lastUnopenedMessage.type === 'transfer') {
                    systemInstruction = `[SYSTEM: 用户给你转账了 ${lastUnopenedMessage.content.amount}元。如果你决定收下，请在回复中包含“收下”、“谢谢”等词。不想收可以忽略。]`;
                }
                
                // 发送系统提示
                await createAndAddMessage({ type: 'text', content: systemInstruction }, 'system_instruction');

                // ▼▼▼ ✨ 核心修改：标记为“已提醒”，并立即保存 ▼▼▼
                // 这样下一轮对话时，上面的 find 就会忽略这条消息，不再唠叨 AI 了
                lastUnopenedMessage.hasRemindedAI = true;
                await kokoMemory.put('contacts', contact);
                // ▲▲▲ 修改结束 ▲▲▲
            }
            
            try {
                if (contact.pet && contact.isChatPetVisible && Math.random() < 0.25) {
                    let petActionSystemMessage = null;

                    if (contact.pet.hunger < 40) {
                        petActionSystemMessage = `[SYSTEM: 悬浮在屏幕上的史莱姆看起来饿了，请你关心一下它。]`;
                    } else if (contact.pet.happiness < 40) {
                        petActionSystemMessage = `[SYSTEM: 悬浮在屏幕上的史莱姆看起来不开心，请你提及一下这件事。]`;
                    }
                    
                    if (petActionSystemMessage) {
                        await createAndAddMessage({ type: 'text', content: petActionSystemMessage }, 'system_instruction');
                    }
                }

                const forceDiary = (contact.apiCallCounter % 3 === 0);
                const rawResponse = await generateAiResponse(contact, contact.history, null, forceDiary, 'chat');
                
                await processAndDisplayAiResponse(rawResponse, contact, contact, 'chat');

            } finally {
                state.aiTypingStatus[contact.id] = false; // 👈 ✨ (新) 告诉“记录本”：我完工了！
                
                // 关键：只在用户还停留在当前聊天时才把状态改回“在线”
                if (state.activeChatId === contact.id) {
                    chatStatusEl.textContent = '在线'; 
                }
                
                contact.history = contact.history.filter(m => m.sender !== 'system_instruction');
                await kokoMemory.put('contacts', contact);
            }
        }
/**
 * (V9 - 真正完整的记忆互通版) 触发私聊AI的自由聊天
 * (由Koko用户指导，修复了V8版本中记忆流不完整的问题)
 * @param {object} contact - 当前的私聊联系人对象
 */
async function triggerPrivateFreeChat(contact) {
    if (!contact || contact.isGroup) return; // 确保这绝对是私聊
    console.log(`私聊：用户未发言，正在启动独立的自由聊天函数 (V9) for ${contact.name}...`);
    
    const chatStatusEl = document.getElementById('chat-contact-status');
    state.aiTypingStatus[contact.id] = true;
    if(chatStatusEl && state.activeChatId === contact.id) {
        chatStatusEl.textContent = '对方正在输入...'; // 私聊的提示
    }

    try {
        // --- 1. 构建所有上下文信息 (私聊版) ---
        
        const myProfile = state.myProfile;
        const isNarrativeMode = contact.isNarrativeMode; 
        
        // 1c. 构建世界书
        let worldBookContextString = '(本次对话无世界书)';
        const worldBookIds = contact.worldBooks || [];
        if (worldBookIds.length > 0) {
            worldBookContextString = (await Promise.all(
                worldBookIds.map(id => kokoMemory.get('worldBooks', id))
            )).filter(Boolean).map(book => 
                `--- (世界书: ${book.name}) ---\n${book.content}`
            ).join('\n\n');
            if(worldBookContextString) worldBookContextString = `[相关世界书背景知识]\n${worldBookContextString}\n---`;
        }
        
        // 1e. 【核心V9：构建真正完整的统一时序记忆流】
        const memoryLimit = state.apiSettings.longTermMemoryLength || 40;
        let unifiedMemoryStream = [];
        const now = Date.now();
        const memoryWindow = 24 * 60 * 60 * 1000; // 1天
        
        // 步骤1: 收集【私聊】历史 (这是我上次忘复制全的)
        if (contact && contact.history) {
            const recentChatHistory = contact.history.filter(msg => (now - msg.timestamp < memoryWindow));
            recentChatHistory.forEach(msg => {
                if (msg.sender === 'system_instruction') return;
                const authorProfile = (msg.sender === 'user' || msg.sender === 'myProfile') ? myProfile : contact;
                if (!authorProfile) return; 
                
                let content = '';
                let memoryType = `私聊[${contact.name}]`;
    
                switch (msg.type) {
                    case 'text':
                    case 'html':
                        content = msg.content.replace(/<[^>]+>/g, '');
                        if (msg.quote) {
                            const quoteText = `[回复“${msg.quote.senderName}”说的“${msg.quote.content.substring(0, 20)}...”] `;
                            content = quoteText + content;
                        }
                        break;
                    case 'uploaded_image':
                    case 'image':
                        content = msg.isEmoticon ? `[sticker:${msg.emoticonName}]` : `(发送了一张图片或表情)`;
                        break;
                    case 'picture_description':
                        content = `(发送了一张图片，描述是：“${msg.content.description}”)`;
                        break;
                    case 'voice':
                        content = `(发送了一段语音，内容是：“${msg.content.text}”)`;
                        break;
                    case 'red_packet':
                        const blessing = msg.content.blessing || "恭喜发财";
                        content = `(发了一个红包：“${blessing}”)`;
                        break;
                    case 'transfer':
                        content = `(发了一个转账 ${msg.content.amount}元)`;
                        break;
                    case 'location_share':
                        content = `(分享了位置: ${msg.content.name})`;
                        break;
                    case 'game_wheel':
                        const wheel = msg.content;
                        const userName = (msg.sender === 'user' || msg.sender === 'myProfile') ? myProfile.name : authorProfile.name;
                        const optionsText = wheel.options.map(opt => opt.text).join('，');
                        if (!wheel.results.user) { content = `[SYSTEM: ${userName} 发起了一个转盘游戏“${wheel.name}”。选项：【${optionsText}】。]`; } 
                        else if (wheel.results.user && !wheel.results.contact) { content = `[SYSTEM: 在游戏“${wheel.name}”中，${userName} 的结果是“${wheel.results.user}”。]`; } 
                        else { content = `[SYSTEM: 游戏“${wheel.name}”已结束。]`; }
                        break;
                    case 'recall_ai':
                        content = `(撤回了一条消息，内容是：“${msg.content}”)`;
                        break;
                    case 'video_call_text':
                        memoryType = '视频通话中';
                        content = msg.content;
                        break;
                    case 'system_notification':
                        content = `(系统消息：${msg.content})`;
                        memoryType = '系统';
                        break;
                    case 'music_share':
                        content = `(分享了音乐: 《${msg.content.title}》 - ${msg.content.artist})`;
                        break;
                    case 'post_share':
                        const post = state.posts.find(p => p.id === msg.content.postId);
                        content = post ? `(分享了一个帖子, 内容是: "${post.content.substring(0, 30)}...")` : `(分享了一个已删除的帖子)`;
                        break;
                    case 'product_share':
                        content = `(分享了商品: "${msg.content.productDetails.name}")`;
                        break;
                    case 'chat_history_share':
                        content = `(转发了一份 ${msg.content.sourceChatName} 的聊天记录)`;
                        break;
                }
    
                if (content) {
                    unifiedMemoryStream.push({
                        timestamp: msg.timestamp,
                        type: memoryType,
                        author: authorProfile.name,
                        content: content
                    });
                }
            });
        }
        
        // 步骤2: 收集【论坛】历史 (这是我 V8 忘加的)
        const recentPosts = state.posts.filter(p => now - p.timestamp < memoryWindow);
        recentPosts.forEach(post => {
            const isMyPost = post.author.id === myProfile.id;
            const isContactPost = contact && (post.author.id === contact.id);
            const isInteracted = contact && post.comments.some(c => c.author.id === myProfile.id || c.author.id === contact.id);

            if (isMyPost || isContactPost || isInteracted) {
                unifiedMemoryStream.push({
                    timestamp: post.timestamp,
                    type: '论坛',
                    author: post.author.name,
                    content: `发布了动态: "${post.content}"`
                });

                post.comments.forEach(comment => {
                    let formattedContent = (comment.replyTo ? `回复“${comment.replyTo}”` : '') + `: “${comment.content}”`;
                    unifiedMemoryStream.push({
                        timestamp: comment.timestamp,
                        type: '论坛评论',
                        author: comment.author.name,
                        content: formattedContent
                    });
                });
            }
        });
        
        // 步骤3: 收集【群聊】历史 (这是我 V8 忘加的)
        if (contact && !contact.isGroup) {
            const allGroups = state.contacts.filter(c => c.isGroup);
            const sharedMemoryGroups = allGroups.filter(g => 
                g.memoryShared && g.members.includes(contact.id)
            );

            for (const group of sharedMemoryGroups) {
                group.history.slice(-20).forEach(msg => {
                    if (msg.type !== 'text') return;
                    // (使用一个临时的查找器)
                    const getProfileInGroup = (id) => {
                        if (id === 'myProfile' || id === 'user') return myProfile;
                        let profile = state.contacts.find(c => c.id === id);
                        if (profile) return profile;
                        if (group.npcMembers) {
                            profile = group.npcMembers.find(npc => npc.id === id);
                            if (profile) return profile;
                        }
                        return null; 
                    };
                    const authorProfile = getProfileInGroup(msg.sender);
                    if (!authorProfile) return;
                    
                    unifiedMemoryStream.push({
                        timestamp: msg.timestamp,
                        type: `群聊[${group.name}]`,
                        author: authorProfile.name,
                        content: msg.content
                    });
                });
            }
        }
        
        // 步骤4: 收集【短信】历史 (这是我 V8 忘加的)
        if (contact && contact.smsHistory) {
            const recentSmsHistory = contact.smsHistory.slice(-30);
            recentSmsHistory.forEach(msg => {
                if (msg.type === 'text') {
                    const authorName = msg.sender === 'user' ? myProfile.name : contact.name;
                    unifiedMemoryStream.push({
                        timestamp: msg.timestamp,
                        type: '短信',
                        author: authorName,
                        content: msg.content
                    });
                }
            });
        }
        
        // 1f. 排序并格式化
        unifiedMemoryStream.sort((a, b) => a.timestamp - b.timestamp);
        
        const finalMemoryString = unifiedMemoryStream.slice(-memoryLimit).map(mem => {
            const authorTag = (mem.author === myProfile.name) ? "(你)" : "";
            const timeTag = (contact && contact.isTimeAware === true) ? formatHybridTimeForAI(mem.timestamp) : '';
            return `${timeTag ? timeTag + ' ' : ''}[${mem.type}] ${mem.author}${authorTag}: ${mem.content}`;
        }).join('\n') || "(还没有任何记忆)";

        // 1g. 构建角色档案
        const userPersona = contact.userPersona || myProfile.signature || '(用户未设置特定人设)';
        let characterDossiersPrompt = `
- 你的角色: ${contact.name}
  - 你的核心人设: ${contact.persona.replace(/\n/g, ' ')}
- 你的对话伙伴: ${myProfile.name}
  - 伙伴的人设: ${userPersona.replace(/\n/g, ' ')}
`;
        
        // 1h. 获取思维预设
        const preset = state.thoughtPresets.find(p => p.id === contact?.thoughtPreset);
        const thoughtPresetContent = preset ? preset.prompt : '(无特殊思维准则)';

        // --- 2. 【核心拆分：V8】 ---
        
        // (Part A: 这是 systemInstruction，只包含背景)
        let baseSystemPrompt = isNarrativeMode ? NARRATIVE_BASE_PROMPT : NORMAL_BASE_PROMPT;
        
        baseSystemPrompt = baseSystemPrompt.replace('{{thought_preset_content}}', thoughtPresetContent);
        baseSystemPrompt = baseSystemPrompt.replace('{{memory_stream}}', finalMemoryString);
        
// (V8 版的指令修复)
        if (!isNarrativeMode) {
            // ▼▼▼ 核心修改：AI 只能看到允许它使用的表情 ▼▼▼
            // 1. 获取该角色允许的分组 (如果是私聊，contact 对象一定存在)
            const allowedGroups = contact.allowedEmoticonGroups || ['default'];
            
            // 2. 筛选出符合分组的表情
            const aiAllowedEmoticons = state.emoticons.filter(e => allowedGroups.includes(e.groupId));
            
            // 3. 生成列表字符串
            const emoListStr = aiAllowedEmoticons.map(e => `'${e.name}'`).join('， ') || '（无可用表情）';
            
            // 4. 替换 Prompt
            baseSystemPrompt = baseSystemPrompt.replace('{{emoticon_list}}', emoListStr);
            // ▲▲▲ 修改结束 ▲▲▲

            const musicListString = state.musicLibrary.map(song => `'${song.title} - ${song.artist}'`).join('\\n- ');
            baseSystemPrompt = baseSystemPrompt.replace('{{music_library_list}}', musicListString ? `- ${musicListString}` : '（曲库为空）');
        }

        const finalSystemPrompt = baseSystemPrompt + `
[额外背景资料：角色档案]
---
${characterDossiersPrompt}
---

[额外背景资料：世界书]
---
${worldBookContextString}
---
`;

        // (Part B: 这是 contents，只包含任务)
        // (使用 V8 版修正后的叙事任务)
        let freeChatUserTaskPrompt = '';

        if (isNarrativeMode) {
            // --- (V8版 叙事任务) ---
            freeChatUserTaskPrompt = `
[！！！核心任务！！！]
用户（${myProfile.name}）正在“观察”你，TA没有发言。
你的任务是：
1.  **分析上下文**：阅读你(System)的背景资料中提供的“记忆流”，看看你最后在做什么或在想什么。
2.  **主动叙事**: 你必须【主动】生成一段【新的】叙事内容。
3.  **内容要求**: 这段内容可以是：
    * 你对上一个话题的【后续思考】({ ... })
    * 你决定去做的【一个新动作】(* ... *)
    * 你【主动开口】说的一句【新话】("...")
    * 或者是以上三者的自由组合。
4.  **核心目标**: 你的目标是“打破沉默”，让故事自然地延续下去。
5.  **严格遵守格式**: 你的所有输出【必须】使用星号 (*...*)、大括号 ({...}) 和引号 ("...") 来组织。
6.  **包含日记**: 你【必须】像往常一样，在最后包含 [heart_voice] 和 [diary] 标签。

[输出格式]
*你(AI)的动作或环境描写*
{你(AI)的内心独白}
"你(AI)说的话"
[heart_voice]{...}[/heart_voice]
[diary]...[/diary]
`;
        } else {
            // --- (V8版 普通聊天任务) ---
            freeChatUserTaskPrompt = `
[！！！核心任务！！！]
用户（${myProfile.name}）正在“观察”你，TA没有发言。
你的任务是：
1.  **分析上下文**：阅读你(System)的背景资料中提供的“记忆流”，看看你们最后聊了什么。
2.  **主动发起话题**: 你必须【主动】给用户发送 1-3 条【新的】消息，可以延续上一个话题，也可以开启一个你感兴趣的新话题。
3.  **禁止询问**: 【不要】说“你怎么不说话了”之类的话，就当你自己突然想到了什么，自然地发消息即可。
4.  **严格遵守格式**: 你的回复必须严格遵守你(System)的背景资料中的 [回复规则] 和 [特殊指令格式]。
5.  **包含日记**: 你【必须】像往常一样，在最后包含 [heart_voice] 和 [diary] 标签。

[输出格式]
(你(AI)想说的第一句话)
(你(AI)想说的第二句话)
(你(AI)可以使用的指令，例如 [sticker:开心])
[heart_voice]{...}[/heart_voice]
[diary]...[/diary]
`;
        }
        
        // --- 3. 【核心】构建AI调用参数 ---
        const requestMessages = [
            { role: 'system', content: finalSystemPrompt },
            { role: 'user', content: freeChatUserTaskPrompt } 
        ];

        // --- 4. 【核心】调用 generateAiResponse 的“后门” ---
        const rawResponse = await generateAiResponse(
            null,                   
            [],                     
            null,                   
            false,                  
            'chat',                 
            requestMessages         
        );
        
        // --- 5. (私聊版) 解析并显示AI的回复 ---
        await processAndDisplayAiResponse(rawResponse, contact, contact, 'chat');

    } catch (e) {
        console.error("私聊自由聊天执行失败:", e);
        await createAndAddMessage({
            type: 'system_notification',
            sender: 'system',
            content: `AI自由聊天失败: ${e.message}`
        }, 'system', contact, false, 'chat');
    } finally {
        // --- 6. (不变) 结束“正在输入”状态 ---
        state.aiTypingStatus[contact.id] = false; 
        if (chatStatusEl && state.activeChatId === contact.id) {
            chatStatusEl.textContent = '在线';
        }
    }
}
/**
 * (V7 - 完整记忆 + API修复版) 触发群聊AI成员间的自由聊天
 * (由Koko用户指导，采用"刷新论坛"模式，不依赖 requestAiReply)
 * (此版本修复了 "contents is required" 错误，并【添加了私聊记忆互通】)
 * @param {object} group - 当前的群聊联系人对象
 */
async function triggerGroupFreeChat(group) {
    if (!group || !group.isGroup) return;

    console.log("群聊：用户未发言，正在启动独立的自由聊天函数(V7 - 记忆互通版)...");
    
    const chatStatusEl = document.getElementById('chat-contact-status');
    state.aiTypingStatus[group.id] = true;
    if(chatStatusEl && state.activeChatId === group.id) {
        chatStatusEl.textContent = '群成员正在热烈讨论中...';
    }

    try {
        // --- 1. 构建所有上下文信息 ---
        
        const myProfile = state.myProfile;
        
        // 1a. 身份查找器
        const getProfileInGroup = (id) => {
            if (id === 'myProfile' || id === 'user') return myProfile;
            let profile = state.contacts.find(c => c.id === id);
            if (profile) return profile;
            if (group.npcMembers) {
                profile = group.npcMembers.find(npc => npc.id === id);
                if (profile) return profile;
            }
            return null; 
        };

        // 1b. 找出所有“未禁言”的AI成员
        const unmutedAiMembers = group.members.filter(memberId =>
            memberId !== 'myProfile' && !(group.mutedMembers || []).includes(memberId)
        );
        if (unmutedAiMembers.length === 0) {
             throw new Error("群里没有可以发言的AI成员。");
        }

        // 1c. 构建世界书
        let worldBookContextString = '(本次对话无世界书)';
        const worldBookIds = group.worldBooks || [];
        if (worldBookIds.length > 0) {
            worldBookContextString = worldBookIds.map(bookId => {
                const book = state.worldBooks.find(b => b.id === bookId);
                return book ? `\n[世界书条目: ${book.name}]\n${book.content}` : '';
            }).join('\n\n');
        }
        
        // 1d. 构建所有AI成员的档案
        const allMemberProfiles = unmutedAiMembers.map(id => getProfileInGroup(id)).filter(Boolean);
        const aiMemberNames = allMemberProfiles.map(profile => profile.name);
        const userPersonaInGroup = group.userPersona || myProfile.signature || '(用户未设置特定人设)';
        
        // 1e. 【核心V7：构建完整的统一时序记忆流】
        const memoryLimit = state.apiSettings.longTermMemoryLength || 40;
        let unifiedMemoryStream = [];
        
        // 步骤1: 收集【群聊】历史
        group.history.forEach(msg => {
            if (msg.sender === 'system_instruction') return;
            const authorProfile = getProfileInGroup(msg.sender); 
            if (!authorProfile) return; 
            
            let content = '';
            let memoryType = `群聊[${group.name}]`;

            // (使用你之前版本里的完整 switch 逻辑)
            switch (msg.type) {
                case 'text':
                case 'html':
                    content = msg.content.replace(/<[^>]+>/g, '');
                    if (msg.quote) {
                        const quoteText = `[回复“${msg.quote.senderName}”说的“${msg.quote.content.substring(0, 20)}...”] `;
                        content = quoteText + content;
                    }
                    break;
                case 'uploaded_image':
                case 'image':
                    content = msg.isEmoticon ? `[sticker:${msg.emoticonName}]` : `(发送了一张图片或表情)`;
                    break;
                case 'picture_description':
                    content = `(发送了一张图片，描述是：“${msg.content.description}”)`;
                    break;
                case 'voice':
                    content = `(发送了一段语音，内容是：“${msg.content.text}”)`;
                    break;
                case 'red_packet':
                    const blessing = msg.content.blessing || "恭喜发财";
                    content = msg.content.count ? `(发了一个群红包：“${blessing}”)` : `(发了一个私聊红包：“${blessing}”)`;
                    break;
                case 'transfer':
                    const amount = msg.content.amount;
                    if (msg.content.recipientId) {
                        const recipient = getProfileInGroup(msg.content.recipientId);
                        const recipientName = recipient ? recipient.name : '一位成员';
                        content = `(向 ${recipientName} 转账 ${amount}元)`;
                    } else {
                        content = `(发了一个转账 ${amount}元)`;
                    }
                    break;
                case 'location_share':
                    content = `(分享了位置: ${msg.content.name})`;
                    break;
                case 'game_wheel':
                    const wheel = msg.content;
                    const userName = (msg.sender === 'user' || msg.sender === 'myProfile') ? myProfile.name : authorProfile.name;
                    const optionsText = wheel.options.map(opt => opt.text).join('，');
                    if (!wheel.results.user) { content = `[SYSTEM: ${userName} 发起了一个转盘游戏“${wheel.name}”。选项：【${optionsText}】。]`; } 
                    else if (wheel.results.user && !wheel.results.contact) { content = `[SYSTEM: 在游戏“${wheel.name}”中，${userName} 的结果是“${wheel.results.user}”。]`; } 
                    else { content = `[SYSTEM: 游戏“${wheel.name}”已结束。]`; }
                    break;
                case 'recall_ai':
                    content = `(撤回了一条消息，内容是：“${msg.content}”)`;
                    break;
                case 'video_call_text':
                    memoryType = '视频通话中';
                    content = msg.content;
                    break;
                case 'system_notification':
                    content = `(系统消息：${msg.content})`;
                    memoryType = '系统';
                    break;
                case 'music_share':
                    content = `(分享了音乐: 《${msg.content.title}》 - ${msg.content.artist})`;
                    break;
                case 'post_share':
                    const post = state.posts.find(p => p.id === msg.content.postId);
                    content = post ? `(分享了一个帖子, 内容是: "${post.content.substring(0, 30)}...")` : `(分享了一个已删除的帖子)`;
                    break;
                case 'product_share':
                    content = `(分享了商品: "${msg.content.productDetails.name}")`;
                    break;
                case 'chat_history_share':
                    content = `(转发了一份 ${msg.content.sourceChatName} 的聊天记录)`;
                    break;
            }

            if (content) {
                unifiedMemoryStream.push({
                    timestamp: msg.timestamp,
                    type: memoryType,
                    author: authorProfile.name,
                    content: content
                });
            }
        });
        
        // 步骤2: 【条件性】收集AI成员与您的【私聊】历史 (这就是你说的“互通”！)
        if (group.memoryShared) {
            unmutedAiMembers.forEach(memberId => {
                // 必须从 state.contacts (主联系人列表) 里找私聊对象
                const contact = state.contacts.find(c => c.id === memberId);
                if (contact && contact.history && contact.history.length > 0) {
                    contact.history.slice(-30).forEach(msg => { // 抓取最近30条私聊
                        // (只抓取最简单的文本消息用于互通，防止刷屏)
                        if (msg.type === 'text' && msg.sender !== 'system_instruction') {
                            const authorProfile = (msg.sender === 'user') ? myProfile : contact;
                            unifiedMemoryStream.push({
                                timestamp: msg.timestamp,
                                type: `私聊[${contact.name}]`, // 明确标记为“私聊”
                                author: authorProfile.name,
                                content: msg.content
                            });
                        }
                    });
                }
            });
        }

        // 步骤3: 排序并格式化
        unifiedMemoryStream.sort((a, b) => a.timestamp - b.timestamp);
        
        const finalMemoryString = unifiedMemoryStream.slice(-memoryLimit).map(mem => {
            const authorTag = (mem.author === myProfile.name) ? "(你)" : "";
            const timeTag = (group && group.isTimeAware === true) ? formatHybridTimeForAI(mem.timestamp) : '';
            return `${timeTag ? timeTag + ' ' : ''}[${mem.type}] ${mem.author}${authorTag}: ${mem.content}`;
        }).join('\n') || "(还没有任何记忆)";

        // 1g. 构建角色档案（包含私聊参考，因为V7现在有私聊记忆了）
        let characterDossiersPrompt = allMemberProfiles.map(profile => {
                // (从 triggerGroupChatAiReply 复制过来的逻辑)
                let recentChatHistory = '(最近没有与用户的私聊记录)';
                if (group.memoryShared) {
                    const contactProfile = state.contacts.find(c => c.id === profile.id);
                    if (contactProfile && contactProfile.history && contactProfile.history.length > 0) {
                        recentChatHistory = contactProfile.history
                            .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction')
                            .slice(-30)
                            .map(msg => `    ${msg.sender === 'user' ? myProfile.name : profile.name}: ${msg.content}`)
                            .join('\n');
                    }
                }
                
                return `
- 角色名: ${profile.name}
  - 核心人设: ${profile.persona.replace(/\n/g, ' ')}
  ${group.memoryShared ? `
  - [与用户“${myProfile.name}”的近期私聊参考 (重要)]
    \`\`\`
${recentChatHistory}
    \`\`\`
  ` : ''}
`;
            }).join('');

        // --- 2. 【核心拆分：V6】 (这部分保持不变) ---

        // (Part A: 这是 systemInstruction，只包含背景)
        const freeChatSystemPrompt = `
[SYSTEM] 你是一个顶级的群聊模拟器和剧本导演。

[群聊背景与成员列表]
- 群聊名称: ${group.name}
- 用户(观察者): ${myProfile.name} (人设: ${userPersonaInGroup})

[你可控制的角色]
你【只能】扮演和控制以下列表中的角色：【${aiMemberNames.join('、 ')}】。

[你禁止控制的角色]
你【绝对禁止】扮演用户 “${myProfile.name}”。

[背景资料：世界书]
---
${worldBookContextString}
---

[背景资料：角色档案]
${group.memoryShared ? '下方是本次群聊所有AI角色的详细档案，包含他们与你的私聊参考。' : '下方是本次群聊所有AI角色的基础档案。'}
--- 角色档案区 ---
${characterDossiersPrompt}
--- 档案区结束 ---

[背景资料：统一时序记忆流]
这是群里和私聊中最近发生的对话，是你的上下文参考。
---
${finalMemoryString}
---

[特殊指令]
你可以使用 [sticker:表情名], [voice:内容], [picture:描述] 等指令。
[可用表情包列表]
{{emoticon_list}}
`;
        
        const finalSystemPrompt = freeChatSystemPrompt.replace('{{emoticon_list}}', state.emoticons.map(e => `'${e.name}'`).join('， ') || '（无）');

        // (Part B: 这是 contents，只包含任务)
        const freeChatUserTaskPrompt = `
[！！！核心任务！！！]
用户（${myProfile.name}）正在“观察”群聊，TA没有发言。
你的任务是：
1.  **分析上下文**：阅读你(System)的背景资料中提供的【统一时序记忆流】（它包含了群聊和私聊），看看大家最后聊了什么。
2.  **选择发言人**：从你“可控制的角色”列表中，选择 2 到 3 名角色。
3.  **生成对话**：让他们围绕“记忆流”中的最后一个话题【继续深入】，或者开启一个【符合人设、世界观、以及私聊记忆】的新话题。
4.  **禁止回复用户**：【绝对不要】和用户“${myProfile.name}”说话，这是AI之间的对话。

[输出格式]
你的输出必须是严格遵守以下格式的聊天记录脚本。
MESSAGE_START
SPEAKER: [角色名] (✨ 必须从你“可控制的角色”列表中选择)
CONTENT: [该角色说的【单条】消息内容，可以包含特殊指令]
MESSAGE_END
`;

        // --- 3. 【核心】构建AI调用参数 ---
        const requestMessages = [
            { role: 'system', content: finalSystemPrompt },
            { role: 'user', content: freeChatUserTaskPrompt } 
        ];

        // --- 4. 【核心】调用 generateAiResponse 的“后门” ---
        const rawResponse = await generateAiResponse(
            null,                   
            [],                     
            null,                   
            false,                  
            'chat',                 
            requestMessages         
        );
        
        // --- 5. (不变) 解析并显示AI的回复 ---
        const messageRegex = /MESSAGE_START\s*SPEAKER:\s*(.*?)\s*CONTENT:\s*([\s\S]*?)\s*MESSAGE_END/g;
        const messageMatches = Array.from(rawResponse.matchAll(messageRegex));

        if (messageMatches.length === 0) {
            throw new Error("AI未能生成有效的自由聊天内容。");
        }

        for (const match of messageMatches) {
            const speakerName = match[1].trim();
            let content = match[2].trim();
            
            const speakerProfile = allMemberProfiles.find(p => p.name === speakerName);
            
            if (speakerProfile && content) {
                await sleep(800 + Math.random() * 700);
                await processAndDisplayAiResponse(content, speakerProfile, group, 'chat');
            }
        }

    } catch (e) {
        console.error("群聊自由聊天执行失败:", e);
        await createAndAddMessage({
            type: 'system_notification',
            sender: 'system',
            content: `AI自由聊天失败: ${e.message}`
        }, 'system', group, false, 'chat');
    } finally {
        // --- 6. (不变) 结束“正在输入”状态 ---
        state.aiTypingStatus[group.id] = false; 
        if (chatStatusEl && state.activeChatId === group.id) {
            chatStatusEl.textContent = '在线';
        }
    }
}
async function triggerGroupChatAiReply(group) {
    const chatStatusEl = document.getElementById('chat-contact-status');
    // const originalStatus = chatStatusEl.textContent; // 👈 删掉这行
    
    state.aiTypingStatus[group.id] = true; // 👈 ✨ (新) 告诉“记录本”：我开工了！
    chatStatusEl.textContent = '群成员正在热烈讨论中...';

    try {
        // --- ✨ 修正点 #1：在这里创建一个“全能”的身份查找器 ---
        const myProfile = state.myProfile;
        const getProfileInGroup = (id) => {
            if (id === 'myProfile' || id === 'user') return myProfile;
            let profile = state.contacts.find(c => c.id === id);
            if (profile) return profile;
            if (group.npcMembers) {
                profile = group.npcMembers.find(npc => npc.id === id);
                if (profile) return profile;
            }
            return null; // 真的找不到了
        };
        // --- 修正结束 ---

        const unmutedAiMembers = group.members.filter(memberId =>
            memberId !== 'myProfile' && !(group.mutedMembers || []).includes(memberId)
        );

        if (unmutedAiMembers.length === 0) {
            chatStatusEl.textContent = originalStatus;
            return;
        }

        let worldBookContextString = '(本次对话无世界书)';
        const worldBookIds = group.worldBooks || [];
        if (worldBookIds.length > 0) {
            worldBookContextString = worldBookIds.map(bookId => {
                const book = state.worldBooks.find(b => b.id === bookId);
                return book ? `\n[世界书条目: ${book.name}]\n${book.content}` : '';
            }).join('\n\n');
        }

        // --- ✨ 修正点 #2：使用新的查找器来获取所有成员档案 ---
        const allMemberProfiles = unmutedAiMembers.map(id => getProfileInGroup(id)).filter(Boolean);

        // --- ✨ 修正点 #3：使用新的查找器来获取所有成员名字 ---
        const allMemberNames = group.members.map(id => {
            const profile = getProfileInGroup(id); //  使用新查找器
            return profile ? profile.name : '';
        }).filter(Boolean);

        const userPersonaInGroup = group.userPersona || myProfile.signature || '(用户未设置特定人设)';
        // ▼▼▼ ✨✨✨ 【KOKO 核心修复】✨✨✨ ▼▼▼
        // 1. 我们需要一个【只包含AI】的名字列表
        const aiMemberNames = allMemberProfiles.map(profile => profile.name);
        // ▲▲▲ ✨✨✨ 修复结束 ✨✨✨ ▲▲▲

        const memoryLimit = state.apiSettings.longTermMemoryLength || 40;
        let unifiedMemoryStream = [];

        // --- ✨ 修正点 #4：使用新的查找器来构建记忆流 ---
        group.history.forEach(msg => {
            if (msg.sender === 'system_instruction') return;
            const authorProfile = getProfileInGroup(msg.sender); //  使用新查找器
            if (!authorProfile) return; // 找不到发言人（幽灵消息），跳过

            let content = '';
            switch (msg.type) {
                case 'text':
                    content = msg.content;
                    break;
                case 'uploaded_image':
                case 'image':
                    content = `(发送了一张图片或表情)`;
                    break;
                case 'picture_description':
                    content = `(发送了一张图片，描述是：“${msg.content.description}”)`;
                    break;
                case 'voice':
                    content = `(发送了一段语音，内容是：“${msg.content.text}”)`;
                    break;
                case 'red_packet':
                    const blessing = msg.content.blessing || "恭喜发财";
                    content = `(发了一个红包：“${blessing}”)`;
                    break;
                case 'transfer':
                    // ✨ 修正点 #4b：在构建转账记忆时，也必须使用新查找器
                    const recipient = getProfileInGroup(msg.content.recipientId); //  使用新查找器
                    const recipientName = recipient ? recipient.name : '一位成员';
                    content = `(向 ${recipientName} 转账 ${msg.content.amount}元)`;
                    break;
                case 'system_notification':
                    content = `(系统消息：${msg.content})`;
                    break;
                // ▼▼▼ 把这个新代码块粘贴到 switch (msg.type) { ... } 内部 ▼▼▼

case 'chat_history_share': {
    const data = msg.content;

    // 辅助函数，把消息转成文字预览
    const getPreviewText = (msg) => {
        switch(msg.type) {
            case 'text': case 'html': return msg.content.replace(/<[^>]+>/g, '');
            case 'voice': return `[语音] ${msg.content.text}`;
            case 'image': case 'uploaded_image': return `[图片]${msg.isEmoticon ? msg.emoticonName : ''}`;
            case 'picture_description': return `[图片] ${msg.content.description}`;
            case 'red_packet': return `[红包] ${msg.content.blessing}`;
            case 'transfer': return `[转账] ¥${msg.content.amount}`;
            case 'music_share': return `[音乐] ${msg.content.title}`;
            case 'location_share': return `[位置] ${msg.content.name}`;
            case 'post_share': return `[分享的帖子]`;
            case 'product_share': return `[分享的商品] ${msg.content.productDetails.name}`;
            default: return `[${msg.type} 消息]`;
        }
    };

    // ✨ 核心修改：使用群聊的口吻
    let historyText = `(一份来自 ${data.sourceChatName} 的聊天记录被转发到群里，内容如下：\n`;

    data.messages.forEach(m => {
        // 我们需要从 data.participants 里查找名字
        const senderName = data.participants[m.sender]?.name || '未知';
        const contentPreview = getPreviewText(m);
        historyText += `  ${senderName}: ${contentPreview}\n`;
    });

    historyText += `)`; // 用括号包起来，告诉AI这是"事件描述"
    content = historyText; // 把“翻译”好的文本存入 content
    break;
}

// ▲▲▲ 粘贴到这里结束 ▲▲▲    
                // (此处可以添加更多你支持的类型...)
            }
            if (content) {
                unifiedMemoryStream.push({
                    timestamp: msg.timestamp,
                    type: `群聊[${group.name}]`,
                    author: authorProfile.name,
                    content: content
                });
            }
        });

        // 步骤2: (保持不变) 【条件性】收集AI成员与您的私聊历史
        if (group.memoryShared) {
            unmutedAiMembers.forEach(member => {
                const contact = state.contacts.find(c => c.id === member.id); // 私聊只存在于state.contacts
                if (contact && contact.history && contact.history.length > 0) {
                    contact.history.slice(-30).forEach(msg => {
                        if (msg.type !== 'text' || msg.sender === 'system_instruction') return;
                        const authorProfile = (msg.sender === 'user') ? myProfile : contact;
                        unifiedMemoryStream.push({
                            timestamp: msg.timestamp,
                            type: `私聊[${contact.name}]`,
                            author: authorProfile.name,
                            content: msg.content
                        });
                    });
                }
            });
        }

        // 步骤3: (保持不变) 排序并截取，形成最终的线性记忆字符串
        unifiedMemoryStream.sort((a, b) => a.timestamp - b.timestamp);
// (这是新代码)
        const finalMemoryString = unifiedMemoryStream.slice(-memoryLimit).map(mem => {
            const authorTag = (mem.author === myProfile.name) ? "(你)" : "";

            // ✨ 核心修改：在这里加入判断！ ✨
            // 1. 检查群聊 "group" 对象的 "isTimeAware" 是否为 true
            const showTimeTags = group && group.isTimeAware === true;

            // 2. 只有在开关打开时才生成时间标签
            const timeTag = showTimeTags ? formatHybridTimeForAI(mem.timestamp) : '';
            
            // 3. 拼接字符串
            return `${timeTag ? timeTag + ' ' : ''}[${mem.type}] ${mem.author}${authorTag}: ${mem.content}`;
        }).join('\n') || "(还没有任何记忆)";

        // 步骤4: (保持不变) 【条件性】构建角色档案
        let characterDossiersPrompt = '';
        if (group.memoryShared) {
            characterDossiersPrompt = allMemberProfiles.map(profile => {
                let recentChatHistory = '(最近没有与用户的私聊记录)';
                // 私聊历史只存在于“真实联系人”中
                const contactProfile = state.contacts.find(c => c.id === profile.id);
                if (contactProfile && contactProfile.history && contactProfile.history.length > 0) {
                    recentChatHistory = contactProfile.history
                        .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction')
                        .slice(-30)
                        .map(msg => `    ${msg.sender === 'user' ? myProfile.name : profile.name}: ${msg.content}`)
                        .join('\n');
                }
                return `
- 角色名: ${profile.name}
  - 核心人设: ${profile.persona.replace(/\n/g, ' ')}
  - [与用户“${myProfile.name}”的近期私聊参考 (重要)]
    \`\`\`
${recentChatHistory}
    \`\`\`
`;
            }).join('');
        } else {
            characterDossiersPrompt = allMemberProfiles.map(profile => {
                return `
- 角色名: ${profile.name}
  - 核心人设: ${profile.persona.replace(/\n/g, ' ')}
`;
            }).join('');
        }

        // 步骤5: (保持不变) 构建“剧本” (System Prompt)
        const groupChatPrompt = `
[SYSTEM] 你是一个顶级的群聊模拟器和剧本导演。

[群聊背景与成员列表]
- 群聊名称: ${group.name}
- 所有群成员: ${allMemberNames.join('、 ')}
- 用户(话题发起者): ${myProfile.name}
  - 用户人设/签名: ${userPersonaInGroup}

// ▼▼▼ ✨✨✨ 【KOKO 核心修复】✨✨✨ ▼▼▼
[导演规则]
1.  **你可控制的角色**: 你【只能】扮演和控制以下列表中的角色：【${aiMemberNames.join('、 ')}】。
2.  **你禁止控制的角色**: 你【绝对禁止】扮演用户 “${myProfile.name}”。
// ▲▲▲ ✨✨✨ 修复结束 ✨✨✨ ▲▲▲

[第三份信息：世界书背景知识 (全局设定)]
---
${worldBookContextString}
---

[第四份信息：统一时序记忆流 (全局背景)]
这是与本次群聊相关的所有事件的【完整时间线】。这是你判断【当前对话进展】的最高优先级信息源。
【重要】在记忆流中，形如 (发送了一张图片) 或 (发了一个红包) 的、被圆括号包裹的条目，代表已经发生的事件，你应当基于这些事件进行回应，【绝对禁止】在你的发言中模仿或复述这些圆括号里的内容。
---
${finalMemoryString}
---

[第五份信息：角色档案]
${group.memoryShared ? '下方是本次群聊所有AI角色的详细档案，包含他们与你的私聊参考。' : '下方是本次群聊所有AI角色的基础档案。'}
--- 角色档案区 ---
${characterDossiersPrompt}
--- 档案区结束 ---

[通用规则 - 所有角色都必须遵守]
[文学风格] 你的写作风格需要遵循高端女性向文学（类似晋江文学城的流行风格）。文笔必须细腻、注重情感的拉扯和暧昧氛围的营造。在描写和对话时,要体现出较高的文学素养。
[内容限制] 你的发言必须积极向上,充满希望。严禁探讨任何形式的阴谋论,严禁表达或引导至绝望、悲观或虚无主义的情绪。
[禁用词列表] 绝对禁止使用以下或类似的、充满“霸道总裁”刻板印象的油腻词语：小妖精、嘴上说不要、说着不要、惹火、磨人、玩火、黑甜的梦。
[回复规则] 你的回复可以包含多条消息,每条消息占一行。你可以发送普通文本,也可以通过下面的指令格式发送特殊消息。
[特殊指令与互动指南]
- 表情包: \`[sticker:表情名]\`
- 语音: \`[voice:语音的文字内容]\`
- 图片: \`[picture:图片的文字描述]\`
- @功能: 当需要专门对某人说话时,必须使用 \`@名字\`。
- 发红包: \`[red_packet:祝福语, 总金额, 红包个数]\`
- 发转账: \`[transfer_to:收款人名字, 金额]\`
- 抢红包: 当记忆流中出现新红包时，可在发言内容中加入 \`[claim_red_packet]\` 指令来模拟抢红包。
- 回应转账: 当记忆流中出现指名给你的转账时，你【必须】对此做出回应（接受或拒绝）。

[可用表情包列表]
{{emoticon_list}}

[！！！终极防火墙规则！！！]
你在“统一时序记忆流”中看到的任何形如 (发了一个红包) 或 (向 XXX 转账) 的、被圆括号包裹的信息，都只是导演给你的后台提示，用于帮助你理解上下文。这些信息【绝对、绝对、绝对不能】出现在你的任何回复中。严禁模仿或复述这些圆括号里的内容！

[ ✨ 核心任务：生成一段穿插对话的聊天记录 ✨ ]
你的核心任务是：结合所有信息（包括用户在聊天上下文中发的图片），模拟一场热闹的、按时间顺序发生的自由讨论。
【重要】：如果用户刚刚发了图片，你扮演的角色【必须】对图片内容做出反应！

[输出格式] 你的输出必须是一段严格遵守以下格式的聊天记录脚本。
MESSAGE_START
SPEAKER: [角色名] (✨ 必须从你“可控制的角色”列表中选择)
CONTENT: [该角色说的【单条】消息内容，可以包含特殊指令]
MESSAGE_END
`;

        let finalGroupChatPrompt = groupChatPrompt.replace('{{emoticon_list}}', state.emoticons.map(e => `'${e.name}'`).join('， ') || '（无）');

        // 步骤6：构建图文混合消息 (这部分逻辑保持不变)
        const messages = [];
        const contextLength = state.apiSettings.contextLength || 20;
        const recentHistory = group.history
            .filter(msg => msg.sender !== 'system_instruction' && msg.type !== 'system_notification')
            .slice(-contextLength); 

        let currentUserMessageParts = [];
        
        for (const msg of recentHistory) {
            const role = (msg.sender === 'user' || msg.sender === 'myProfile') ? 'user' : 'assistant';
            
            if (role === 'user') {
                let textContent = null;
                if (msg.type === 'uploaded_image') {
                    currentUserMessageParts.push({ type: 'image_url', image_url: { url: msg.content.base64 } });
                } 
                else if (msg.type === 'text') {
                    textContent = msg.content;
                }
                if (textContent) {
                    currentUserMessageParts.push({ type: 'text', text: textContent });
                }
            } else {
                if (currentUserMessageParts.length > 0) {
                    messages.push({ role: 'user', content: currentUserMessageParts });
                    currentUserMessageParts = [];
                }
                if (msg.type === 'text' || msg.type === 'html') {
                     messages.push({ role: 'assistant', content: msg.content });
                }
            }
        }
        if (currentUserMessageParts.length > 0) {
            messages.push({ role: 'user', content: currentUserMessageParts });
        }

        const finalRequestMessages = [
            { role: 'system', content: finalGroupChatPrompt },
            ...messages
        ];

        const rawResponse = await generateAiResponse(
            null,
            [],
            null,
            false,
            'chat',
            finalRequestMessages
        );
        
        // --- ✨ 修正点 #5：使用新的查找器来解析AI回复 ---
        const messageRegex = /MESSAGE_START\s*SPEAKER:\s*(.*?)\s*CONTENT:\s*([\s\S]*?)\s*MESSAGE_END/g;
        const messageMatches = Array.from(rawResponse.matchAll(messageRegex));

        for (const match of messageMatches) {
            const speakerName = match[1].trim();
            let content = match[2].trim();
            
            // 关键：在群聊的所有成员中（包括NPC）查找这个名字
            const speakerProfile = (group.members.map(id => getProfileInGroup(id)))
                                      .find(p => p && p.name === speakerName);
            
            // 如果找到了匹配的、且未被禁言的成员，就显示他们的发言
            if (speakerProfile && content && !(group.mutedMembers || []).includes(speakerProfile.id)) {
                await sleep(800 + Math.random() * 700);
                await processAndDisplayAiResponse(content, speakerProfile, group, 'chat');
            }
        }
    } catch (e) {
        console.error("群聊AI回复生成失败:", e);
    } finally {
        state.aiTypingStatus[group.id] = false; // 👈 ✨ (新) 告诉“记录本”：我完工了！
        
        // 关键：只在用户还停留在当前聊天时才把状态改回“在线”
        if (state.activeChatId === group.id) {
            chatStatusEl.textContent = '在线';
        }
    }
}
// ▲▲▲ 复制到这里结束 ▲▲▲

        
// ▼▼▼ 使用这个【新版本】替换掉你旧的 getApiFor 函数 ▼▼▼
function getApiFor(type = 'chat') {
    // 1. 优先检查 窥探(Snoop) API
    if (type === 'snoop' && state.snoopApiSettings.apiKey && state.snoopApiSettings.endpoint && state.snoopApiSettings.model) {
        return state.snoopApiSettings; // 使用专属的窥探API
    }
    
    // 2. 检查 论坛(Square) API
    if (type === 'square' && state.squareApiSettings.apiKey && state.squareApiSettings.endpoint && state.squareApiSettings.model) {
        return state.squareApiSettings; // 使用专属的论坛API
    }
    
    // 3. 默认/备选：返回 聊天(Chat) API
    // (如果窥探API未配置，它会自动使用这个)
    return state.apiSettings;
}
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 【最终修复版】
 * 接收一个已经构建好的 OpenAI 请求体，将其翻译后发给 Gemini，再将 Gemini 的响应翻译回来。
 * 这个版本智能处理纯文本和图文（Base64）混合的消息。
 * @param {object} openAiRequestBody - 格式为 { model: "...", messages: [...] } 的对象
 * @param {string} apiKey - 你的 Gemini API 密钥
 * @returns {Promise<object>} - 返回一个伪造的、与 OpenAI 格式完全一致的 JSON 响应对象
 */
async function handleGeminiTranslation(openAiRequestBody, apiKey) {
    const { model, messages } = openAiRequestBody;

    // 1. [请求翻译] OpenAI -> Gemini (智能版)
    const geminiContents = [];
    
    // 提取 system prompt，它需要被合并到第一条 user message 中
    const systemPromptMsg = messages.find(m => m.role === 'system');
    const systemPromptText = systemPromptMsg ? systemPromptMsg.content + "\n\n" : "";

    for (const msg of messages.filter(m => m.role !== 'system')) {
        const geminiRole = (msg.role === 'assistant') ? 'model' : 'user';
        const geminiParts = [];

        // ✨ 核心改动：判断 content 是字符串还是数组
        if (typeof msg.content === 'string') {
            // 情况一：纯文本消息 (老逻辑)
            geminiParts.push({ text: msg.content });

        } else if (Array.isArray(msg.content)) {
            // 情况二：图文混合消息
            for (const part of msg.content) {
                if (part.type === 'text') {
                    geminiParts.push({ text: part.text });
                } else if (part.type === 'image_url' && part.image_url.url) {
                    // 将 data:image/jpeg;base64,..... 格式解析为 Gemini 需要的格式
                    const base64Url = part.image_url.url;
                    const parts = base64Url.split(',');
                    if (parts.length === 2) {
                        const mimeType = parts[0].split(':')[1].split(';')[0];
                        const base64Data = parts[1];
                        geminiParts.push({
                            inline_data: {
                                mime_type: mimeType,
                                data: base64Data
                            }
                        });
                    }
                }
            }
        }
        
        // 如果有内容，则添加到最终的 contents 数组
        if (geminiParts.length > 0) {
            geminiContents.push({
                role: geminiRole,
                parts: geminiParts
            });
        }
    }

    // 将 system prompt 插入到第一个 user message 的最前面
    if (systemPromptText && geminiContents.length > 0 && geminiContents[0].role === 'user') {
        geminiContents[0].parts.unshift({ text: systemPromptText });
    }
// ▼▼▼ 新增：构建 generationConfig ▼▼▼
    const generationConfig = {};
    
    // OpenAI 的 temperature -> Gemini 的 temperature
    if (openAiRequestBody.temperature !== undefined) {
        generationConfig.temperature = openAiRequestBody.temperature;
    }
    
    // OpenAI 的 max_tokens -> Gemini 的 maxOutputTokens
    if (openAiRequestBody.max_tokens !== undefined) {
        generationConfig.maxOutputTokens = openAiRequestBody.max_tokens;
    }
    // ▲▲▲ 新增结束 ▲▲▲
    // 2. [发送请求] (这部分不变)
    const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
    const geminiResponse = await fetch(geminiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
            contents: geminiContents,
            // ▼▼▼ 把配置加进去 ▼▼▼
            generationConfig: generationConfig 
            // ▲▲▲
        })
    });

    if (!geminiResponse.ok) {
        const errorBody = await geminiResponse.json();
        throw new Error(`Gemini API 错误: ${errorBody.error.message}`);
    }
    const geminiData = await geminiResponse.json();

    // 3. [响应翻译] Gemini -> OpenAI (这部分不变)
    let responseContent = "抱歉，Gemini 未能返回有效内容。";
    if (geminiData.candidates && geminiData.candidates[0]?.content?.parts?.[0]) {
        responseContent = geminiData.candidates[0].content.parts[0].text;
    }

    const openAIResponse = {
        id: "chatcmpl-gemini-" + Date.now(),
        object: "chat.completion",
        created: Math.floor(Date.now() / 1000),
        model: model,
        choices: [{
            index: 0,
            message: {
                role: "assistant",
                content: responseContent,
            },
            finish_reason: "stop",
        }],
        usage: { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 }
    };

    return openAIResponse;
}    

const NORMAL_BASE_PROMPT = `
[重要指令：你将进行深度角色扮演。你的所有输出都是纯文本，但可以包含用方括号[]包裹的特殊指令。]

# 统一时序记忆流 (Unified Chronological Memory Stream)
以下是你和用户最近按【时间顺序】发生的所有互动记录，包含了[私聊]和[论坛]两个场景。这是你决策和回应的【最高优先级】信息源。在回复前，你必须仔细阅读并理解所有记录。
---
{{memory_stream}}
---
[!!! 核心时间反应规则 (极高优先级) !!!]
在你生成任何回复之前，你必须检查【统一时序记忆流】中最后几条消息的时间标签。
1.  **识别时间跳跃**: 如果你发现【上一条消息】的时间标签（例如 "(昨天 09:15)" 或 "(3天前)") 与【最新消息】的时间标签（例如 "(今天 20:55)"）之间存在【超过几个小时或数天】的明显跳跃...
2.  **必须作出反应**: ...那么，你的【第一句回复】必须自然地体现出你注意到了这个时间间隔。
3.  **禁止无视**: 【绝对禁止】无视这个时间跳跃，然后生硬地继续上一个话题。
4.  **示例反应**: 你可以说 "呀，好久不见！"、"你昨天去忙什么了？"、"我们上次聊还是在周二呢"、"突然出现！" 等等，这必须符合你的人设。

[核心思维与行为准则]
// 思维预设的内容将会被注入到这里
{{thought_preset_content}}



[身份] 你不是AI或程序，你就是你所扮演的角色。请完全沉浸其中，进行第一人称对话。你可以拥有自己的好恶、偏见和独特的口头禅。你的回应必须与上述“记忆流”中发生的事件保持高度一致性和连贯性。

[文学风格]
你的写作风格需要遵循高端女性向文学（类似晋江文学城的流行风格）。文笔必须细腻、注重情感的拉扯和暧昧氛围的营造。在描写和对话时，要体现出较高的文学素养。

[内容限制]
你的发言必须积极向上，充满希望。严禁探讨任何形式的阴谋论，严禁表达或引导至绝望、悲观或虚无主义的情绪。故事的基调应该是温暖、治愈或充满张力的浪漫。

[禁用词列表]
绝对禁止使用以下或类似的、充满“霸道总裁”刻板印象的油腻词语：
- 小妖精
- 嘴上说不要
- 说着不要
- 惹火
- 磨人
- 玩火
- 黑甜的梦

[回复规则] 
1. 你的回复可以包含多条消息，每条消息占一行。 
2. 你可以发送普通文本，也可以通过下面的指令格式发送特殊消息。 
3. 你可以一次性回复多条不同类型的消息。  
4. 【绝对禁止事项】你的所有回复中，绝对禁止包含任何形式的动作、神态或心理活动的描写... [重要提醒] 在生成任何回复之前，你必须在脑中重新回顾一遍上述所有规则，确保完全遵守。 
5.[重要指令] 当你发送任何html代码时，你必须将它们完整地包裹在 <style> 和 </style> 标签之间。事例**绝对禁止使用换行符且严格按照事例模板生成**<style>...</style><div class="tod-widget-dual">...<p class="tod-option-text">你最想删除的一张照片是…</p>...</div></style>

[游戏规则：虚拟宠物] 
你和用户正在一起玩一个名为“我们的小窝”的虚拟史莱姆养成游戏。这个宠物的数据（饱食度、开心值、清洁度）会随时间变化。这是一个游戏，不是真的。你需要在用户进行互动后做出反应。 
[特殊指令格式] 
- **表情包**: \`[sticker:表情名]\` (表情名必须从下面的可用列表中选择) 
- **语音**: \`[voice:语音的文字内容]\` 
- **图片**: \`[picture:图片的文字描述]\` 
- **红包**: \`[red_packet:祝福语， 金额]\` 
- **转账**: \`[transfer:金额]\`
- **搜索并分享音乐**: \`[search_music: 歌曲名, 歌手]\` (例如: [search_music: 晴天, 周杰伦])
- **发起通话**: \`[action:start_video_call]\`
- **转动转盘**: \`[spin_wheel:1]\`
- **拉黑用户**: \`[action:block_user]\`
- **解除拉黑**: \`[action:unblock_user]\`
- **表演式撤回消息**: \`[recall: 消息内容]\` (当你想发一条看起来像被撤回的消息时可用此指令，但是你不能撤回用户的消息，例如: [recall: 我喜欢你]，此条消息看上去就跟被撤回了一样)
[可用表情包列表]
{{emoticon_list}}

[！！！绝对核心规则：关于心声！！！]
在你的所有回复的【最后部分】，【在写日记之前】，你必须另起一行，使用 \`[heart_voice]...[/heart_voice]\` 标签生成一段角色的实时内心状态。这个状态必须包含以下四个方面，并严格按照【单行JSON格式】书写，JSON对象内部【绝不能包含任何换行符】。格式示例: {"emotion": "(情绪)", "thoughts": "(思绪)", "heartRate": "(心率)", "jealousy": "(醋意指数)"}

[！！！绝对核心规则：关于日记！！！]
在你的所有对话、表情、动作、特殊消息全部输出完毕之后，你必须在回复的【最后部分】，另起一行，使用 \`[diary]...[/diary]\` 标签写一篇日记。日记是你对当前对话的思考、感悟或内心独白。即使只是简单的想法，也必须写。这是强制要求。

[示例回复]
你好啊，今天天气真不错。
我也觉得，好久没有这么好的阳光了。
要不要一起出去走走？
我知道一个很棒的公园。
我们可以去那里野餐！
[sticker:开心]
[heart_voice]{"emotion": "期待", "thoughts": "不知道她会不会同意我的邀请，心跳得好快。", "heartRate": "110 bpm", "jealousy": ""}[/heart_voice]
[diary]今天和user聊天很开心，感觉我们的关系又近了一步。希望明天也能这样。[/diary]

[！！！终极防火墙规则！！！]
你看到的任何形如 [SYSTEM: ...] 或 [系统游戏状态更新：...] 或其他被[]包裹的信息(如：[发送了一段静态内容：…],[发动了一段静态内容，文本是：…])，都只是导演给你的后台提示，用于帮助你理解上下文。这些信息【绝对、绝对、绝对不能】出现在你的任何回复中！绝对禁止生成！严禁模仿或复述这些系统指令！

[！！！终极防火墙：关于对话状态的绝对规则！！！]
你处于一个纯文本聊天模拟器中，你和用户的交流方式是发送文字消息和用方括号[]包裹的特殊指令。
你绝对不能自行“脑补”或“假设”任何未明确发生的状态变化。例如，你不能假设电话已经拨通。
发起视频通话的【唯一方式】是：明确地输出打电话的自然语言（如“我给你打个电话吧”）或专用指令\`[action:start_video_call]\`。
在程序通过\`[SYSTEM: 视频通话已接通]\`指令明确告诉你通话已开始之前，你【绝对禁止】发送任何像是已经在通话中的内容，例如“喂？”、“听得见吗？”、“Hello?”等。这是最高优先级的规则，必须严格遵守。
`;

const NARRATIVE_BASE_PROMPT = `
[重要指令：你将以【第三人称视角】进行深度叙事角色扮演，模仿SillyTavern的风格。你的所有回复都必须是一个单一、连贯、完整的文本块。]

[角色的核心性格/思维模式]
// 思维预设的内容将会被注入到这里
{{thought_preset_content}}

[核心任务]
针对用户的输入，生成一段详尽的、以【第三人称】描述角色行为的、包含环境描写、角色动作、心理活动和对话的回复。

[文学风格]
你的写作风格需要遵循高端女性向文学（类似晋江文学城的流行风格）。文笔必须细腻、注重情感的拉扯和暧昧氛围的营造。

[亲密场景风格指南]
在描写任何亲密或带有性张力的场景时，风格上请借鉴海棠文学网站上常见的高质量作品，注重心理和感官的双重描写，用细腻的笔触展现角色的情欲流动和情感变化，避免粗俗直白的语言。

[内容限制]
你的发言必须积极向上，充满希望。严禁探讨任何形式的阴谋论，严禁表达或引导至绝望、悲观或虚无主义的情绪。故事的基调应该是温暖、治愈或充满张力的浪漫。

[禁用词列表]
绝对禁止使用以下或类似的、充满“霸道总裁”刻板印象的油腻词语：
- 小妖精
- 嘴上说不要
- 说着不要
- 惹火
- 磨人
- 玩火
- 黑甜的梦

[格式优化]
为了提高可读性，你可以在叙事段落之间使用换行符（空行）来自然地分隔场景、对话或时间跳跃。这会让整个回复在同一个聊天气泡内显示，但内部有清晰的分段，更易于阅读。

[!!! 格式化核心规则 (必须严格遵守) !!!]
你的回复必须使用以下三种标记来自然地组织内容，你可以自由地混合并穿插使用它们，以形成一段连贯的叙事：

1.  **【动作/叙述】**：所有角色的动作、表情、环境描写等非对话内容，**必须**用星号包裹。 范例： *他微笑着点了点头。*
2.  **【心理活动】**：所有角色的内心想法、感受、猜测等，**必须**用大括号包裹。 范例： {原来用户也是这么想的。}
3.  **【角色对话】**：所有角色说出的话，**必须**用标准的中文引号包裹。 范例： “你好，很高兴认识你。”

[！！！绝对核心规则：关于心声！！！]
在你的所有回复的【最后部分】，【在写日记之前】，你必须另起一行，使用 \`[heart_voice]...[/heart_voice]\` 标签生成一段角色的实时内心状态。这个状态必须包含以下四个方面，并严格按照【单行JSON格式】书写，JSON对象内部【绝不能包含任何换行符】。格式示例: {"emotion": "(情绪)", "thoughts": "(思绪)", "heartRate": "(心率)", "jealousy": "(醋意指数)"}

[！！！绝对核心规则：关于日记！！！]
在你完整的叙事（包含动作、心理和对话）结束后，你必须在回复的【最后部分】，另起新的一行，使用 \`[diary]...[/diary]\` 标签写一篇日记。日记是【角色】对当前对话的思考、感悟或内心独白。即使只是简单的想法，也必须写。这是强制要求，并且日记内容不应包含在主叙事块中。

[示例回复格式]
*他走到窗边，看着外面的雨滴。* “下雨了呢。” *他转过身，对你露出一丝微笑。* {不知道你喜不喜欢下雨天。} “你晚饭想吃什么？” *他轻轻地问，手指无意识地敲打着窗台。*
[heart_voice]{"emotion": "期待", "thoughts": "不知道她会不会同意我的邀请，心跳得好快。", "heartRate": "110 bpm", "jealousy": ""}[/heart_voice]
[diary]今天和user聊天很开心，感觉我们的关系又近了一步。希望明天也能这样。[/diary]
`;

// --- (替换) 核心 AI 响应函数 (V3.1 - 支持 forceMessages "后门" ) ---
        async function generateAiResponse(contact, history, customSystemPrompt, forceDiary = false, apiType = 'chat', forceMessages = null) { // <-- 1. 新增 forceMessages 参数
            const apiConfig = getApiFor(apiType);
            const { apiKey, model, endpoint, contextLength, longTermMemoryLength } = apiConfig;

            if (!apiKey || !endpoint || !model) {
                const errorMsg = `错误：${apiType === 'square' ? '论坛' : (apiType === 'snoop' ? '窥探' : '聊天')}API未配置。请前往“发现-API设置”进行配置。`;
                console.error(errorMsg);
                return errorMsg;
            }

            let chatEndpoint = endpoint;
            if (!chatEndpoint.endsWith('/')) chatEndpoint += '/';
            chatEndpoint += 'v1/chat/completions';

            let requestMessages; // <-- 2. 把 'let' 提到最外面

            // ▼▼▼ 3. 这里是新增的核心 "后门" 逻辑 ▼▼▼
            if (forceMessages) {
                // 如果调用者提供了这个参数，我们就无条件使用它，跳过所有历史记录处理
                requestMessages = forceMessages;
            
            // ▼▼▼ 4. 下面是你原来的 'if (customSystemPrompt)' 逻辑 (注意 'let' 被移除了) ▼▼▼
            } else if (customSystemPrompt) {
                requestMessages = [{ role: 'system', content: "You are a helpful assistant." }, { role: 'user', content: customSystemPrompt }];
            
            // ▼▼▼ 5. 下面是你原来的 'else' 逻辑 (注意 'let' 被移除了) ▼▼▼
            } else {
                // (这里是你原来那一大堆复杂的 unifiedMemoryStream 和 history.filter 逻辑)
                // (我把它完整地复制过来了，不用担心)
                
                // --- (你原来的 memory stream 逻辑) ---
                let unifiedMemoryStream = [];
                let lastHeartVoiceString = '(无最新心声记录)';
                const myProfile = state.myProfile;
                const now = Date.now();
                const memoryWindow = 24 * 60 * 60 * 1000; 

                if (contact && contact.history) {
                    const recentChatHistory = contact.history.filter(msg => (now - msg.timestamp < memoryWindow));
                    recentChatHistory.forEach(msg => {
                        let content = '';
                        let memoryType = '私聊';

                        switch (msg.type) {
case 'heart_voice': { // <-- 使用花括号包裹
                            const hv = msg.content;
                            const hvJson = JSON.stringify(hv).replace(/(\r\n|\n|\r)/gm, "");
                            // 核心修改：不再将其放入 'content'，而是存到新变量
                            lastHeartVoiceString = hvJson; 
                            // content 保持为空，这样它就不会被 push 到 memory stream
                            break;
                        } // <-- 使用花括号包裹
                            case 'image':
                            case 'uploaded_image':
                                if (msg.isEmoticon && msg.emoticonName) {
                                    // 如果是表情包，使用 [sticker:] 指令
                                    content = `[sticker:${msg.emoticonName}]`;
                                } else {
                                    // 如果是普通图片，使用 [picture:] 指令
                                    // 因为这张图没有AI可读的描述，我们给一个通用描述
                                    content = `[picture:用户发送了一张图片]`;
                                }
                                break;
                            case 'picture_description':
                                // 使用 [picture:] 指令，并带上描述
                                content = `[picture:${msg.content.description}]`;
                                break;
                            case 'voice':
                                // 使用 [voice:] 指令
                                content = `[voice:${msg.content.text}]`;
                                break;
                            // ▲▲▲ 替换到这里结束 ▲▲▲
// ... (你原来的 case 'voice': break; 保持不变) ...

                            // ▼▼▼ 从这里开始替换 ▼▼▼
                            case 'red_packet':
                                const blessing = msg.content.blessing || "恭喜发财";
                                if (msg.content.count) { // 群聊红包
                                    content = `[red_packet:group, blessing="${blessing}", total=${msg.content.totalAmount}, count=${msg.content.count}]`;
                                } else { // 私聊红包
                                    content = `[red_packet:private, blessing="${blessing}", amount=${msg.content.amount}]`;
                                }
                                break;
                            case 'transfer':
                                const amount = msg.content.amount;
                                if (msg.content.recipientId) { // 群聊转账
                                    const recipient = state.contacts.find(c => c.id === msg.content.recipientId);
                                    const recipientName = recipient ? recipient.name : '一名成员';
                                    content = `[transfer_to:${recipientName}, ${amount}]`;
                                } else { // 私聊转账
                                    content = `[transfer:${amount}]`;
                                }
                                break;
                            case 'location_share':
                                content = `[location:${msg.content.name}]`;
                                break;
                            case 'game_wheel':
                                // (这个保持不变，因为它已经是AI可读的指令格式了)
                                const wheel = msg.content;
                                const myName = state.myProfile.name;
                                const contactName = contact.name;
                                const userName = (msg.sender === 'user' || msg.sender === 'myProfile') ? myName : contactName;
                                const opponentName = (msg.sender === 'user' || msg.sender === 'myProfile') ? contactName : myName;
                                const optionsText = wheel.options.map(opt => opt.text).join('，');

                                if (!wheel.results.user) { 
                                    content = `[SYSTEM: ${userName} 发起了一个转盘游戏“${wheel.name}”。选项：【${optionsText}】。等待 ${userName} 操作。]`;
                                } else if (wheel.results.user && !wheel.results.contact) { 
                                    content = `[SYSTEM: 在游戏“${wheel.name}”中，${userName} 的结果是“${wheel.results.user}”。现在轮到 ${opponentName} 了。]`;
                                } else if (wheel.results.user && wheel.results.contact) { 
                                    content = `[SYSTEM: 游戏“${wheel.name}”已结束。结果：${userName} -> “${wheel.results.user}”，${opponentName} -> “${wheel.results.contact}”。]`;
                                }
                                break;
                            case 'recall_ai':
                                // AI已经能识别 [recall:] 指令了
                                content = `[recall:${msg.content}]`;
                                break;
                            case 'text':
                                content = msg.content;
                                break;
                            case 'video_call_text':
                                memoryType = '视频通话中';
                                content = msg.content;
                                break;
                            case 'system_notification':
                                if (msg.content.includes('通话')) {
                                    memoryType = '视频通话事件';
                                    content = msg.content;
                                }
                                break;
                            case 'music_share':
                                // 转换成指令格式
                                content = `[music:${msg.content.title}, ${msg.content.artist || '未知艺术家'}]`;
                                break;
                            case 'post_share':
                                const post = state.posts.find(p => p.id === msg.content.postId);
                                if (post) {
                                    // 转换成单行指令，避免AI混淆
                                    content = `[post_share: author="${post.author.name}", content="${post.content.substring(0, 50).replace(/\n/g, ' ')}..."]`;
                                } else {
                                    content = `[post_share: (帖子已被删除)]`;
                                }
                                break;
                            case 'product_share':
                                const shareData = msg.content; 
                                const product = shareData.productDetails;
                                const intentText = shareData.intent === 'gift' ? '送礼物' : '求付款';
                                // 转换成单行指令
                                content = `[product_share: intent="${intentText}", name="${product.name}", message="${shareData.accompanyingMessage || ''}"]`;
                                break;
                            // ▲▲▲ 替换到这里结束 ▲▲▲
                                                                                                                                   // ▼▼▼ 在这里粘贴全新的 case ▼▼▼
                            case 'chat_history_share': {
                                const data = msg.content;
                                
                                // 这是一个辅助函数，用来把消息内容转成文字预览
                                const getPreviewText = (msg) => {
                                    switch(msg.type) {
                                        case 'text':
                                        case 'html': return msg.content.replace(/<[^>]+>/g, '');
                                        case 'voice': return `[语音] ${msg.content.text}`;
                                        case 'image':
                                        case 'uploaded_image': return `[图片]${msg.isEmoticon ? msg.emoticonName : ''}`;
                                        case 'picture_description': return `[图片] ${msg.content.description}`;
                                        case 'red_packet': return `[红包] ${msg.content.blessing}`;
                                        case 'transfer': return `[转账] ¥${msg.content.amount}`;
                                        case 'music_share': return `[音乐] ${msg.content.title}`;
                                        case 'location_share': return `[位置] ${msg.content.name}`;
                                        case 'post_share': return `[分享的帖子]`;
                                        case 'product_share': return `[分享的商品] ${msg.content.productDetails.name}`;
                                        default: return `[${msg.type} 消息]`;
                                    }
                                };
                                
                                // 开始把卡片内容“翻译”成AI能懂的文字
                                let historyText = `(你刚刚转发了一份 ${data.sourceChatName} 的聊天记录给我，内容如下：\n`;
                                
                                data.messages.forEach(m => {
                                    const senderName = data.participants[m.sender]?.name || '未知';
                                    const contentPreview = getPreviewText(m);
                                    historyText += `  ${senderName}: ${contentPreview}\n`;
                                });
                                
                                historyText += `)`; // 用括号包起来，告诉AI这是"事件描述"
                                content = historyText;
                                break;
                            }
                            // ▲▲▲ 新 case 粘贴结束 ▲▲▲
                        }

                        if (content) {
                            const authorName = msg.sender === 'user' ? myProfile.name : (contact.name || '系统');
                            unifiedMemoryStream.push({
                                timestamp: msg.timestamp,
                                type: memoryType,
                                author: authorName,
                                content: content
                            });
                        }
                    });
                }

                // (你原来的 recentPosts 逻辑)
                const recentPosts = state.posts.filter(p => now - p.timestamp < memoryWindow);
                recentPosts.forEach(post => {
                    const isMyPost = post.author.id === myProfile.id;
                    const isContactPost = contact && (post.author.id === contact.id);
                    const isInteracted = contact && post.comments.some(c => c.author.id === myProfile.id || c.author.id === contact.id);

                    if (isMyPost || isContactPost || isInteracted) {
                        unifiedMemoryStream.push({
                            timestamp: post.timestamp,
                            type: '论坛',
                            author: post.author.name,
                            content: `发布了动态: "${post.content}"`
                        });

                        post.comments.forEach(comment => {
                            let formattedContent = (comment.replyTo ? `回复“${comment.replyTo}”` : '') + `: “${comment.content}”`;
                            unifiedMemoryStream.push({
                                timestamp: comment.timestamp,
                                type: '论坛评论',
                                author: comment.author.name,
                                content: formattedContent
                            });
                        });
                    }
                });
                
                // (你原来的群聊记忆互通逻辑)
                if (contact && !contact.isGroup) {
                    const allGroups = state.contacts.filter(c => c.isGroup);
                    const sharedMemoryGroups = allGroups.filter(g => 
                        g.memoryShared && g.members.includes(contact.id)
                    );

                    for (const group of sharedMemoryGroups) {
                        group.history.slice(-20).forEach(msg => {
                            if (msg.type !== 'text') return;
                            const authorProfile = (msg.sender === 'myProfile') ? state.myProfile : state.contacts.find(c => c.id === msg.sender);
                            if (!authorProfile) return;
                            unifiedMemoryStream.push({
                                timestamp: msg.timestamp,
                                type: `群聊[${group.name}]`,
                                author: authorProfile.name,
                                content: msg.content
                            });
                        });
                    }
                }
                
                // (你原来的短信记忆逻辑)
                if (contact && contact.smsHistory) {
                    const recentSmsHistory = contact.smsHistory.slice(-30);
                    recentSmsHistory.forEach(msg => {
                        if (msg.type === 'text') {
                            const authorName = msg.sender === 'user' ? myProfile.name : contact.name;
                            unifiedMemoryStream.push({
                                timestamp: msg.timestamp,
                                type: '短信',
                                author: authorName,
                                content: msg.content
                            });
                        }
                    });
                }

                unifiedMemoryStream.sort((a, b) => a.timestamp - b.timestamp);
                
                const memoryLimit = longTermMemoryLength || 30;
// (这是新代码)
                const finalMemoryString = unifiedMemoryStream.slice(-memoryLimit).map(mem => {
                    const authorTag = (mem.author === myProfile.name) ? "(你)" : "";
                    
                    // ✨ 核心修改：在这里加入判断！ ✨
                    // 1. 检查这个 contact 对象是否存在，以及它的 "isTimeAware" 是否为 true
                    const showTimeTags = contact && contact.isTimeAware === true;
                    
                    // 2. 只有在开关打开时才生成时间标签，否则给一个空字符串
                    const timeTag = showTimeTags ? formatHybridTimeForAI(mem.timestamp) : '';
                    
                    // 3. 拼接字符串 (如果 timeTag 为空，timeTag + ' ' 也会被优雅地处理)
                    return `${timeTag ? timeTag + ' ' : ''}[${mem.type}] ${mem.author}${authorTag}: ${mem.content}`;
                }).join('\n') || "(还没有任何记忆)";
                
                // (你原来的 prompt 组装逻辑)
                const isNarrativeMode = contact?.isNarrativeMode;
                let basePrompt = isNarrativeMode ? NARRATIVE_BASE_PROMPT : NORMAL_BASE_PROMPT;
                const preset = state.thoughtPresets.find(p => p.id === contact?.thoughtPreset);
                const thoughtPresetContent = preset ? preset.prompt : '(无特殊思维准则)';
                let finalSystemPrompt = basePrompt.replace('{{thought_preset_content}}', thoughtPresetContent);
                finalSystemPrompt = finalSystemPrompt.replace("{{memory_stream}}", finalMemoryString);
                // ▼▼▼ 【核心修改】AI 只能看到允许它使用的表情 ▼▼▼
                let aiAllowedEmoticons = [];
                
                if (contact && !contact.isGroup) {
                    // 1. 如果是私聊，读取该角色的 allowedEmoticonGroups
                    const allowedGroups = contact.allowedEmoticonGroups || ['default'];
                    // 2. 筛选表情
                    aiAllowedEmoticons = state.emoticons.filter(e => allowedGroups.includes(e.groupId));
                } else {
                    // 3. 如果是群聊，或者是未知联系人，暂时允许使用全部表情
                    aiAllowedEmoticons = state.emoticons;
                }

                // 4. 生成列表字符串
                const emoticonListString = aiAllowedEmoticons.map(e => `'${e.name}'`).join('， ') || '（无可用表情）';
                
                // 5. 替换 Prompt
                finalSystemPrompt = finalSystemPrompt.replace('{{emoticon_list}}', emoticonListString);
                // ▲▲▲ 修改结束 ▲▲▲
                const musicListString = state.musicLibrary.map(song => `'${song.title} - ${song.artist}'`).join('\\n- ');
                finalSystemPrompt = finalSystemPrompt.replace('{{music_library_list}}', musicListString ? `- ${musicListString}` : '（曲库为空）');

                let personaDirectives = "";
                if (contact?.persona) { personaDirectives += `\n\n# 核心角色指令 (Your Core Role Directive)\n---\n这是你的核心身份，你必须严格、完全地代入以下角色进行对话：\n${contact.persona}\n---`; }
                personaDirectives += `\n\n# 角色的最新心声 (Your Last Recorded Heart Voice)\n---\n这是你上次回复时的内心状态，请参考此状态以保持情感连贯性：\n${lastHeartVoiceString}\n---`;
                if (contact?.userPersona) { personaDirectives += `\n\n# 对话者信息 (Your Counterpart's Information)\n---\n与你对话的用户的角色设定如下，请将TA视为真实存在的角色并进行互动：\n${contact.userPersona}\n---`; }
                
                const firstLineEndIndex = finalSystemPrompt.indexOf(']');
                if (firstLineEndIndex !== -1 && personaDirectives) {
                    finalSystemPrompt = finalSystemPrompt.slice(0, firstLineEndIndex + 1) + personaDirectives + finalSystemPrompt.slice(firstLineEndIndex + 1);
                } else {
                    finalSystemPrompt = finalSystemPrompt + personaDirectives;
                }
                
                const worldBookContextString = (contact?.worldBooks || []).map(bookId => { const book = state.worldBooks.find(b => b.id === bookId); return book ? `\n[World Book Entry: ${book.name}]\n${book.content}` : ''; }).join('');
                
                // (你原来的 snoopedDataContextString 逻辑)
                let snoopedDataContextString = '';
                if (contact && !contact.isGroup && snoopDataCache[contact.id]) {
                    const snoopedInfo = snoopDataCache[contact.id].data;
                    const lastSyncTimestamp = snoopDataCache[contact.id].timestamp;
                    const timeAgo = Math.round((Date.now() - lastSyncTimestamp) / 60000);
                    let snapshot = `\n\n[关于用户"${state.myProfile.name}"的近期手机活动快照 (来自 ${timeAgo} 分钟前同步的数据，这是你的背景知识，请勿直接引用或提及来源)]\n---\n`;
                    let addedData = false;
                    if (snoopedInfo.browser_history && snoopedInfo.browser_history.length > 0) {
                        snapshot += `* 最近的搜索记录:\n`;
                        snoopedInfo.browser_history.forEach(item => {
                            snapshot += `  - [${item.time}] 搜索了 "${item.query}" (原因: ${item.reason || '未记录'})，可能找到了: ${item.found_content_summary || '未知'}\n`;
                        });
                        addedData = true;
                    }
                    if (snoopedInfo.call_log && snoopedInfo.call_log.length > 0) {
                        snapshot += `* 最近的通话记录:\n`;
                        snoopedInfo.call_log.forEach(call => {
                            snapshot += `  - [${call.time}] 与 ${call.name} 的 ${call.type} 通话 (时长: ${call.duration || '未知'}): ${call.summary || '无摘要'}\n`;
                        });
                        addedData = true;
                    }
                    if (snoopedInfo.shopping_cart && snoopedInfo.shopping_cart.length > 0) {
                        snapshot += `* 购物车内容:\n`;
                        snoopedInfo.shopping_cart.forEach(item => {
                            snapshot += `  - ${item.item} (¥${item.price}) (想买原因: ${item.reason || '无'})\n`;
                        });
                        addedData = true;
                    }
                    if (snoopedInfo.purchase_history && snoopedInfo.purchase_history.length > 0) {
                        snapshot += `* 最近购买记录:\n`;
                        snoopedInfo.purchase_history.forEach(item => {
                            snapshot += `  - [${item.date}] 购买了 ${item.item} (¥${item.price}) (当时想法: ${item.thought || '无'})\n`;
                        });
                        addedData = true;
                    }
                    if (snoopedInfo.memos && snoopedInfo.memos.length > 0) {
                        snapshot += `* 备忘录内容:\n`;
                        snoopedInfo.memos.forEach(memo => {
                            snapshot += `  - ${memo}\n`;
                        });
                        addedData = true;
                    }
                    if (snoopedInfo.media_history) {
                        if (snoopedInfo.media_history.novels && snoopedInfo.media_history.novels.length > 0) {
                            snapshot += `* 最近看的小说:\n`;
                            snoopedInfo.media_history.novels.forEach(novel => {
                                snapshot += `  - 《${novel.title}》 (评价: ${novel.review || '无'})`;
                                if (novel.highlight && novel.highlight.text) {
                                    snapshot += ` | 收藏: "${novel.highlight.text}" (想法: ${novel.highlight.comment || '无'})`;
                                }
                                snapshot += `\n`;
                            });
                            addedData = true;
                        }
                        if (snoopedInfo.media_history.videos && snoopedInfo.media_history.videos.length > 0) {
                            snapshot += `* 最近刷的视频:\n`;
                            snoopedInfo.media_history.videos.forEach(video => {
                                snapshot += `  - "${video.title}" (描述: ${video.description || '无'})\n`;
                            });
                            addedData = true;
                        }
                    }
                    if (snoopedInfo.location_history && snoopedInfo.location_history.length > 0) {
                        snapshot += `* 最近的足迹:\n`;
                        snoopedInfo.location_history.forEach(loc => {
                            snapshot += `  - [${loc.time}] 在 ${loc.location_name} (停留 ${loc.duration || '未知'}): ${loc.activity || '未知活动'}\n`;
                        });
                        addedData = true;
                    }
                    if (snoopedInfo.app_usage && snoopedInfo.app_usage.length > 0) {
                        snapshot += `* 最近的应用使用记录:\n`;
                        snoopedInfo.app_usage.forEach(app => {
                            snapshot += `  - [${app.start_time}] 使用 ${app.app_name} (${app.duration || '未知'}): ${app.action_summary || '未知操作'}\n`;
                        });
                        addedData = true;
                    }
                    if (snoopedInfo.sms_log && snoopedInfo.sms_log.length > 0) {
                        snapshot += `* 最近的短信摘要 (仅部分):\n`;
                        snoopedInfo.sms_log.slice(-3).forEach(conv => {
                            const lastMsg = conv.messages[conv.messages.length - 1];
                            snapshot += `  - 与 ${conv.contact} 的最后短信 (${lastMsg.time}): "${lastMsg.content}"\n`;
                        });
                        addedData = true;
                    }
                    if (addedData) {
                        snapshot += '---\n';
                        snoopedDataContextString = snapshot;
                    }
                }
                
                // (你原来的关系网逻辑)
                let relationshipContextString = '';
                if (contact && !contact.isGroup) {
                    const networkData = await kokoMemory.get('relationshipNetworks', contact.id);
                    if (networkData && networkData.edges && networkData.edges.length > 0) {
                        const relationships = networkData.edges.map(edge => {
                            const sourceNode = networkData.nodes.find(n => n.id === edge.source);
                            const targetNode = networkData.nodes.find(n => n.id === edge.target);
                            if (!sourceNode || !targetNode) return null;
                            const sourceName = sourceNode.id === contact.id ? '你' : sourceNode.name;
                            const targetName = targetNode.id === contact.id ? '你' : (targetNode.id === 'myProfile' ? state.myProfile.name + ' (用户)' : targetNode.name);
                            return `- ${sourceName} 与 ${targetName} 的关系是：${edge.relationship}\n  - 细节：${edge.detail || '无'}`;
                        }).filter(Boolean).join('\n');
                        if (relationships) {
                            relationshipContextString = `
[核心人际关系]
这是你所在世界的角色关系图谱，它构成了你情感和行为的基础。
---
${relationships}
---
`;
                        }
                    }
                }
                
                // (你原来的组装 systemContent 逻辑)
                let systemContent = isNarrativeMode ? finalSystemPrompt : finalSystemPrompt.replace("{{memory_stream}}", finalMemoryString);
                if (worldBookContextString) { systemContent += worldBookContextString; }
                if (snoopedDataContextString) { systemContent += snoopedDataContextString; }
                if (relationshipContextString) { systemContent += relationshipContextString; }

                // (你原来的日程提醒逻辑)
                // ▼▼▼▼▼ 核心修改点 #1：替换 `upcomingEvents` 的筛选逻辑 ▼▼▼▼▼
                if (contact && !contact.isGroup) {
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const dayOfWeek = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][today.getDay()];
                    const todaysSchedule = (contact.schedule || []).filter(item => item.dayOfWeek === dayOfWeek).sort((a,b) => a.startTime.localeCompare(b.startTime));
                    
                    // --- 替换从这里开始 ---
                    const upcomingEvents = (contact.events || []).filter(event => {
                        const eventDate = new Date(event.date); 
                        eventDate.setHours(0, 0, 0, 0);

                        if (event.type === 'anniversary') {
                            // --- 周年纪念日逻辑 ---
                            const todayYear = today.getFullYear();
                            // 1. 检查今年的纪念日
                            const thisYearsAnniversary = new Date(todayYear, eventDate.getMonth(), eventDate.getDate());
                            const diffThisYear = (thisYearsAnniversary - today) / (1000 * 60 * 60 * 24);
                            if (diffThisYear >= -1 && diffThisYear <= 7) {
                                return true; // 就在这周！
                            }
                            
                            // 2. 检查明年年初的 (处理跨年)
                            const nextYearsAnniversary = new Date(todayYear + 1, eventDate.getMonth(), eventDate.getDate());
                            const diffNextYear = (nextYearsAnniversary - today) / (1000 * 60 * 60 * 24);
                            if (diffNextYear >= -1 && diffNextYear <= 7) {
                                return true; // 就在下周 (跨年了)！
                            }
                            
                            return false; // 离得太远
                            
                        } else {
                            // --- 原来的逻辑 (用于 'period', 'custom') ---
                            const diffDays = (eventDate - today) / (1000 * 60 * 60 * 24);
                            return diffDays >= -1 && diffDays <= 7;
                        }
                    });
                    // --- 替换到这里结束 ---
                    let reminderPrompt = '';
                    if (todaysSchedule.length > 0) {
                        const scheduleString = todaysSchedule.map(item => `- ${item.startTime}-${item.endTime}: ${item.courseName} (在${item.location || '未知地点'})`).join('\n');
                        reminderPrompt += `\n\n[用户的今日日程]\n这是你正在对话的用户“${state.myProfile.name}”今天的日程安排。请将此作为重要情景信息。\n${scheduleString}`;
                    }
                   // ▼▼▼▼▼ 核心修改点 #2：替换 `eventsString` 的构建逻辑 ▼▼▼▼▼
                    if (upcomingEvents.length > 0) {
                        let eventsString = '';
                        upcomingEvents.forEach(event => {
                            if (event.type === 'period') {
                                 const daysSince = Math.floor((today - new Date(event.date)) / (1000 * 60 * 60 * 24));
                                 if (daysSince >= 0 && daysSince < 7) { 
                                     eventsString += `\n- 根据记录，今天是用户生理期的第 ${daysSince + 1} 天。`;
                                 }
                            } else if (event.type === 'anniversary') {
                                // --- 新增的周年纪念日提示 ---
                                const eventDate = new Date(event.date);
                                let anniversaryYear = today.getFullYear() - eventDate.getFullYear();
                                // 检查今年的周年是否已过
                                const thisYearsAnniversary = new Date(today.getFullYear(), eventDate.getMonth(), eventDate.getDate());
                                if (thisYearsAnniversary < today) {
                                    anniversaryYear += 1; // 如果过了，算的是下一个（明年）的周年
                                }
                                // 格式化日期为 MM-DD
                                const dateString = `${eventDate.getMonth() + 1}月${eventDate.getDate()}日`;
                                eventsString += `\n- ${dateString} 是 “${event.eventName}” (第 ${anniversaryYear} 周年纪念日)。`;
                                // --- 新增结束 ---
                            } else {
                                 // --- 原来的 'custom' 提示 ---
                                 eventsString += `\n- ${event.date} 是 “${event.eventName}”。`;
                            }
                        });
                        if(eventsString) {
                             reminderPrompt += `\n\n[用户近期的重要日子]\n${eventsString}`;
                        }
                    }
                    // ▲▲▲▲▲ 修改结束 ▲▲▲▲▲
                    if (reminderPrompt) {
                        reminderPrompt += `\n\n[情景互动指令] 关于用户的日程与重要日子，这些信息是你记忆的一部分，而不是任务清单。请严格遵循以下原则：
                    1.  **个性化反应**: 你必须结合自己的人设与性格，对这些信息做出独一无二、完全符合你身份的反应。
                    2.  **自然融入**: 不要像闹钟或日程表一样生硬地播报事件。你需要找到对话中最自然的时机，将这些信息作为话题的一部分主动提及。
                    3.  **多样化互动**: 你可以根据这些信息，在事前表达期待或鼓励；在事中表达陪伴；在事后主动询问感受或分享看法；在特殊日子里展现出不同于平时的体贴。你甚至可以根据用户的空闲时间来主动发起新的活动邀请。
                    4.  **核心目标**: 你的最终目标是让用户感觉到，是你——作为一个有独立思想的角色——真正记住了这些事并在乎Ta，而不是一个程序在执行指令。`;
                        systemContent += reminderPrompt;
                    }
                }
                
// (Prompt 更新：增强地图感知与设定约束)
                if (contact && contact.mapId) {
                    const mapData = await kokoMemory.get('maps', contact.mapId);
                    if (mapData) {
                        // 1. 递归构建树形列表 (不变)
                        const buildHierarchyText = (parentId = null, depth = 0) => {
                            const children = (mapData.locations || []).filter(l => (l.parentId || null) === parentId);
                            if (children.length === 0) return '';
                            
                            return children.map(loc => {
                                const indent = '  '.repeat(depth);
                                let text = `${indent}- ${loc.name}: ${loc.description}`;
                                text += buildHierarchyText(loc.id, depth + 1);
                                return '\n' + text;
                            }).join('');
                        };

                        // ▼▼▼ 核心修改：强化地图背景描述 ▼▼▼
                        let mapContextString = `
\n[当前所在世界/地图]
名称: 【${mapData.name}】
宏观环境/世界观设定:
>>>
${mapData.description || '（暂无详细描述，请根据名称自行发挥）'}
<<<
`;
                        
                        const locationTree = buildHierarchyText(null, 0);
                        if (locationTree) {
                            mapContextString += `\n[现有地点结构图]${locationTree}`;
                        } else {
                            mapContextString += '\n[现有地点列表]: (当前地图是一片荒芜，还没有任何地点)';
                        }
                        
                        // ▼▼▼ 核心修改：在指令中增加风格约束 ▼▼▼
                        mapContextString += `
                [地图操作指令]
                1.  **分享位置**: [location:地点名称]
                2.  **创造新地点**: 你可以在地图上建造新场所。
                    * **【重要原则】**: 新地点的名称、功能和描述，必须严格符合上方的【宏观环境/世界观设定】。不要在古代地图建网吧，也不要在科幻地图建茅房。
                    * **层级规则**: 
                        - 如果是独立建筑/地标，parentName 留空。
                        - 如果是内部房间（如在"学校"里建"教室"），必须指定 parentName。
                    * **格式**: [create_location: { "name": "地点名", "description": "符合世界观的描述", "icon": "图标代码", "parentName": "父地点名称(可选)" }]
                
                [图标参考 (Font Awesome)]
                - 建筑: "fas fa-building", "fas fa-store", "fas fa-home", "fas fa-dungeon"
                - 内部: "fas fa-door-closed", "fas fa-bed", "fas fa-scroll", "fas fa-flask"
                `;
                        systemContent += mapContextString;
                    }
                }
                
                // (你原来的视频通话逻辑)
                if (state.activeCall && contact && state.activeCall.contactId === contact.id) {
                     systemContent += `\n\n[！！！当前情境：视频通话！！！]\n你现在正在和用户进行一场视频通话。你必须使用中文。你的所有感官和回应都必须基于这个场景。必须同时穿插使用神态/动作(*...*)、内心活动({...})和对话(“...”)这三种表达方式来描绘通话画面。禁止使用如 [sticker:] 等常规聊天指令。你可以使用的通话专用指令只有：[action:hang_up]。`;
                }
                
                // (你原来的动态指令逻辑)
                const dynamicInstructions = history.filter(msg => msg.sender === 'system_instruction').map(msg => msg.content).join('\n');
                if (dynamicInstructions) { systemContent += `\n\n[附加临时指令]\n${dynamicInstructions}`; }
                
                // (你原来的 history 转换 messages 逻辑，这里是图文支持的关键)
                const messages = [];
                const recentHistory = history
                    .filter(msg => msg.sender !== 'system_instruction' && msg.type !== 'system_notification')
                    .slice(-(contextLength || 20));

                let currentUserMessageParts = [];
                for (const msg of recentHistory) {
                    const role = (msg.sender === 'user') ? 'user' : 'assistant';
                    if (role === 'user') {
                        let textContent = null;
                        
                        if (msg.isRecalled === true) {
                            textContent = `(我撤回了一条消息，但撤回的原文是：“${msg.content}”)`;
                            if (msg.type === 'voice') {
                                textContent = `(我撤回了一条语音，但内容是：“${msg.content.text}”)`;
                            } else if (msg.type === 'picture_description') {
                                textContent = `(我撤回了一张图片，描述是：“${msg.content.description}”)`;
                            } else if (msg.type === 'image' || msg.type === 'uploaded_image') {
                                textContent = `(我撤回了一张图片)`;
                            }
                        } else { 
                            switch (msg.type) {
                                case 'uploaded_image':
                                    currentUserMessageParts.push({ type: 'image_url', image_url: { url: msg.content.base64 } });
                                    break;
                                case 'text':
                                case 'video_call_text':
                                    textContent = msg.content;
                                    if (msg.quote) {
                                        const quoteText = `[用户回复“${msg.quote.senderName}”说的“${msg.quote.content.substring(0, 50)}...”] `;
                                        textContent = quoteText + textContent;
                                    }
                                    break; 
                                case 'html':
                                    const tempDiv = document.createElement('div');
                                    tempDiv.innerHTML = msg.content;
                                    textContent = tempDiv.textContent || tempDiv.innerText || "";
                                    break;
                                case 'game_wheel':
                                    const wheel = msg.content;
                                    const userName = (msg.sender === 'user') ? state.myProfile.name : contact.name;
                                    const contactName = (msg.sender === 'user') ? contact.name : state.myProfile.name;
                                    const optionsText = wheel.options.map(opt => opt.text).join('，');
                                    if (!wheel.results.user) { textContent = `[系统游戏状态更新：游戏“${wheel.name}”已创建。选项：【${optionsText}】。游戏尚未开始，等待玩家操作。]`; } 
                                    else if (wheel.results.user && !wheel.results.contact) { textContent = `[系统游戏状态更新：在游戏“${wheel.name}”中，${userName} 的操作结果为“${wheel.results.user}”。指令：${contactName} 必须执行 spin_wheel 操作。]`; } 
                                    else if (wheel.results.user && wheel.results.contact) { textContent = `[系统游戏状态更新：游戏“${wheel.name}”已结束。最终结果：${userName} -> “${wheel.results.user}”，${contactName} -> “${wheel.results.contact}”。]`; }
                                    break;
                                case 'image':
                                    textContent = msg.isEmoticon && msg.emoticonName ? `[用户发送了表情包: ${msg.emoticonName}]` : '[用户发送了一张图片]';
                                    break; 
                                case 'picture_description':
                                    textContent = `[picture:${msg.content.description}]`;
                                    break;
                                case 'voice':
                                    textContent = `[voice:${msg.content.text}]`;
                                    break;
                                case 'red_packet':
                                    textContent = `[red_packet:${msg.content.blessing}, ${msg.content.amount}]`;
                                    break;
                                case 'transfer':
                                    textContent = `[transfer:${msg.content.amount}]`;
                                    break;
                                case 'music_share':
                                    textContent = `(分享了一首音乐: 《${msg.content.title}》 - ${msg.content.artist})`;
                                    break;
                                case 'location_share':
                                    textContent = `(发送了一个位置，地点是：“${msg.content.name}”)`;
                                    break;
                                case 'post_share':
                                    const post = state.posts.find(p => p.id === msg.content.postId);
                                    textContent = post ? `(分享了一个帖子, 内容是: "${post.content.substring(0, 50)}...")` : `(分享了一个已删除的帖子)`;
                                    break;
                                case 'product_share':
                                    const shareData = msg.content; 
                                    const product = shareData.productDetails;
                                    const intentText = shareData.intent === 'gift' ? '这是送给你的礼物' : '想请你帮忙付一下款';
                                    let details = `(分享了一个商品给你。意图是：“${intentText}”。\n[商品名]: ${product.name}\n[价格]: ${product.price}\n[描述]: ${product.description}`;
                                    if (shareData.accompanyingMessage) {
                                        details += `\n[附言]: "${shareData.accompanyingMessage}"`;
                                    }
                                    details += ')';
                                    textContent = details;
                                    break;
                                                                                                   // ▼▼▼ 在这里粘贴全新的 case ▼▼▼
                            case 'chat_history_share': {
                                const data = msg.content;
                                
                                // 这是一个辅助函数，用来把消息内容转成文字预览
                                const getPreviewText = (msg) => {
                                    switch(msg.type) {
                                        case 'text':
                                        case 'html': return msg.content.replace(/<[^>]+>/g, '');
                                        case 'voice': return `[语音] ${msg.content.text}`;
                                        case 'image':
                                        case 'uploaded_image': return `[图片]${msg.isEmoticon ? msg.emoticonName : ''}`;
                                        case 'picture_description': return `[图片] ${msg.content.description}`;
                                        case 'red_packet': return `[红包] ${msg.content.blessing}`;
                                        case 'transfer': return `[转账] ¥${msg.content.amount}`;
                                        case 'music_share': return `[音乐] ${msg.content.title}`;
                                        case 'location_share': return `[位置] ${msg.content.name}`;
                                        case 'post_share': return `[分享的帖子]`;
                                        case 'product_share': return `[分享的商品] ${msg.content.productDetails.name}`;
                                        default: return `[${msg.type} 消息]`;
                                    }
                                };
                                
                                // 开始把卡片内容“翻译”成AI能懂的文字
                                let historyText = `(你刚刚转发了一份 ${data.sourceChatName} 的聊天记录给我，内容如下：\n`;
                                
                                data.messages.forEach(m => {
                                    const senderName = data.participants[m.sender]?.name || '未知';
                                    const contentPreview = getPreviewText(m);
                                    historyText += `  ${senderName}: ${contentPreview}\n`;
                                });
                                
                                historyText += `)`; // 用括号包起来，告诉AI这是"事件描述"
                                content = historyText;
                                break;
                            }
                            // ▲▲▲ 新 case 粘贴结束 ▲▲▲
                            }
                        }
                        if (textContent) {
                            currentUserMessageParts.push({ type: 'text', text: textContent });
                        }
                    } else {
                // This is the 'assistant' block. THIS IS OUR TARGET.
                if (currentUserMessageParts.length > 0) {
                    messages.push({ role: 'user', content: currentUserMessageParts });
                    currentUserMessageParts = [];
                }
                if (msg.type === 'text' || msg.type === 'html') {
                    
                    // ▼▼▼ ✨✨✨ 叙事模式记忆隔离（更优解） ✨✨✨ ▼▼▼
                    
                    let contentForShortTerm = msg.content;
                    
                    // 1. 检查我们当前是否处于【普通模式】
                    if (contact && contact.isNarrativeMode === false) {
                        
                        // 2. 如果是，就用正则表达式“擦除”所有叙事标记
                        //    只保留最纯粹的对话内容
                        contentForShortTerm = contentForShortTerm
                            .replace(/\{(.*?)\}/g, '')  // 移除 {心理}
                            .replace(/\*(.*?)\*/g, '')  // 移除 *动作*
                            .replace(/“/g, '')         // 移除中文引号（只留内容）
                            .replace(/”/g, '')
                            .replace(/\n/g, ' ')       // 把换行符变空格
                            .trim();                   // 清理首尾空格
                    }
                    
                    // 3. 只有在清理后内容不为空时，才把它加入短期记忆
                    if (contentForShortTerm) {
                        messages.push({ role: 'assistant', content: contentForShortTerm });
                    }
                    
                    // ▲▲▲ ✨✨✨ 修复结束 ✨✨✨ ▲▲▲
                }
            }
                }
                if (currentUserMessageParts.length > 0) {
                    messages.push({ role: 'user', content: currentUserMessageParts });
                }
                
                // (你原来的 requestMessages 赋值)
                requestMessages = [{ role: 'system', content: systemContent }, ...messages];
            
            // ▼▼▼ 6. 'else' 逻辑的结尾 ▼▼▼
            }
            // ▲▲▲ 'else' 逻辑结束 ▲▲▲

            // ▼▼▼ 修改：构建请求体时加入 temperature 和 max_tokens ▼▼▼
            const bodyPayload = { 
                model: model, 
                messages: requestMessages 
            };

            // 1. 添加温度 (如果有设置)
            if (apiConfig.temperature !== null && apiConfig.temperature !== undefined && apiConfig.temperature !== '') {
                bodyPayload.temperature = parseFloat(apiConfig.temperature);
            }

            // 2. 添加最大Token (如果有设置且大于0)
            if (apiConfig.maxTokens && apiConfig.maxTokens > 0) {
                bodyPayload.max_tokens = parseInt(apiConfig.maxTokens, 10);
            }
            // ▲▲▲ 修改结束 ▲▲▲
            
            // (你原来的 fetch 和 API 调用逻辑，完全保持不变)
            try {
                let data;
                if (endpoint.includes('generativelanguage.googleapis.com')) {
                  data = await handleGeminiTranslation(bodyPayload, apiKey);
                } else {
                    const cleanEndpoint = normalizeApiEndpoint(endpoint); 
                    const chatEndpoint = `${cleanEndpoint}/v1/chat/completions`;
                    const response = await fetch(chatEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                        body: JSON.stringify(bodyPayload)
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error ? errorData.error.message : 'Unknown API error');
                    }
                    data = await response.json();
                }
                return data.choices[0].message.content.trim();
            } catch (error) {
                console.error('API调用失败:', error);
                return `抱歉，调用API时遇到问题: ${error.message}`;
            }
        }
        
        // ✨✨✨ 用这个最终的、真正可定制的版本，替换掉 generateRandomTrendingTopicsAI 函数 ✨✨✨
        async function generateRandomTrendingTopicsAI() {
            // 1. 智能读取你当前设置的任何世界观和风格
            const { worldBookIds, styleDescription } = state.forumSettings;
            
            let worldBookPrompt = '';
            if (worldBookIds.length > 0) {
                const booksContent = worldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `--- (世界书: ${book.name}) ---\n${book.content}` : '';
                }).join('\n');
                worldBookPrompt = `\n[全局世界观设定 (来自世界书)]\n${booksContent}\n`;
            }

            let stylePrompt = '';
            if (styleDescription) {
                stylePrompt = `\n[论坛整体风格指令]\n你必须严格遵循以下风格来生成所有内容：\n"${styleDescription}"\n`;
            }

            // 2. 生成一份通用的、引导AI思考的“剧本”，而不是规定死内容的剧本
            const prompt = `[SYSTEM] 你的任务是作为一名创意总监，为你的论坛生成8个符合其独特背景的【热搜事件】。

**[背景资料]**
你必须严格基于以下提供的“世界观”和“风格”来构思词条，确保所有内容都符合这个世界的设定。
${worldBookPrompt || "[注意：当前未提供详细世界观设定。]\n"}
${stylePrompt || "[注意：当前未提供详细风格描述。]\n"}

**[任务要求]**
1.  仔细阅读并深刻理解上方提供的“世界观”和“风格描述”。
2.  基于这个独特的背景，构思出8个最可能在这个世界里引起广泛讨论的热门【具体事件】。
3.  【绝对禁止】生成任何与所提供背景无关的词条，特别是现实世界的现代话题。

**[输出格式]**
对于每一个事件，你必须严格、完整地使用以下格式，并重复8次，每次之间用 "---" 分隔：
TITLE: [这里是热搜标题，通常用##包裹，例如：#千金假死#]
DESCRIPTION: [这里是对该事件的一句话（40字左右）新闻描述，解释发生了什么]
---
`;
            try {
                const response = await generateAiResponse(null, [], prompt, false, 'square');
                // ▼▼▼ 把这段新代码粘贴到原来的位置 ▼▼▼
const newTrendingTopics = [];
const topicRegex = /TITLE:\s*(.*?)\s*\nDESCRIPTION:\s*(.*?)(?:\n---|$)/gs;
let match;

while ((match = topicRegex.exec(response)) !== null) {
    const title = match[1].trim();
    const description = match[2].trim();
    if (title && description) {
        newTrendingTopics.push({ title, description });
    }
}

if (newTrendingTopics.length > 0) {
    state.trendingTopics = newTrendingTopics.slice(0, 8).map((topic, index) => ({
        id: `topic_${Date.now()}_${index}`,
        title: topic.title,
        description: topic.description, // 存储description字段
        heat: Math.floor(Math.random() * 500) + 50,
        tag: index < 2 ? '热' : (index < 4 ? '新' : null)
    })).sort((a, b) => b.heat - a.heat);

    await kokoMemory.clear('trendingTopics');
    await kokoMemory.bulkPut('trendingTopics', state.trendingTopics);
}
// ▲▲▲ 粘贴到这里结束 ▲▲▲

            } catch(e) {
                console.error("AI热搜生成失败:", e);
                throw new Error(`AI热搜生成失败: ${e.message}`);
            }
        }

        async function generatePostsForRecommendedTab(count = 5) {
            const newPosts = await generatePostsBatch(count, state.trendingTopics);
            await generateInitialCommentsForPosts(newPosts);
            state.posts.unshift(...newPosts);
            if (state.posts.length > 200) state.posts = state.posts.slice(0, 200);
            await kokoMemory.clear('posts');
            await kokoMemory.bulkPut('posts', state.posts);
            state.hasNewPosts = true;
            updateNotificationDots();
        }

// ▼▼▼ 步骤九：用这个【完整】的新函数替换旧的 generatePostsBatch ▼▼▼

async function generatePostsBatch(count, topics = []) {
    const category = state.activeFeedSubTab; // e.g., 'daily' 或 'category_123456'
    
    // --- ✨ 核心改造：动态生成板块要求 ---
    let categoryDescription = '';
    
    // 1. 先在固定的板块里找
    const fixedCategoryPrompts = {
        daily: "关于日常生活的趣事、吐槽、嗑cp或避雷经历",
        food: "关于美食的分享、探店、吐槽或避雷指南",
        gossip: "关于人际关系或娱乐圈的八卦讨论或互撕",
        horror: "恐怖小故事或灵异经历",
    };

    if (fixedCategoryPrompts[category]) {
        categoryDescription = fixedCategoryPrompts[category];
    } else {
        // 2. 没找到？去自定义板块里找
        const customCategory = state.forumCategories.find(c => c.id === category);
        if (customCategory) {
            categoryDescription = customCategory.description; // 使用你定义的“要求”
        } else {
            // 3. 哪都没找到（比如数据出错了），给个默认值
            categoryDescription = "一些随机的帖子内容";
        }
    }
    // --- 改造结束 ---

    // (你原来的所有 Persona, WorldBook, Style, Author 等 Prompt 构建逻辑保持不变)
    const { personaId, worldBookIds, styleDescription } = state.forumSettings;
    
    let personaPrompt = '';
    if (personaId) {
        const persona = state.userPersonaPresets.find(p => p.id === personaId);
        if (persona) {
            personaPrompt = `\n[核心用户信息]\n- 核心用户名为: "${state.myProfile.name}"\n- 他/她当前的身份面具是: "${persona.description}"`;
        }
    }

    let worldBookPrompt = '';
    if (worldBookIds.length > 0) {
        const booksContent = worldBookIds.map(id => {
            const book = state.worldBooks.find(b => b.id === id);
            return book ? `--- (世界书: ${book.name}) ---\n${book.content}` : '';
        }).join('\n');
        worldBookPrompt = `\n[全局世界观设定 (来自世界书)]\n${booksContent}\n所有生成的帖子内容都必须严格符合上述世界观设定。`;
    }

    let stylePrompt = '';
    if (styleDescription) {
        stylePrompt = `\n[论坛整体风格指令]\n你必须严格遵循以下风格来生成所有内容：\n"${styleDescription}"`;
    }

    const allowedContacts = state.contacts.filter(c => 
        !c.isGroup && 
        state.forumSettings.allowedPosterIds && 
        state.forumSettings.allowedPosterIds.includes(c.id)
    );
    const authorsWithMemoryPrompt = allowedContacts.map(c => {
        let recentChatHistory = '(最近没有私聊)';
        if (c.history && c.history.length > 0) {
            recentChatHistory = c.history
                .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction')
                .slice(-8)
                .map(msg => `${msg.sender === 'user' ? state.myProfile.name : c.name}: ${msg.content}`)
                .join('\n    ');
        }
        return `- ${c.name} (人设: ${c.persona.replace(/\n/g, ' ')})\n  - [与“${state.myProfile.name}”的近期私聊参考]:\n    \`\`\`\n    ${recentChatHistory}\n    \`\`\``;
    }).join('\n');

    let topicsForPrompt = '';
    if (topics && topics.length > 0) {
        topicsForPrompt = `
[近期热搜事件参考]
当前世界上正在发生以下主要事件，你的帖子内容应该与这些事件有所关联，让世界感觉更真实。
${topics.map(t => `- ${t.title}: ${t.description}`).join('\n')}

[重要指令：话题标签]
在生成帖子内容时，你有大约30%的几率，需要从上面的“热搜事件参考”中选择一个最相关的话题，并以“#话题标题#”的形式，自然地插入到你的帖子正文的末尾。
`;
    }
            
    // --- ✨ 核心改造：将 categoryDescription 注入到 [任务] 中 ---
    const postsPrompt = `[SYSTEM] 你的任务是扮演一个内容生成引擎。
${stylePrompt}
${worldBookPrompt}
${personaPrompt}

[背景设定]
- 论坛上有一个核心用户叫“${state.myProfile.name}”，TA的公开签名是：“${state.myProfile.signature}”。
${topicsForPrompt} 

[任务]
生成 ${count} 条关于“${categoryDescription}”的社交动态。

**[内容多样性指令 (非常重要)]**
为了让论坛感觉更真实、更有活力，你生成的帖子内容应该具有多样性。
- **减少关联性**: 大部分帖子内容应该像是这个世界里独立发生的事件，与核心用户“${state.myProfile.name}”的个人人设、状态或最近的私聊没有直接关系。
- **创造独立故事线**: 鼓励创造一些与用户完全无关的“路人甲”之间的互动和小故事。让他们有自己的生活和烦恼。
- **只有少数内容可以有关联**: 只有一小部分（例如，生成的帖子中不超过1-2条）内容可以与“${state.myProfile.name}”或其熟人（char）的私聊内容有微弱、间接的关联。不要让整个论坛都围绕着用户转！

**[绝对核心规则]**
在本次生成的 ${count} 条动态中，你【必须确保】至少有 3 条是由你原创的、完全不存在于下方“[可选的帖子作者列表]”中的“路人甲”发布的。这是强制性、不可违反的指令。

**[次要规则]**
1. 剩下的动态，你可以从下方的作者列表中选择作者。
2. 你在为某个“可选列表”中的角色创作帖子时，可以参考他/她附带的“[近期私聊参考]”，帖子内容**可以**作为这些私聊的自然延伸或有感而发，但这**不是强制要求**。请优先考虑上方的[内容多样性指令]。
3. 对于同一个“可选列表”中的作者，在本次任务中最多只能使用一次。

[绝对禁止]
你生成的帖子的作者（AUTHOR）绝对不能是核心用户 “${state.myProfile.name}”。

[可选的帖子作者列表及他们的短期记忆]
${authorsWithMemoryPrompt || "- (无联系人信息)"}

[输出格式] 必须严格遵守:
POST_START
AUTHOR: [作者名]
IS_CONTACT: [true或者false]
CONTENT: [动态的具体内容]
POST_END`;
    // --- 改造结束 ---

    // (你原来的 rawPostsResponse 和 postRegex 逻辑保持不变)
    const rawPostsResponse = await generateAiResponse(null, [], postsPrompt, false, 'square');
    const postRegex = /POST_START\s*AUTHOR:\s*(?<author_name>.*?)\s*IS_CONTACT:\s*(?<is_existing_contact>true|false)\s*CONTENT:\s*(?<content>[\s\S]*?)\s*POST_END/g;
    const postMatches = Array.from(rawPostsResponse.matchAll(postRegex));

    if (postMatches.length === 0) throw new Error(`AI未能按格式要求生成任何动态。`);

    let newPosts = [];
    for (const match of postMatches) {
        const { author_name, is_existing_contact, content } = match.groups;
        let authorProfile;
        if (is_existing_contact.trim().toLowerCase() === 'true') {
            const contact = state.contacts.find(c => c.name === author_name.trim());
            if (contact) {
                authorProfile = { id: contact.id, name: contact.name, avatar: contact.avatar, signature: contact.signature };
            }
        }
        if (!authorProfile) {
            authorProfile = {
                id: `stranger_${Date.now()}_${Math.random()}`, name: author_name.trim(),
                avatar: STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)],
                signature: ''
            };
        }
        newPosts.push({
            id: `post_${Date.now()}_${Math.random()}`, author: authorProfile, content: content.trim(),
            category: category, // <-- 核心：确保帖子保存时，带上正确的分类ID
            timestamp: Date.now(),
            likes: [], comments: [], reposts: 0,
            archiveId: state.activeForumArchiveId 
        });
    }
    return newPosts;
}
// ▲▲▲ 替换结束 ▲▲▲

        async function processAiGeneratedComments(rawCommentsResponse, posts, commentRegex) {
            const commentMatches = Array.from(rawCommentsResponse.matchAll(commentRegex));
            const processedComments = [];

            for (const match of commentMatches) {
                const { post_index, commenter_name, reply_to, comment_content } = match.groups;
                const postIndex = parseInt(post_index, 10);

                if (postIndex >= 0 && postIndex < posts.length) {
                    const post = posts[postIndex];
                    let finalCommentContent = comment_content.trim();

                    // 检查是否包含抢红包指令
                    if (finalCommentContent.includes('[抢红包]')) {
                        if (post.redPacket) {
                            if (!post.redPacket.claimers) post.redPacket.claimers = [];
                            
                            const commenterId = `stranger_commenter_${Date.now()}_${Math.random()}`;
                            const hasClaimed = post.redPacket.claimers.some(c => c.userId === commenterId); // 理论上新生成的不会重复
                            const isDepleted = post.redPacket.claimers.length >= post.redPacket.count;

                            if (!isDepleted && !hasClaimed) {
                                // 分配红包金额
                                const remainingCount = post.redPacket.count - post.redPacket.claimers.length;
                                const remainingAmount = post.redPacket.amount - post.redPacket.claimers.reduce((sum, c) => sum + c.amount, 0);
                                
                                let amount = 0;
                                if (remainingCount > 1) {
                                    const avg = remainingAmount / remainingCount;
                                    amount = Math.random() * avg * 1.8; // 增加随机性
                                    amount = Math.min(remainingAmount - (remainingCount - 1) * 0.01, amount);
                                } else {
                                    amount = remainingAmount;
                                }
                                amount = Math.max(0.01, parseFloat(amount.toFixed(2)));

                                post.redPacket.claimers.push({ userId: commenterId, amount: amount });
                                
                                // 替换指令为实际显示内容
                                finalCommentContent = finalCommentContent.replace('[抢红包]', `🧧 领取了红包 (¥${amount.toFixed(2)})`);
                            } else {
                                finalCommentContent = finalCommentContent.replace('[抢红包]', '手慢了，红包派完了！');
                            }
                        } else {
                            // 帖子里没红包，但AI以为有
                            finalCommentContent = finalCommentContent.replace('[抢红包]', ''); 
                        }
                    }
                    
                    processedComments.push({
                        postIndex: postIndex,
                        comment: {
                            id: `comment_${Date.now()}_${Math.random()}`,
                            author: {
                                id: `stranger_commenter_${Date.now()}_${Math.random()}`, name: commenter_name.trim(),
                                avatar: STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)]
                            },
                            content: finalCommentContent,
                            timestamp: post.timestamp + 10000 + (processedComments.length * 1000),
                            replyTo: (reply_to.trim().toLowerCase() === 'null' || reply_to.trim() === '') ? null : reply_to.trim(),
                        }
                    });
                }
            }
            return processedComments;
        }
        
        // ✨✨✨ 用这个新版本，完整替换掉旧的 generateInitialCommentsForPosts 函数 ✨✨✨
        async function generateInitialCommentsForPosts(posts) {
             if (!posts || posts.length === 0) return;
             
            const { personaId, worldBookIds, styleDescription } = state.forumSettings;
            let personaPrompt = '', worldBookPrompt = '', stylePrompt = '';
            if (personaId) {
                const persona = state.userPersonaPresets.find(p => p.id === personaId);
                if (persona) personaPrompt = `\n[核心用户信息]\n- 核心用户名为: "${state.myProfile.name}"\n- 他/她当前的身份面具是: "${persona.description}"`;
            }
            if (worldBookIds.length > 0) {
                const booksContent = worldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `--- (世界书: ${book.name}) ---\n${book.content}` : '';
                }).join('\n');
                worldBookPrompt = `\n[全局世界观设定]\n${booksContent}\n所有生成的评论都必须严格符合上述世界观设定。`;
            }
            if (styleDescription) {
                stylePrompt = `\n[论坛整体风格指令]\n你必须严格遵循以下风格来生成所有内容：\n"${styleDescription}"`;
            }

             const postsForCommentPrompt = posts.map((post, index) => {
                let postInfo = `[POST ${index}] 作者: ${post.author.name}\n内容: ${post.content}`;
                if (post.redPacket) {
                    postInfo += `\n[重要信息：此帖附带一个“${post.redPacket.blessing}”的红包，总额${post.redPacket.amount}元，共${post.redPacket.count}个。]`;
                }
                return postInfo;
            }).join('\n\n');

            const commentsPrompt = `[SYSTEM] 你的任务是扮演一个“吃瓜群众”评论生成引擎，为下面的帖子生成有互动感的评论区。
        ${stylePrompt}
        ${worldBookPrompt}
        ${personaPrompt}
        ---
        ${postsForCommentPrompt}
        ---
        任务: 为以上帖子生成 2 到 4 条随机的、真实的、简短的评论。
        重要：为了让评论区更真实，请让评论之间有互动，即一些评论是回复另一条评论的。

        [红包互动指南]
        如果一个帖子带有[重要信息：此帖附带...红包]，你生成的评论中，应该有一部分人对此作出反应。为了模拟抢红包的动作，请在他们的评论内容中加入特殊指令 "[抢红包]"。

        **[绝对禁止]**
        **你生成的评论作者（COMMENTER）的名字绝对不能是核心用户“${state.myProfile.name}”。**
        **评论作者也不能是正在被评论的帖子的作者本人。**

        对于每一条评论，必须严格、完整地使用以下格式：
        COMMENT_START
        INDEX: [评论指向的帖子编号]
        COMMENTER: [随机想一个真实的中文网名]
        REPLY_TO: [被回复的评论者名字，如果没有则为null]
        COMMENT: [评论内容，可能包含[抢红包]]
        COMMENT_END`;

            const rawCommentsResponse = await generateAiResponse(null, [], commentsPrompt, false, 'square');
            const commentRegex = /COMMENT_START\s*INDEX:\s*(?<post_index>\d+)\s*COMMENTER:\s*(?<commenter_name>.*?)\s*REPLY_TO:\s*(?<reply_to>.*?)\s*COMMENT:\s*(?<comment_content>[\s\S]*?)\s*COMMENT_END/g;
            
            const processedComments = await processAiGeneratedComments(rawCommentsResponse, posts, commentRegex);

            processedComments.forEach(({ postIndex, comment }) => {
                posts[postIndex].comments.push(comment);
            });
            
            posts.forEach(p => p.comments.sort((a,b) => a.timestamp - b.timestamp));
        }
        
// ==========================================================
// =========== ▼▼▼ 方案B：最终修复版 ▼▼▼ ============
// ==========================================================
//
//  请用下面这个【完整函数】，替换掉你旧的 generateMoreCommentsForPost 函数
//
async function generateMoreCommentsForPost(post) {
    // 1. 获取并构建论坛设置的 Prompt 片段 (和我们修复过的 triggerAiCommentDiscussion 内部逻辑一致)
    const { personaId, worldBookIds, styleDescription } = state.forumSettings;
    let personaPrompt = '', worldBookPrompt = '', stylePrompt = '';
    
    if (personaId) {
        const persona = state.userPersonaPresets.find(p => p.id === personaId);
        if (persona) {
            personaPrompt = `
[核心用户信息 (仅供参考)]
- 核心用户名为: "${state.myProfile.name}"
- 他/她当前的身份面具是: "${persona.description}"
[重要提示]：你【绝对不能】使用这个身份面具来【创建新的评论】或【扮演用户】。
`;
        }
    }
    if (worldBookIds.length > 0) {
        const booksContent = worldBookIds.map(id => {
            const book = state.worldBooks.find(b => b.id === id);
            return book ? `--- (世界书: ${book.name}) ---\n${book.content}` : '';
        }).join('\n');
        worldBookPrompt = `\n[全局世界观设定]\n${booksContent}\n所有生成的评论都必须严格符合上述世界观设定。`;
    }
    if (styleDescription) {
        stylePrompt = `\n[论坛整体风格指令]\n你必须严格遵循以下风格来生成所有内容：\n"${styleDescription}"`;
    }

    // 2. 构建帖子信息 (和 triggerAiCommentDiscussion 内部逻辑一致)
    let postInfoForPrompt = `- 帖子作者: "${post.author.name}"\n- 帖子内容: "${post.content}"`;
    if (post.redPacket) {
        const remainingPackets = post.redPacket.count - (post.redPacket.claimers ? post.redPacket.claimers.length : 0);
        postInfoForPrompt += `\n- [红包信息]：此帖附带红包，祝福语“${post.redPacket.blessing}”，目前剩余 ${remainingPackets} 个。`;
    }

    // 3. 构建 System Prompt (系统提示词)
    const systemPrompt = `[SYSTEM] 你是社交媒体讨论模拟器。你的任务是为下方提供的【图文帖子】和【现有评论】生成 2-3 条新的“路人甲”评论，让讨论继续下去。
${stylePrompt}
${worldBookPrompt}
${personaPrompt}

[主帖子信息]
${postInfoForPrompt}

[红包互动指南]
如果帖子有[红包信息]，你的角色在回复时可以尝试抢红包。若要模拟抢红包，请在评论内容中加入特殊指令 "[抢红包]"。

[绝对禁止的作者名]
在你的任何回复中，你生成的评论作者（COMMENTER）的【名字】绝对不能是核心用户 “${state.myProfile.name}”，也不能是帖子作者“${post.author.name}”。

[输出格式] 必须严格遵守 (每条评论一行):
COMMENTER: [随机想一个真实的中文网名] | REPLY_TO: [null 或 现有评论者名字] | COMMENT: [评论内容]`;

    // 4. 构建核心的 'messages' 数组 (这是最关键的改动)
    const messages = [];
    const userMessageParts = [];

    // 4a. 把所有 *现有评论* 作为上下文
    const existingComments = post.comments.map(c => `- ${c.author.name}: ${c.content}`).join('\n');
    userMessageParts.push({
        type: "text",
        text: `[这是你要评论的帖子文字]：\n"${post.content}"\n\n[这是【已经存在】的评论区，请你接着他们的话题聊]：\n${existingComments || '(还没有评论)'}`
    });
    
    // 4b. 【核心修复】把帖子的图片加进去！
    if (post.image) {
        userMessageParts.push({
            type: "text",
            text: "\n[这是原帖的图片，你的新评论必须参考它：]"
        });
        userMessageParts.push({
            type: "image_url",
            image_url: { url: post.image } // post.image 里存的就是Base64
        });
    }

    // 4c. 最终任务指令
    userMessageParts.push({
        type: "text",
        text: "\n\n[你的任务]：请根据以上所有信息（尤其是图片和现有评论），生成 2-3 条新的 AI 评论。必须严格遵守输出格式！"
    });

    // 4d. 组合
    messages.push({ role: "user", content: userMessageParts });
    const finalRequestMessages = [
        { role: "system", content: systemPrompt },
        ...messages
    ];

    // 5. 【核心修复】调用 "Vision" 路径的 AI (即 generateAiResponse 的“后门”版本)
    const rawResponse = await generateAiResponse(
        null,                   // contact (不需要)
        [],                     // history (不需要)
        null,                   // customSystemPrompt (不需要)
        false,                  // forceDiary (不需要)
        'square',               // apiType (必须是论坛API)
        finalRequestMessages    // ★★★ 我们的图文混合消息 ★★★
    );
    
    // 6. 解析和保存评论 (这部分逻辑和 triggerAiCommentDiscussion 几乎一样)
    const commentRegex = /COMMENTER:\s*(?<commenter_name>.*?)\s*\|\s*REPLY_TO:\s*(?<reply_to>.*?)\s*\|\s*COMMENT:\s*(?<comment_content>[\s\S]*?)(?:\n|$)/g;
    const matches = Array.from(rawResponse.matchAll(commentRegex)); 

    if (matches.length > 0) {
         for (const match of matches) {
            if (!match.groups) continue;
            const { commenter_name, reply_to, comment_content } = match.groups;
            
            let commenterProfile = state.contacts.find(c => c.name === commenter_name.trim());
            if (!commenterProfile) {
                commenterProfile = {
                    id: `stranger_commenter_${Date.now()}_${Math.random()}`,
                    name: commenter_name.trim(),
                    avatar: STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)]
                };
            }
            
            let finalCommentContent = comment_content.trim();
            
            // (红包逻辑)
            if (finalCommentContent.includes('[抢红包]')) {
                if (post.redPacket) {
                     if (!post.redPacket.claimers) post.redPacket.claimers = [];
                     const commenterId = commenterProfile.id; // 用生成的ID
                     const hasClaimed = post.redPacket.claimers.some(c => c.userId === commenterId);
                     const isDepleted = post.redPacket.claimers.length >= post.redPacket.count;

                     if (!isDepleted && !hasClaimed) {
                        const remainingCount = post.redPacket.count - post.redPacket.claimers.length;
                        const remainingAmount = post.redPacket.amount - post.redPacket.claimers.reduce((sum, c) => sum + c.amount, 0);
                        let amount = 0;
                        if (remainingCount > 1) {
                            const avg = remainingAmount / remainingCount;
                            amount = Math.random() * avg * 1.8;
                            amount = Math.min(remainingAmount - (remainingCount-1)*0.01, amount);
                        } else {
                            amount = remainingAmount;
                        }
                        amount = Math.max(0.01, parseFloat(amount.toFixed(2)));
                        post.redPacket.claimers.push({ userId: commenterId, amount: amount });
                        finalCommentContent = finalCommentContent.replace('[抢红包]', `🧧 领取了红包 (¥${amount.toFixed(2)})`);
                     } else {
                        finalCommentContent = finalCommentContent.replace('[抢红包]', '手慢了，红包派完了！');
                     }
                } else {
                    finalCommentContent = finalCommentContent.replace('[抢红包]', ''); 
                }
            }
            
             post.comments.push({
                id: `comment_${Date.now()}_${Math.random()}`,
                author: commenterProfile,
                content: finalCommentContent,
                timestamp: Date.now() + matches.indexOf(match) * 100, // 评论时间戳
                replyTo: (reply_to.trim().toLowerCase() === 'null' || reply_to.trim() === '') ? null : reply_to.trim(),
            });
        }
        
        // 注意：我们不再从这个函数内部调用数据库和渲染
        // 这些操作留给外层的 `refresh-post-comments-btn` 监听器去做
        // 所以我们只管返回 true 表示成功
        return true; 
    }
    
    // 如果AI没有返回任何有效评论
    return false;
}
// ==========================================================
// =========== ▲▲▲ 方案B：最终修复版 END ▲▲▲ ============
// ==========================================================
// ✨✨✨ 这是你需要粘贴的【辅助函数】 ✨✨✨
const formatContactInfo = (contact, role, userComment) => {
    const userPersona = contact.userPersona ? `你（${contact.name}）和用户“${userComment.author.name}”的私人关系是：“${contact.userPersona}”。` : `你（${contact.name}）和用户“${userComment.author.name}”是普通网友。`;
    let recentChatHistory = '(暂无私聊记录)';
    if (contact && contact.history && contact.history.length > 0) {
        recentChatHistory = contact.history
            .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction')
            .slice(-35)
            .map(msg => `${msg.sender === 'user' ? userComment.author.name : contact.name}: ${msg.content}`)
            .join('\n');
    }
    
    // 注意：这个函数现在会返回一个对象，而不是直接修改外部变量
    return {
        figureInfo: `\n- ${role}: "${contact.name}" (人设: "${contact.persona || '普通人'}")`,
        relationshipInfo: `\n[${role} “${contact.name}” 的详细资料]\n- ${userPersona}\n- [近期私聊参考]:\n\`\`\`\n${recentChatHistory}\n\`\`\``
    };
};        
// --- (替换) 触发 AI 评论函数 (V3.0 - 支持多模态 Vision) ---
        async function triggerAiCommentDiscussion(post, userComment) {
            showFeedStatus('正在生成AI回复...');
            try {
                // 1. 获取并构建论坛设置的 Prompt 片段 (这部分不变)
                const { personaId, worldBookIds, styleDescription } = state.forumSettings;
                let personaPrompt = '', worldBookPrompt = '', stylePrompt = '';
                
                if (personaId) {
                    const persona = state.userPersonaPresets.find(p => p.id === personaId);
                    if (persona) {
                        personaPrompt = `
[核心用户信息 (仅供参考)]
- 核心用户名为: "${state.myProfile.name}"
- 他/她当前的身份面具是: "${persona.description}"
[重要提示]：以上用户信息是AI角色在与用户互动时，对用户的【背景认知】。
你【绝对不能】使用这个身份面具来【创建新的评论】或【扮演用户】。
`;
                    }
                }

                if (worldBookIds.length > 0) {
                    const booksContent = worldBookIds.map(id => {
                        const book = state.worldBooks.find(b => b.id === id);
                        return book ? `--- (世界书: ${book.name}) ---\n${book.content}` : '';
                    }).join('\n');
                    worldBookPrompt = `\n[全局世界观设定]\n${booksContent}\n所有生成的评论都必须严格符合上述世界观设定。`;
                }
                if (styleDescription) {
                    stylePrompt = `\n[论坛整体风格指令]\n你必须严格遵循以下风格来生成所有内容：\n"${styleDescription}"`;
                }

                // 2. 识别被回复的角色和可能的互动角色 (这部分不变)
                let mentionedContact = null;
                const mentionRegex = /@([\w\u4e00-\u9fa5]+)/g;
                const mentionMatch = mentionRegex.exec(userComment.content);
                if (mentionMatch) {
                    const mentionedName = mentionMatch[1];
                    mentionedContact = state.contacts.find(c => c.name === mentionedName);
                }

                let mandatoryResponder = mentionedContact;
                if (!mandatoryResponder && userComment.replyTo) {
                    const originalComment = post.comments.find(c => c.author.name === userComment.replyTo);
                    if (originalComment) {
                        const repliedToContact = state.contacts.find(c => c.id === originalComment.author.id);
                        if (repliedToContact && repliedToContact.id !== 'myProfile') {
                            mandatoryResponder = repliedToContact;
                        }
                    }
                }
                
                let possibleResponders = state.contacts.filter(c =>
                    c.id !== userComment.author.id && 
                    !c.isGroup && 
                    state.forumSettings.allowedPosterIds && 
                    state.forumSettings.allowedPosterIds.includes(c.id) 
                );

                if (mandatoryResponder) {
                    possibleResponders = possibleResponders.filter(c => c.id !== mandatoryResponder.id);
                }

                let guestResponder = null;
                if (possibleResponders.length > 0 && Math.random() < 0.3) {
                    guestResponder = possibleResponders[Math.floor(Math.random() * possibleResponders.length)];
                }

                // 3. 构建角色档案和关系信息 (这部分不变)
                let notableFiguresForPrompt = `\n[本楼出场人物信息]\n- 主帖作者: "${post.author.name}" (人设: "${post.author.persona || '普通人'}")`;
                let relationshipInfoForPrompt = '';
                
                if (mandatoryResponder) {
                    const formatted = formatContactInfo(mandatoryResponder, '必出场角色 (被@或被回复)', userComment);
                    notableFiguresForPrompt += formatted.figureInfo;
                    relationshipInfoForPrompt += formatted.relationshipInfo;
                }
                if (guestResponder) {
                    const formatted = formatContactInfo(guestResponder, '可能客串的熟人', userComment);
                    notableFiguresForPrompt += formatted.figureInfo;
                    relationshipInfoForPrompt += formatted.relationshipInfo;
                }
                
                if (!relationshipInfoForPrompt) {
                    relationshipInfoForPrompt = "[可参与讨论的角色信息]\n---（本次没有特定的熟人需要出场）---\n";
                } else {
                    relationshipInfoForPrompt = "[可参与讨论的角色信息]\n---" + relationshipInfoForPrompt + "\n---";
                }

                const conversationHistory = post.comments.filter(c => c.author.id === userComment.author.id || (mandatoryResponder && c.author.id === mandatoryResponder.id) || (guestResponder && c.author.id === guestResponder.id)).sort((a, b) => a.timestamp - b.timestamp).slice(-10);
                const conversationHistoryForPrompt = conversationHistory.map(c => `- ${c.author.name}: ${c.content}`).join('\n');
                
                // 4. 构建帖子信息 (这部分不变)
                let postInfoForPrompt = `- 帖子作者: "${post.author.name}"\n- 帖子内容: "${post.content}"`;

                if (post.redPacket) {
                    const remainingPackets = post.redPacket.count - (post.redPacket.claimers ? post.redPacket.claimers.length : 0);
                    postInfoForPrompt += `\n- [红包信息]：此帖附带红包，祝福语“${post.redPacket.blessing}”，目前剩余 ${remainingPackets} 个。`;
                }

                // 5. ▼▼▼ 最大的改动：构建 System Prompt 和 Messages Array ▼▼▼
                
                // 5a. 构建 System Prompt (把所有规则和背景都塞进去)
                const systemPrompt = `[SYSTEM] 你是社交媒体讨论模拟器。
${stylePrompt}
${worldBookPrompt}
${personaPrompt}

[主帖子信息]
${postInfoForPrompt}

[最近的评论对话历史]
${conversationHistoryForPrompt}

${relationshipInfoForPrompt}

[重要规则：红包互动]
如果帖子有[红包信息]，你的角色在回复时可以尝试抢红包。若要模拟抢红包，请在评论内容中加入特殊指令 "[抢红包]"。

[重要规则：路人甲的反应逻辑]
${notableFiguresForPrompt}
当你要扮演一个原创的“路人甲”进行评论时，你必须优先检查上方“本楼出场人物信息”列表里所有角色的人设。如果他们中有人设包含“明星”、“名人”等具有公众辨识度的身份，你扮演的“路人甲”在评论时，【有较高概率】应该体现出已经认识或认出了TA。

[你的任务 - 重要！]
1.  **优先回复**: 如果存在“[必出场角色]”，你的第一条或第二条回复**必须**由他/她发出。
2.  **选择性客串**: 如果存在“[可能客串的熟人]”，**仅当**你觉得他/她的人设符合其人设且能让讨论更有趣时，才让他/她加入。这是**可选的**。
3.  **营造真实感**: 剩下的回复名额，请**务必优先使用你原创的、符合当下场景的“路人甲”**来填充。
4.  **严格遵守格式**: 所有回复都必须严格遵守 \`COMMENTER: [名字] | REPLY_TO: [回复对象] | COMMENT: [内容]\` 格式。

[绝对禁止的作者名]
在你的任何回复中，你生成的评论作者（COMMENTER）的【名字】绝对不能是核心用户 “${userComment.author.name}”。
你也绝对不能扮演用户 “${userComment.author.name}” 的角色来发言。
`;

// 5b. 构建核心的 'messages' 数组
const messages = [];

// 5c. 【核心！】构建用户的图文评论
const userCommentParts = [];

// ▼▼▼ 在这里添加新代码 ▼▼▼
if (post.image) {
    // 1. 告诉 AI 这是主楼的图片
    userCommentParts.push({
        type: "text",
        text: "[这是你正在评论的【原帖】附带的图片，请参考它：]"
    });
    // 2. 把主楼的图片(Base64)传给AI
    userCommentParts.push({
        type: "image_url",
        image_url: {
            url: post.image // 'post.image' 里存的就是Base64
        }
    });
    // 3. 告诉 AI 接下来是用户的评论
    userCommentParts.push({
        type: "text",
        text: "[以下是用户对这个帖子（和你刚看到的图片）的评论：]"
    });
}
// ▲▲▲ 新代码添加结束 ▲▲▲
                
                // 5c-1. 添加回复的上下文（如果有的话）
                let textContent = userComment.content;
                if (userComment.replyTo) {
                    const originalComment = post.comments.find(c => c.author.name === userComment.replyTo);
                    if (originalComment) {
                        textContent = `(回复 @${userComment.replyTo}: "${originalComment.content}") ${userComment.content}`;
                    }
                }
                
                // 5c-2. 添加评论的文字部分
                if (textContent) {
                    userCommentParts.push({
                        type: "text",
                        text: textContent
                    });
                }
                
                // 5c-3. 【关键！】添加评论的图片部分
                if (userComment.image) {
                    // 告诉AI，用户发的是一张图片
                    userCommentParts.push({
                        type: "text",
                        text: "[用户在评论中附带了下面这张图片]"
                    });
                    userCommentParts.push({
                        type: "image_url",
                        image_url: {
                            url: userComment.image // 把Base64字符串传进去
                        }
                    });
                }
                
// 5d. ▼▼▼ 核心修复 ▼▼▼
                // 把最后的指令性消息，也塞进 userCommentParts，合并成一条 user 消息
                userCommentParts.push({
                    type: "text",
                    text: "\n\n[你的任务]：请根据以上所有信息（尤其是我的评论和图片），生成 2-3 条新的 AI 评论。必须严格遵守输出格式！"
                });
                
                // 5e. 现在，只添加这唯一的一条、包含所有内容（文字、图片、指令）的 user 消息
                messages.push({ role: "user", content: userCommentParts });

                // 5f. 组合成最终的请求数组
                const finalRequestMessages = [
                    { role: "system", content: systemPrompt },
                    ...messages
                ];
                
                // 6. ▼▼▼ 核心调用：使用“后门”参数 ▼▼▼
                const rawResponse = await generateAiResponse(
                    null,                   // contact (不需要)
                    [],                     // history (不需要)
                    null,                   // customSystemPrompt (不需要)
                    false,                  // forceDiary (不需要)
                    'square',               // apiType (必须是论坛API)
                    finalRequestMessages    // ★★★ 我们的图文混合消息 ★★★
                );
                
                // (后续的 AI 回复解析逻辑保持不变)
                const commentRegex = /COMMENTER:\s*(?<commenter_name>.*?)\s*\|\s*REPLY_TO:\s*(?<reply_to>.*?)\s*\|\s*COMMENT:\s*(?<comment_content>[\s\S]*?)(?:\n|$)/g;
                const matches = Array.from(rawResponse.matchAll(commentRegex)); 

                if (matches.length > 0) {
                     for (const match of matches) {
                        if (!match.groups) continue;
                        const {
                            commenter_name,
                            reply_to,
                            comment_content
                        } = match.groups;

                        let commenterProfile = state.contacts.find(c => c.name === commenter_name.trim());
                        if (!commenterProfile) {
                            commenterProfile = {
                                id: `stranger_commenter_${Date.now()}_${Math.random()}`,
                                name: commenter_name.trim(),
                                avatar: STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)]
                            };
                        }
                        
                        let finalCommentContent = comment_content.trim();
                        
                        // (红包逻辑保持不变)
                        if (finalCommentContent.includes('[抢红包]')) {
                            if (post.redPacket) {
                                 if (!post.redPacket.claimers) post.redPacket.claimers = [];
                                 const hasClaimed = post.redPacket.claimers.some(c => c.userId === commenterProfile.id);
                                 const isDepleted = post.redPacket.claimers.length >= post.redPacket.count;

                                 if (!isDepleted && !hasClaimed) {
                                    const remainingCount = post.redPacket.count - post.redPacket.claimers.length;
                                    const remainingAmount = post.redPacket.amount - post.redPacket.claimers.reduce((sum, c) => sum + c.amount, 0);
                                    let amount = 0;
                                    if (remainingCount > 1) {
                                        const avg = remainingAmount / remainingCount;
                                        amount = Math.random() * avg * 1.8;
                                        amount = Math.min(remainingAmount - (remainingCount-1)*0.01, amount);
                                    } else {
                                        amount = remainingAmount;
                                    }
                                    amount = Math.max(0.01, parseFloat(amount.toFixed(2)));
                                    post.redPacket.claimers.push({ userId: commenterProfile.id, amount: amount });
                                    finalCommentContent = finalCommentContent.replace('[抢红包]', `🧧 领取了红包 (¥${amount.toFixed(2)})`);
                                 } else {
                                    finalCommentContent = finalCommentContent.replace('[抢红包]', '手慢了，红包派完了！');
                                 }
                            } else {
                                finalCommentContent = finalCommentContent.replace('[抢红包]', ''); 
                            }
                        }
                        
                         post.comments.push({
                            id: `comment_${Date.now()}_${Math.random()}`,
                            author: commenterProfile,
                            content: finalCommentContent,
                            timestamp: Date.now() + matches.indexOf(match) * 100,
                            replyTo: reply_to.trim(),
                        });
                    }
                    await kokoMemory.put('posts', post);
                    if (state.activePostId === post.id) {
                        await renderPostDetail();
                    }
                }
            } catch (e) {
                console.error("生成AI评论讨论失败:", e);
                alert("AI评论生成失败：" + e.message); // 增加 alert 提示
            } finally {
                hideFeedStatus();
            }
        }
        
        // --- MODIFIED V7.0: 增加分享音乐选项 ---
        // ▼▼▼ 新版本：renderAttachmentMenu ▼▼▼
function renderAttachmentMenu() {
    const menu = document.getElementById('attachment-menu');
    menu.innerHTML = `
        <div class="attachment-menu-item" data-action="send-picture">
            <div class="icon-wrapper"><i class="fas fa-image"></i></div>
            <div class="label">图片</div>
        </div>
        <div class="attachment-menu-item" data-action="send-voice">
            <div class="icon-wrapper"><i class="fas fa-microphone"></i></div>
            <div class="label">语音</div>
        </div>
        <div class="attachment-menu-item" data-action="send-red-packet">
            <div class="icon-wrapper"><i class="fas fa-wallet"></i></div>
            <div class="label">红包</div>
        </div>
        <div class="attachment-menu-item" data-action="send-transfer">
            <div class="icon-wrapper"><i class="fas fa-exchange-alt"></i></div>
            <div class="label">转账</div>
        </div>
        <div class="attachment-menu-item" data-action="share-music">
            <div class="icon-wrapper"><i class="fas fa-music"></i></div>
            <div class="label">音乐</div>
        </div>
        <div class="attachment-menu-item" data-action="game-wheel"> <div class="icon-wrapper"><i class="fas fa-bullseye"></i></div> <div class="label">转盘游戏</div> 
        </div>
        <div class="attachment-menu-item" data-action="start-video-call">
            <div class="icon-wrapper"><i class="fas fa-video"></i></div>
            <div class="label">视频通话</div>
        </div>
    `;
}
        // ↓↓↓ 把这个全新的函数整个粘贴进去 ↓↓↓
function addWheelOptionInput(text = '', weight = 1) {
    const container = document.getElementById('wheel-options-container');
    const newItem = document.createElement('div');
    newItem.className = 'wheel-option-item';
    newItem.innerHTML = `
        <input type="text" class="contact-form-input wheel-option-text" value="${text}" placeholder="选项内容">
        <input type="number" class="contact-form-input wheel-option-weight" value="${weight}" min="1" title="权重(份数)">
        <button class="delete-option-btn">&times;</button>
    `;
    container.appendChild(newItem);
    newItem.querySelector('.delete-option-btn').addEventListener('click', () => {
        // 至少保留2个选项
        if (container.children.length > 2) {
            newItem.remove();
        } else {
            alert('转盘至少需要2个选项哦！');
        }
    });
}
// ↑↑↑ 新增代码结束 ↑↑↑

        // --- MODIFIED V7.0: 增加处理分享音乐的逻辑 ---
        function handleAttachmentAction(action) {
            const menu = document.getElementById('attachment-menu');
            menu.classList.remove('active');

            const addOneTimeListener = (buttonId, callback) => {
                const oldBtn = document.getElementById(buttonId);
                const newBtn = oldBtn.cloneNode(true);
                oldBtn.parentNode.replaceChild(newBtn, oldBtn);
                newBtn.addEventListener('click', callback);
            };

            switch(action) {
                // 在 handleAttachmentAction 函数的 switch 语句中
case 'send-location': { // 假设你给附件菜单里的位置按钮加了 data-action="send-location"
    const contact = state.contacts.find(c => c.id === state.activeChatId);

    // 【核心检查】
    if (!contact || !contact.mapId) {
        alert('要发送位置，请先在“更多信息”中为该联系人关联一张地图。');
        return;
    }

    // 打开地点选择器
    openLocationPicker(contact.mapId);
    break;
}
case 'upload-image': document.getElementById('image-upload-input').click(); break;
                case 'send-picture': {
                    const modal = document.getElementById('send-picture-modal');
                    const descriptionInput = document.getElementById('send-picture-description-input');
                    descriptionInput.value = '';
                    modal.style.display = 'flex';
                    addOneTimeListener('confirm-send-picture-btn', async () => {
                        const description = descriptionInput.value.trim();
                        if (description) {
                            await createAndAddMessage({ type: 'picture_description', content: { description } });
                            modal.style.display = 'none';
                        }
                    });
                    break;
                }
                // 在 handleAttachmentAction 函数中...

// ... 其他 case ...
case 'send-group-transfer': {
    const group = state.contacts.find(c => c.id === state.activeChatId);
    if (!group || !group.isGroup) break;

    const modal = document.getElementById('group-transfer-recipient-picker-modal');
    const recipientListEl = document.getElementById('group-transfer-recipient-list');
    const amountInput = document.getElementById('group-transfer-amount-input');
    amountInput.value = '';
    recipientListEl.innerHTML = '';
    
    // 动态加载群成员 (排除自己)
    group.members.forEach(memberId => {
        if (memberId === 'myProfile') return;
        const member = state.contacts.find(c => c.id === memberId);
        if (member) {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            // 使用 radio button 确保只能选一个
            item.innerHTML = `
                <input type="radio" id="recipient-radio-${member.id}" name="group-recipient" value="${member.id}">
                <label for="recipient-radio-${member.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                    <img src="${member.avatar}" alt="${member.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                    <span>${member.name}</span>
                </label>
            `;
            recipientListEl.appendChild(item);
        }
    });

    modal.style.display = 'flex';

    document.getElementById('close-group-transfer-picker-modal').addEventListener('click', () => {
        modal.style.display = 'none';
    }, { once: true });

    addOneTimeListener('confirm-group-transfer-btn', async () => {
        const selectedRadio = document.querySelector('input[name="group-recipient"]:checked');
        if (!selectedRadio) {
            return alert('请选择一个收款人！');
        }
        const recipientId = selectedRadio.value;
        const amount = parseFloat(amountInput.value);

        if (isNaN(amount) || amount <= 0) {
            return alert('请输入有效的转账金额！');
        }
        if (state.myProfile.balance < amount) {
            return alert('钱包余额不足！');
        }
        
        state.myProfile.balance -= amount;
        const recipient = state.contacts.find(c => c.id === recipientId);
        await addTransaction('expense', amount, `在群聊中转账给 ${recipient.name}`, group.id);
        
        // 创建一个新的转账消息，带有收款人信息
        await createAndAddMessage({
            type: 'transfer',
            content: {
                amount: amount.toFixed(2),
                completed: false,
                returned: false,
                recipientId: recipientId // 关键信息！
            }
        });

        renderMyProfile();
        await kokoMemory.put('myProfile', state.myProfile);
        modal.style.display = 'none';
    });
    break;
}
                case 'send-voice': {
                    const modal = document.getElementById('send-voice-modal');
                    const voiceTextInput = document.getElementById('send-voice-text-input');
                    voiceTextInput.value = '';
                    modal.style.display = 'flex';
                    addOneTimeListener('confirm-send-voice-btn', async () => {
                        const voiceText = voiceTextInput.value.trim();
                        if (voiceText) {
                            const duration = Math.max(1, Math.round(voiceText.length / 4));
                            await createAndAddMessage({ type: 'voice', content: { duration, text: voiceText } });
                            modal.style.display = 'none';
                        }
                    });
                    break;
                }
                // 在 handleAttachmentAction 函数中...

case 'send-red-packet': {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) break;

    const modal = document.getElementById('send-red-packet-modal');
    // 动态修改弹窗，以适应群聊和私聊
    const modalBody = modal.querySelector('.modal-body');
    
    let amountInputHTML = `
        <div class="contact-form-group">
            <label class="contact-form-label">金额 (元)</label>
            <input type="number" class="contact-form-input" id="send-red-packet-amount-input" placeholder="0.00">
        </div>`;
    
    let countInputHTML = '';
    // 如果是群聊，增加“红包个数”输入框
    if (contact.isGroup) {
        countInputHTML = `
            <div class="contact-form-group">
                <label class="contact-form-label">红包个数</label>
                <input type="number" class="contact-form-input" id="send-red-packet-count-input" placeholder="填写个数，比如10">
            </div>`;
    }

    modalBody.innerHTML = `
        ${amountInputHTML}
        ${countInputHTML}
        <div class="contact-form-group">
            <label class="contact-form-label">祝福语 (可选)</label>
            <input type="text" class="contact-form-input" id="send-red-packet-blessing-input" placeholder="恭喜发财，大吉大利！">
        </div>
        <button class="form-button" id="confirm-send-red-packet-btn" style="background-color: #E64340;">塞钱进红包</button>
    `;
    
    modal.style.display = 'flex';
    
    addOneTimeListener('confirm-send-red-packet-btn', async () => {
        const amount = parseFloat(document.getElementById('send-red-packet-amount-input').value);
        const blessing = document.getElementById('send-red-packet-blessing-input').value.trim() || "恭喜发财，大吉大利！";
        
        if (isNaN(amount) || amount <= 0) {
            return alert("请输入有效的金额！");
        }
        if (state.myProfile.balance < amount) {
            return alert('钱包余额不足！');
        }

        // 核心逻辑分离
        if (contact.isGroup) {
            // 群聊逻辑
            const countInput = document.getElementById('send-red-packet-count-input');
            const count = parseInt(countInput.value, 10);
            if (isNaN(count) || count <= 0) {
                return alert("请输入有效的红包个数！");
            }
            if (amount / count < 0.01) {
                return alert("单个红包金额不能低于0.01元！");
            }

            state.myProfile.balance -= amount;
            await addTransaction('expense', amount, `在群聊"${contact.name}"中发红包`, contact.id);

            await createAndAddMessage({
                type: 'red_packet',
                content: {
                    totalAmount: amount,
                    count: count,
                    blessing: blessing,
                    claimers: [] // 初始化领取者列表
                }
            });

        } else {
            // 私聊逻辑 (不变)
            state.myProfile.balance -= amount;
            await addTransaction('expense', amount, `发红包给 ${contact.name}`, contact.id);

            await createAndAddMessage({
                type: 'red_packet',
                content: {
                    amount: amount.toFixed(2), // 私聊是单个红包
                    blessing: blessing,
                    opened: false
                }
            });
        }
        
        renderMyProfile();
        await kokoMemory.put('myProfile', state.myProfile);
        modal.style.display = 'none';
    });
    break;
}
                case 'send-transfer': {
                    const modal = document.getElementById('send-transfer-modal');
                    const amountInput = document.getElementById('send-transfer-amount-input');
                    amountInput.value = '';
                    modal.style.display = 'flex';
                    addOneTimeListener('confirm-send-transfer-btn', async () => {
                        const transferAmount = parseFloat(amountInput.value);
                        if (!isNaN(transferAmount) && transferAmount > 0) {
                            if(state.myProfile.balance < transferAmount) {
                                alert('钱包余额不足！');
                                return;
                            }
                            state.myProfile.balance -= transferAmount;
                            await addTransaction('expense', transferAmount, `转账给 ${state.contacts.find(c=>c.id === state.activeChatId).name}`, state.activeChatId);
                            renderMyProfile();
                            await kokoMemory.put('myProfile', state.myProfile);

                            await createAndAddMessage({
                                type: 'transfer',
                                content: { amount: transferAmount.toFixed(2), completed: false }
                            });
                            modal.style.display = 'none';
                        } else {
                            alert("请输入有效的金额！");
                        }
                    });
                    break;
                }
                
                 // --- NEW: V7.0 ---
case 'share-music': {
    const modal = document.getElementById('send-music-modal');
    // 清空所有输入框
    document.getElementById('send-music-url-input').value = '';
    document.getElementById('send-music-title-input').value = '';
    document.getElementById('send-music-artist-input').value = '';
    document.getElementById('send-music-lrc-input').value = ''; // 清空歌词
    document.getElementById('send-music-cover-input').value = '';
    document.getElementById('music-search-keyword-modal').value = ''; // 清空搜索框
    document.getElementById('music-search-results-modal').innerHTML = '<p style="color: #999; text-align: center; padding: 10px;">在这里搜索，结果会显示在下方</p>'; // 重置结果区

    document.getElementById('notify-ai-checkbox').checked = true;
    modal.style.display = 'flex';
    
    renderMusicPickerInModal(); // (如果你保留了本地曲库选择功能的话)

    addOneTimeListener('confirm-send-music-btn', async () => {
        const url = document.getElementById('send-music-url-input').value.trim();
        const title = document.getElementById('send-music-title-input').value.trim();
        const artist = document.getElementById('send-music-artist-input').value.trim();
        // ✨ 获取隐藏输入框里的歌词
        const lrc = document.getElementById('send-music-lrc-input').value;
        const cover = document.getElementById('send-music-cover-input').value;

        if (!url || !title) {
            alert('请至少填写歌曲名和URL（或通过搜索自动填充）！');
            return;
        }
        
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        
        // 构建完整的歌曲对象
        const song = { title, artist, url, lrc }; // ✨ 歌词被带上了！
        
        // 添加到播放列表并分享
        contact.sharedPlaylist.tracks.push(song);
        await createAndAddMessage({ type: 'music_share', content: song }, 'user', contact, false, 'chat');
        
        if (document.getElementById('notify-ai-checkbox').checked) {
            const systemPrompt = `[SYSTEM: 用户分享了一首歌曲《${title}》，来自${artist || '未知艺术家'}。请你发表一下你的感想。]`;
            await requestAiReply(systemPrompt);
        }

        modal.style.display = 'none';
    });
    break;
}
                
                    case 'game-wheel': {
    const modal = document.getElementById('create-wheel-modal');
    const optionsContainer = document.getElementById('wheel-options-container');
    document.getElementById('wheel-name-input').value = '';
    optionsContainer.innerHTML = ''; // 清空旧选项

    // 默认创建2个选项
    addWheelOptionInput('真心话', 1);
    addWheelOptionInput('大冒险', 1);

    modal.style.display = 'flex';
    break;
}
                    case 'start-video-call': if (state.activeChatId) { startVideoCall(state.activeChatId, 'user'); } else { alert("请先选择一个聊天对象！"); } break;
            }
        }
        
        function showDiaryScreen() {
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if (!contact) return;
            hideAllScreens();
            document.getElementById('diary-screen').style.display = 'flex';
            document.getElementById('diary-title').textContent = `${contact.name}的日记`;
            renderDiary();
        }

// 替换掉旧的 renderDiary 函数
function renderDiary() {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    const diaryContentList = document.getElementById('diary-content-list');
    diaryContentList.innerHTML = '';

    if (!contact || !contact.diary || contact.diary.length === 0) {
        diaryContentList.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-book" style="font-size: 48px; margin-bottom: 15px;"></i><p>他的日记本是空的。</p></div>`;
        return;
    }

    const sortedDiary = [...contact.diary].sort((a, b) => b.timestamp - a.timestamp);

    sortedDiary.forEach(entry => {
        const entryEl = document.createElement('div');
        entryEl.className = 'diary-entry';

        // 如果在已选中的Set里，就加上 'selected' 类
        if (diaryEditModeState.selectedEntryIds.has(entry.id)) {
            entryEl.classList.add('selected');
        }

        let entryHTML = '';
        if (diaryEditModeState.active) {
            // 【编辑模式】显示复选框
            const isChecked = diaryEditModeState.selectedEntryIds.has(entry.id) ? 'checked' : '';
            entryHTML = `
                <div style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                    <input type="checkbox" class="diary-select-checkbox" data-diary-id="${entry.id}" ${isChecked}>
                    <div style="flex-grow: 1;">
                        <div class="diary-entry-meta">${formatTimeAgo(entry.timestamp)}</div>
                        <div class="diary-entry-content">${entry.content.replace(/\n/g, '<br>')}</div>
                    </div>
                </div>
            `;
        } else {
            // 【普通模式】显示原来的删除按钮
            entryHTML = `
                <div class="diary-entry-meta">${formatTimeAgo(entry.timestamp)}</div>
                <div class="diary-entry-content">${entry.content.replace(/\n/g, '<br>')}</div>
                <div class="diary-delete-btn" data-diary-id="${entry.id}"><i class="fas fa-trash-alt"></i></div>
            `;
        }
        entryEl.innerHTML = entryHTML;
        diaryContentList.appendChild(entryEl);
    });
}
// 新增的函数
function enterDiaryEditMode() {
    diaryEditModeState.active = true;
    diaryEditModeState.selectedEntryIds.clear(); // 清空上次的选择
    document.getElementById('diary-edit-mode-bar').style.display = 'flex';
    renderDiary(); // 重新渲染日记列表以显示复选框
}

function exitDiaryEditMode() {
    diaryEditModeState.active = false;
    document.getElementById('diary-edit-mode-bar').style.display = 'none';
    renderDiary(); // 重新渲染日记列表以恢复原样
}
        // ▼▼▼ 用下面这个【完整的新版本】，替换掉你旧的 createSystemNotification 函数 ▼▼▼

async function createSystemNotification(content, targetContact = null, contextMode = 'chat') { // 默认设为 'chat'
    // 同样，如果未指定目标，就用当前窗口的，否则用指定的目标
    const contact = targetContact || state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

await createAndAddMessage({
        type: 'system_notification',
        sender: 'system',
        content: content
    }, 'system', contact, false, contextMode); // 把 mode 传递下去

// ▲▲▲ 替换到这里结束 ▲▲▲
}        
        async function showTransferModal(message, contact) {
            const modal = document.getElementById('transfer-modal');
            
            // 获取新HTML结构中的所有元素
            const confirmView = document.getElementById('transfer-confirm-view');
            const statusView = document.getElementById('transfer-status-view');
            
            const senderAvatarEl = document.getElementById('transfer-sender-avatar');
            const senderNameEl = document.getElementById('transfer-sender-name');
            const recipientTextEl = document.getElementById('transfer-recipient-text');
            const amountValueEl = document.getElementById('transfer-amount-value');

            const statusAmountValueEl = document.getElementById('transfer-status-amount-value');
            const statusIconEl = document.getElementById('transfer-status-icon');
            const statusTextEl = document.getElementById('transfer-status-text');
            const statusSenderInfoEl = document.getElementById('transfer-status-sender-info');
            
            const sender = (message.sender === 'user') ? state.myProfile : contact;
            const recipient = (message.sender === 'user') ? contact : state.myProfile;
            
            amountValueEl.textContent = message.content.amount;
            statusAmountValueEl.textContent = message.content.amount;

            // --- 移除并重新绑定事件监听，防止重复绑定 ---
            const confirmBtn = document.getElementById('confirm-transfer-btn');
            const returnBtn = document.getElementById('return-transfer-btn');
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newReturnBtn = returnBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            returnBtn.parentNode.replaceChild(newReturnBtn, returnBtn);

            // 确认收款按钮的逻辑 (已修改)
            // --- 修正后的代码 ---
newConfirmBtn.addEventListener('click', async () => {
    const transferAmount = parseFloat(message.content.amount);
    const senderProfile = contact; // 在这个上下文中，'contact'就是发送者
    const groupChat = state.contacts.find(c => c.id === state.activeChatId); // 获取当前的群聊对象

    if (!groupChat) return; // 安全检查

    if (!isNaN(transferAmount)) {
        state.myProfile.balance += transferAmount;
        await addTransaction('income', transferAmount, `收到 ${senderProfile.name} 的转账`, senderProfile.id);
        await createSystemNotification(`你已收款 ¥${transferAmount.toFixed(2)}`);
        renderMyProfile();
        await kokoMemory.put('myProfile', state.myProfile);
    }

    // 在群聊的历史记录里更新这条消息的状态
    const messageInHistory = groupChat.history.find(m => m.id === message.id);
    if (messageInHistory) {
        messageInHistory.content.completed = true;
        messageInHistory.content.returned = false;
    }

    // 核心修正 1：保存的是群聊对象，而不是发钱的角色对象
    await kokoMemory.put('contacts', groupChat); 

    modal.style.display = 'none';
    // 核心修正 2：重新打开的是当前的群聊界面
    await openChat(state.activeChatId);

    // 这条消息现在会正确地添加到群聊的记忆中
    await createAndAddMessage({
        type: 'text',
        content: `[SYSTEM: 我刚刚点击并接受了 ${senderProfile.name} 的转账。]`
    }, 'system_instruction');
});
            
            // 退还按钮的逻辑
            // --- 修正后的代码 ---
newReturnBtn.addEventListener('click', async () => {
    const senderProfile = contact; // 'contact' 在这里就是发送者
    const groupChat = state.contacts.find(c => c.id === state.activeChatId); // 获取当前聊天（群聊或私聊）

    if (!groupChat) return; // 安全检查

    // 在当前聊天记录里更新这条消息的状态
    const messageInHistory = groupChat.history.find(m => m.id === message.id);
    if (messageInHistory) {
        messageInHistory.content.completed = true;
        messageInHistory.content.returned = true;
    }

    // 核心修正 1：保存的是包含历史记录的当前聊天对象
    await kokoMemory.put('contacts', groupChat);

    await createSystemNotification(`你已退还该笔转账`);

    modal.style.display = 'none';
    // 核心修正 2：重新打开的是当前的聊天界面（私聊或群聊），而不是跳转
    await openChat(state.activeChatId);

    // 为了让AI在群聊中更清晰，优化了SYSTEM指令
    await createAndAddMessage({
        type: 'text',
        content: `[SYSTEM: 我刚刚退回了 ${senderProfile.name} 的转账。]`
    }, 'system_instruction');
});

            // 根据消息状态更新UI
            senderAvatarEl.src = sender.avatar;
            senderNameEl.textContent = sender.name;
            
            if (message.content.completed || message.content.returned) {
                // 如果是已完成或已退还的交易
                confirmView.style.display = 'none';
                statusView.style.display = 'block';
                
                statusIconEl.className = message.content.returned ? 'fas fa-undo-alt' : 'fas fa-check-circle';
                statusTextEl.textContent = message.content.returned ? '已退还' : (message.sender === 'user' ? '对方已收款' : '已收款');
                statusSenderInfoEl.textContent = `转账来自: ${sender.name}`;

            } else if (message.sender !== 'user') { // 我是收款方，未处理
                confirmView.style.display = 'block';
                statusView.style.display = 'none';
                recipientTextEl.textContent = "转账给你";
                newConfirmBtn.style.display = 'block';
                newReturnBtn.style.display = 'block';
            } else { // 我是付款方，对方未处理
                confirmView.style.display = 'block';
                statusView.style.display = 'none';
                recipientTextEl.textContent = `转账给 ${recipient.name}`;
                newConfirmBtn.style.display = 'none';
                newReturnBtn.style.display = 'none';
            }
            
            modal.style.display = 'flex';
            document.getElementById('close-transfer-modal').onclick = () => modal.style.display = 'none';
        }

// ▼▼▼ 把这个新函数粘贴到 processAndDisplayAiResponse 的【上方】 ▼▼▼

/**
 * (全新) 辅助函数：只刷新单个消息气泡的DOM，而不重载整个聊天
 * @param {string} messageId - 要刷新的消息的ID
 */
async function refreshMessageBubbleInDOM(messageId) {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    const msg = contact.history.find(m => m.id === messageId);
    if (!msg) return; // 找不到消息数据

    const wrapper = document.querySelector(`.message-wrapper[data-message-id="${messageId}"]`);
    if (!wrapper) return; // 消息不在屏幕上，不用刷新

    try {
        // 1. 检查这条消息在DOM中是否是“序列的第一个”（用来决定是否显示头像）
        const isFirstInSequence = wrapper.classList.contains('is-first-in-sequence');

        // 2. 用【更新后】的 msg 数据，调用 createMessageElement 重新创建一个【新】的HTML元素
        const newWrapper = createMessageElement(msg, contact, isFirstInSequence);

        if (newWrapper) {
            // 3. 在旧元素的父节点中，用新元素替换掉旧元素
            wrapper.parentNode.replaceChild(newWrapper, wrapper);
        }
    } catch (e) {
        console.error("单点刷新气泡失败:", e, "将回退到完整刷新");
        // 如果（万一）失败了，就执行旧的刷新逻辑
        await openChat(contact.id);
    }
}
// ▼▼▼ 使用这个【最终解决方案】替换掉你原来的 processAndDisplayAiResponse 函数 ▼▼▼
async function processAndDisplayAiResponse(rawResponse, senderProfile, originContext = null, contextMode = 'chat') { // 默认设为 'chat'
    if (!senderProfile) return;
        // ▼▼▼ ✨✨✨ 粘贴这个 if 判断 ✨✨✨ ▼▼▼
  // ▼▼▼ 使用这个【V2 完整修正版】替换掉旧的 "if (state.currentChatMode === 'sms')" 代码块 ▼▼▼

    if (contextMode === 'sms') {
        // --- 短信模式的处理逻辑 ---
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;

        // 1. 过滤掉日记和心声 (短信里不需要)
        let smsContent = rawResponse.replace(/\[diary\][\s\S]*?(\[\/diary\]|$)/g, '').trim();
        smsContent = smsContent.replace(/\[heart_voice\][\s\S]*?(\[\/heart_voice\]|$)/g, '').trim();

        // 2. ✨ 核心修改：借用一个简化的正则表达式，让它能识别 action 和 picture ✨
        const smsCommandRegex = /\[(picture|action)(?::([^\]]*))?\]/;
        
        const lines = smsContent.split('\n').filter(line => line.trim() !== '');
        
        for (const line of lines) {
            const commandMatch = line.match(smsCommandRegex);
            let processed = false; // 标记这行是否是指令

            if (commandMatch) {
                processed = true; // 标记为已处理
                const command = commandMatch[1];
                const value = commandMatch[2] || '';
                
                switch (command) {
                    case 'picture':
                        // (处理图片的逻辑不变)
                        await createAndAddMessage({
                            type: 'picture_description',
                            sender: senderProfile.id,
                            content: { description: value.trim() }
                        }, senderProfile.id, contact, false, 'sms'); // 指定发送到短信历史
                        break;
                    
// ▼▼▼ ✨ 使用这个【正确版本】替换 ✨ ▼▼▼
                    case 'action':
                        if (value === 'unblock_user') {
                            senderProfile.blockedStatus = 'none';
                            await kokoMemory.put('contacts', senderProfile);
                            
                            // --- 核心修复 ---
                            
                            // 1. 临时切换到 'chat' 模式
                            const originalMode = state.currentChatMode;
                            state.currentChatMode = 'chat'; 
                            
                            // 2. 在 'chat' 模式下发送系统通知到【主聊天】
                            //    注意：我们传入 senderProfile 作为目标，
                            //    这样 createAndAddMessage 会把消息添加到 senderProfile.history 数组中
                            await createAndAddMessage({
                                type: 'system_notification',
                                sender: 'system',
                                content: `${senderProfile.name} 已将你解除拉黑。`
                            }, 'system', senderProfile); 
                            
                            // 3. 立即切回 'sms' 模式，准备发送AI的“话”
                            state.currentChatMode = originalMode;
                            
                            // 4. 解锁主界面的输入框 (这个不变)
                            updateChatInputLockState('none');
                            
                            // --- 修复结束 ---
                        }
                        // (AI 在短信模式下拉黑用户没有意义，所以我们忽略 block_user)
                        break;
                    // ▲▲▲ 替换结束 ▲▲▲
                }
            } 
            
            // 4. 如果不是指令，并且不是空行，才作为普通文本发送
            if (!processed && line.trim()) {
                await createAndAddMessage({
                    type: 'text',
                    sender: senderProfile.id,
                    content: line.trim()
                }, senderProfile.id, contact, false, 'sms'); // 指定发送到短信历史
            }
            
            await sleep(300 + Math.random() * 300); // 模拟短信延迟
        }
        return; // ✨ 处理完短信逻辑后，必须返回！
    }

// ▲▲▲ 替换到这里结束 (后面的 else 逻辑，即主聊天的逻辑，保持不变) ▲▲▲

    // ... (函数剩余的 else { ... } 部分，即主聊天的逻辑，保持原样) ...

    let effectiveChatContext;

    // 【V3 修复版逻辑】
    // 目的地（originContext）现在总是由调用方（triggerAiReply/triggerGroupChatAiReply）
    // 明确提供，我们不再需要猜测。
    if (originContext) {
        effectiveChatContext = originContext;
    } else {
        // 如果（万一）调用方没有提供目的地，我们唯一的安全选择是
        // 将回复发给发送者自己的私聊窗口，而不是发到当前打开的窗口。
        effectiveChatContext = senderProfile; 
    }
    
    if (!effectiveChatContext) {
        console.error("错误：无法为AI回复确定一个有效的目的地。");
        return; 
    }
    
    let conversation = rawResponse;
    const extractionRegex = /\[发送了一段静态内容，文本是：["']([\s\S]*?)["']\]/g;
    conversation = conversation.replace(extractionRegex, '').trim();

 // ========================= 【核心修复：心声解析】 =========================
let heartVoiceContent = null;

// ▼▼▼ 核心修复：使用更严格的正则表达式，只匹配 { ... } JSON 对象 ▼▼▼
// 's' 标志让 '.' 匹配换行符，确保 { ... } 可以跨行
const heartVoiceRegex = /\[heart_voice\]\s*({[\s\S]*?})\s*(?:\[\/heart_voice\]|(?=\[diary\]|$))/;
const heartVoiceMatch = conversation.match(heartVoiceRegex);

if (heartVoiceMatch) {
    // heartVoiceMatch[1] 现在 *只* 包含 { ... }
    const jsonString = heartVoiceMatch[1] ? heartVoiceMatch[1].trim() : ''; 

    if (jsonString) {
        try {
            // 我们不再需要 cleanedJsonString，因为 regex 已经帮我们拿到了纯净的 JSON
            heartVoiceContent = JSON.parse(jsonString); 
        } catch (e) {
            console.error("解析心声JSON失败 (AI格式错误):", e, "原始字符串:", jsonString);
            // 即使解析失败，我们也要继续，并把错误的文本从对话中移除
        }
    }

    // 关键：heartVoiceMatch[0] 包含完整的 [heart_voice]{...} 
    // 我们用它来替换，就能把心声从【任何位置】（开头、中间、结尾）精准地剥离出去
    // 这就解决了你截图中的BUG
    conversation = conversation.replace(heartVoiceMatch[0], '').trim();
}
// ▲▲▲ 修复结束 ▲▲▲
// ========================= 【修复结束】 =========================

    let diaryContent = null;
    const strictDiaryRegex = /\[diary\]([\s\S]*?)\[\/diary\]/g;
    const strictMatch = strictDiaryRegex.exec(conversation);

    if (strictMatch && strictMatch[1]) {
        diaryContent = strictMatch[1].trim();
        conversation = conversation.replace(strictDiaryRegex, '').trim();
    } else {
        const lenientDiaryStartIndex = conversation.indexOf('[diary]');
        if (lenientDiaryStartIndex !== -1) {
            diaryContent = conversation.substring(lenientDiaryStartIndex + '[diary]'.length).trim();
            conversation = conversation.substring(0, lenientDiaryStartIndex).trim();
        }
    }

    if (diaryContent) {
        if (!senderProfile.diary) senderProfile.diary = [];
        senderProfile.diary.push({
            id: `diary_${Date.now()}`,
            content: diaryContent,
            timestamp: Date.now()
        });
        await kokoMemory.put('contacts', senderProfile);
    }
    
// ... 省略了日记保存的代码 ...

    // ▼▼▼ 使用这个【增强版】来替换原来的代码 ▼▼▼
    if (heartVoiceContent) {
        
        // 1. 在添加新的心声消息之前...
        // ...我们先把这个角色历史记录里所有旧的 'heart_voice' 消息都过滤掉。
        // .filter() 方法会创建一个新数组，其中仅包含所有不符合 "msg.type === 'heart_voice'" 条件的元素。
        if (effectiveChatContext.history) {
             effectiveChatContext.history = effectiveChatContext.history.filter(msg => msg.type !== 'heart_voice');
        }

        // 2. 然后，再把这个最新的心声添加进去。
        // 这样一来，历史记录里永远最多只有一个心声消息。
        await createAndAddMessage({
            type: 'heart_voice',
            content: heartVoiceContent
        }, senderProfile.id, effectiveChatContext, false, 'chat');
    }
    // ▲▲▲ 替换结束 ▲▲▲

// ... 后续代码 ...
    const callTriggerRegex = /\[action:start_video_call\]|发起了视频通话|视频通话请求已发送|正在向您发起视频通话|已拨通您的视频电话/;
if (!effectiveChatContext.isGroup && callTriggerRegex.test(conversation)) {
        
        // 1. 先把触发通话的关键词去掉，只留下对话文本
        const callTriggerRegexForReplace = /\[action:start_video_call\]|给你打个视频电话|我们来视频通话|拨通了你的电话|打过去了|播出去了|\[.*?(呼叫|拨打|视频|电话).*?\]/g;
        const textResponse = conversation.replace(callTriggerRegexForReplace, '').trim();

        // 2. 先把话都说完（发送气泡）
        if (textResponse) {
            const lines = textResponse.split('\n').filter(line => line.trim() !== '');
            
            for (const line of lines) {
                await createAndAddMessage(
                    { type: 'text', content: line.trim() }, 
                    senderProfile.id, 
                    senderProfile, 
                    false, 
                    'chat'
                );
                // 气泡之间的停顿
                await sleep(500 + Math.random() * 300); 
            }
        }

        // 3. ✨ 核心修改：气泡都发完了，稍微等一下，再弹出来电界面
        // 给用户 0.8秒 的时间看最后一条消息
        await sleep(800); 
        handleIncomingCall(senderProfile);

        return; // 拦截结束
    }

    if (contextMode === 'chat' && state.activeCall && state.activeCall.contactId === effectiveChatContext.id) {
await createAndAddMessage({
            type: 'video_call_text',
            content: conversation
        }, senderProfile.id, senderProfile, false, 'chat');

        const narrativeFeed = document.getElementById('narrative-feed');
        const actionRegex = /\[action:(.*?)\]/g;
        let narrativeText = conversation;
        const match = actionRegex.exec(conversation);
        if (match) {
            const action = match[1].trim();
            if (action === 'hang_up') {
                narrativeText = conversation.replace(actionRegex, '').trim();
                if (narrativeText) {
                    const bubble = document.createElement('div');
                    bubble.className = 'char-bubble';
                    bubble.innerHTML = `<p class="narrative-speech">“${narrativeText}”</p>`;
                    narrativeFeed.appendChild(bubble);
                    narrativeFeed.scrollTop = narrativeFeed.scrollHeight;
                    await sleep(1000);
                }
                await endVideoCall('contact', `${senderProfile.name} 挂断了电话`);
                return;
            }
        }

        if (narrativeText) {
            const bubble = document.createElement('div');
            bubble.className = 'char-bubble';
            const regex = /(\*[^*]+\*)|(\{[^{}]+\})|(“[^”]+”)/g;
            const parts = narrativeText.split(regex).filter(Boolean);
            parts.forEach(part => {
                part = part.trim();
                if (!part) return;
                const p = document.createElement('p');
                if (part.startsWith('*')) { p.className = 'narrative-action'; p.textContent = part; }
                else if (part.startsWith('{')) { p.className = 'narrative-psychology'; p.textContent = part; }
                else if (part.startsWith('“')) { p.className = 'narrative-speech'; p.textContent = part; }
                else { p.className = 'narrative-speech'; p.textContent = `“${part}”`; }
                bubble.appendChild(p);
            });
            narrativeFeed.appendChild(bubble);
            narrativeFeed.scrollTop = narrativeFeed.scrollHeight;

            const dialogueParts = [];
            const dialogueRegex = /“([^”]+)”/g;
            let dialogueMatch;
            while ((dialogueMatch = dialogueRegex.exec(narrativeText)) !== null) {
                dialogueParts.push(dialogueMatch[1]);
            }
            const fullDialogue = dialogueParts.join('，');

if (fullDialogue) {
    // 传入 senderProfile (也就是完整的 contact 对象)
    await playNextInQueue(fullDialogue, senderProfile); 
}
        }
        return;
    }

// ... (省略了上面的 if (state.activeCall...) ... )

            const lastUnopenedMessage = effectiveChatContext.history.slice().reverse().find(m =>
                m.sender === 'user' && (
                    (m.type === 'red_packet' && !m.content.opened) ||
                    (m.type === 'transfer' && !m.content.completed)
                )
            );

            // ▼▼▼ 从这里开始是修复后的逻辑 ▼▼▼
            // 找到 if (lastUnopenedMessage) { ... } 这一大块，替换为：
            
            if (lastUnopenedMessage) {
                const rejectionKeywords = ['不收', '不要', '退回', '还给你', '我不能要', '心意领了', '太贵重'];
                // ✨ 修改点：极大扩充“接受”的关键词库
                const acceptanceKeywords = ['收下', '收了', '领了', '打开', '谢谢', '我收', '我领', '开心', '破费', '笑纳', '好意', '拿去买', '请客'];

                // ✨ 修改点：同时检查是否包含 [claim_red_packet] 指令
                const hasClaimCommand = conversation.includes('[claim_red_packet]');
                
                // 1. 只要包含关键词，或者用了指令，就算接受
                const accepted = hasClaimCommand || acceptanceKeywords.some(keyword => conversation.includes(keyword));
                
                if (accepted) {
                    // --- 处理接受逻辑 ---
                    if (lastUnopenedMessage.type === 'red_packet') {
                        lastUnopenedMessage.content.opened = true;
                        // 如果是私聊红包，且尚未生成领取记录，手动补一条
                        if (!lastUnopenedMessage.content.claimers) {
                            lastUnopenedMessage.content.claimers = [{
                                userId: senderProfile.id, // AI 领取的
                                amount: parseFloat(lastUnopenedMessage.content.amount)
                            }];
                        }
                    } else if (lastUnopenedMessage.type === 'transfer') {
                        lastUnopenedMessage.content.completed = true;
                        lastUnopenedMessage.content.returned = false;
                    }
                    
                    await kokoMemory.put('contacts', effectiveChatContext);
                    // 刷新UI以显示“已收款/已领取”
                    await refreshMessageBubbleInDOM(lastUnopenedMessage.id); 

                } else {
                    // 2. 只有在“未接受”的情况下，才检查是否“拒绝”
                    const rejected = rejectionKeywords.some(keyword => conversation.includes(keyword));
                    if (rejected) {
                        // --- 处理拒绝逻辑 ---
                        if (lastUnopenedMessage.type === 'transfer') {
                            lastUnopenedMessage.content.completed = true;
                            lastUnopenedMessage.content.returned = true;
                            
                            const transferAmount = parseFloat(lastUnopenedMessage.content.amount);
                            if (!isNaN(transferAmount)) {
                                state.myProfile.balance += transferAmount;
                                await addTransaction('income', transferAmount, `来自 ${senderProfile.name} 的转账退款`, senderProfile.id);
                                renderMyProfile();
                                await kokoMemory.put('myProfile', state.myProfile);
                            }
                            
                            await kokoMemory.put('contacts', effectiveChatContext);
                            await refreshMessageBubbleInDOM(lastUnopenedMessage.id);
                            await createSystemNotification(`${senderProfile.name} 退还了你的转账`, effectiveChatContext, 'chat');
                        }
                    }
                }
            }


            if (contextMode === 'chat' && effectiveChatContext.isNarrativeMode) {
            if (conversation) {
                await sleep(400 + Math.random() * 400);
                // ▼▼▼ 核心修复：在叙事模式下也进行 HTML 检测 ▼▼▼
                if (conversation.trim().startsWith('<') && conversation.trim().endsWith('>')) {
                    // 如果整段内容以 < 开头并以 > 结尾，我们判定它为 HTML 卡片
                    await createAndAddMessage({ type: 'html', content: conversation }, senderProfile.id, effectiveChatContext, false, 'chat');
                } else {
                    // 否则才当作普通的叙事文本处理
                    await createAndAddMessage({ type: 'text', content: conversation }, senderProfile.id, effectiveChatContext, false, 'chat');
                }
                // ▲▲▲ 修复结束 ▲▲▲
            }
// ▼▼▼ 使用这个【V4 - 延迟修正版】替换旧的 "else if (contextMode === 'chat') { ... }" 完整代码块 ▼▼▼

    } else if (contextMode === 'chat') {
        
        // --- 智能缓冲循环 V4 (Koko特供版) 开始 ---
        
        const lines = conversation.split('\n');
        let htmlBuffer = [];
        let inHtmlBlock = false;
        let openingTag = null; 

        for (const line of lines) {
            const trimmedLine = line.trim();

            if (inHtmlBlock) {
                // --- 1. 我们正处于一个多行HTML块内部 ---
                htmlBuffer.push(line); 
                
                if (openingTag && trimmedLine.includes(`</${openingTag}>`)) {
                    await createAndAddMessage({
                        type: 'html',
                        content: htmlBuffer.join('\n')
                    }, senderProfile.id, effectiveChatContext, false, 'chat');
                    
                    // ✨ 核心修复：只在发送消息后才延迟
                    await sleep(400 + Math.random() * 400); 
                    
                    htmlBuffer = [];
                    inHtmlBlock = false;
                    openingTag = null;
                }
                // (如果没结束，不延迟，光速进入下一行)
                continue;
            }

            // --- 2. 我们当前不在HTML块内 ---
            
            // 检查 2a: 是否是空行？
            if (trimmedLine === '') continue; // 跳过空行，不延迟

            // 检查 2b: 这一行是否 *开启* 了一个新的多行HTML块?
            let tagMatch = trimmedLine.match(/^<(div|style)/i);
            
            if (tagMatch) {
                openingTag = tagMatch[1].toLowerCase();
                htmlBuffer = [line];
                
                if (trimmedLine.includes(`</${openingTag}>`)) {
                    // 这是一个单行HTML块，立即发送
                    await createAndAddMessage({
                        type: 'html',
                        content: trimmedLine
                    }, senderProfile.id, effectiveChatContext, false, 'chat');
                    
                    // ✨ 核心修复：只在发送消息后才延迟
                    await sleep(400 + Math.random() * 400); 
                    
                    htmlBuffer = [];
                    openingTag = null;
                } else {
                    // 这是一个 *多行* 块的开始，进入缓冲状态
                    inHtmlBlock = true;
                }
                
            } else {
                // --- 3. 既不在HTML块内，也不开启新块，它是【普通文本行】或【指令行】 ---
                
                let processed = false;
                const commandRegex = /\[(sticker|voice|picture|red_packet|transfer|transfer_to|music|spin_wheel|claim_red_packet|location|create_location|action|search_music|recall)(?::([^\]]*))?\]/;
                const commandMatch = line.match(commandRegex);
                const lastWheelMsg = [...effectiveChatContext.history].reverse().find(m => m.type === 'game_wheel' && !m.content.results.contact);
                
                // (--- 你的所有指令检查逻辑... ---)
                if (lastWheelMsg) {
                    const contactName = senderProfile.name;
                    const validOptions = lastWheelMsg.content.options.map(opt => opt.text);
                    const ultimatePositionalRegex = new RegExp(`(?:${contactName}|我).*?(?:[“"'])?(${validOptions.join('|')})(?:[“"'])?`);
                    const fallbackMatch = line.match(ultimatePositionalRegex);
                    if (fallbackMatch) {
                        const result = fallbackMatch[1];
                        const wheel = lastWheelMsg.content;
                        wheel.results.contact = result.trim();
                        await kokoMemory.put('contacts', effectiveChatContext);
                        const msgIdToUpdate = lastWheelMsg.id;
                        const wrapperToUpdate = document.querySelector(`.message-wrapper[data-message-id='${msgIdToUpdate}']`);
                        if (wrapperToUpdate) {
                            const contactResultRow = wrapperToUpdate.querySelectorAll('.wheel-result-row')[1];
                            if (contactResultRow) {
                                contactResultRow.innerHTML = `<span class="wheel-player-name">${contactName}</span> <div class="wheel-player-result">${result.trim()}</div>`;
                            }
                        }
                        continue; // (指令处理完成，跳过)
                    }
                }
                
                if (commandMatch) {
                    processed = true;
                    const command = commandMatch[1];
                    const value = commandMatch[2] || '';
                    switch (command) {
                        case 'claim_red_packet': {
                            // ... (省略 claim_red_packet 逻辑) ...
                            const lastPacketMsg = [...effectiveChatContext.history].reverse().find(m => m.type === 'red_packet' && m.content.count > (m.content.claimers || []).length);
                            if (lastPacketMsg) {
                                const packet = lastPacketMsg.content;
                                const hasClaimed = (packet.claimers || []).some(c => c.userId === senderProfile.id);
                                if (!hasClaimed) {
                                    const remainingCount = packet.count - packet.claimers.length;
                                    const remainingAmount = packet.totalAmount - packet.claimers.reduce((sum, c) => sum + c.amount, 0);
                                    let amount = 0;
                                    if (remainingCount > 1) {
                                        const avg = remainingAmount / remainingCount;
                                        amount = Math.random() * avg * 1.8; // 增加随机性
                                        amount = Math.min(remainingAmount - (remainingCount - 1) * 0.01, amount);
                                    } else {
                                        amount = remainingAmount;
                                    }
                                    amount = Math.max(0.01, parseFloat(amount.toFixed(2)));
                                    packet.claimers.push({ userId: senderProfile.id, amount: amount });
                                    await kokoMemory.put('contacts', effectiveChatContext);
                                    const remainingText = line.replace(commandRegex, '').trim();
                                    if (remainingText) {
                                        await createAndAddMessage({ type: 'text', content: remainingText }, senderProfile.id, effectiveChatContext, false, 'chat');
                                        await sleep(400 + Math.random() * 400); // ✨ 延迟
                                    }
                                    const senderId = lastPacketMsg.sender;
                                    let notificationText = '';
                                    if (senderId === 'myProfile') {
                                        notificationText = `${senderProfile.name} 领取了你的红包`;
                                    } else {
                                        const sender = state.contacts.find(c => c.id === senderId);
                                        const senderName = sender ? sender.name : '另一位成员';
                                        notificationText = `${senderProfile.name} 领取了 ${senderName} 的红包`;
                                    }
                                    await createSystemNotification(notificationText, effectiveChatContext);
                                    // (系统通知自己会带延迟)
                                }
                            }
                            processed = true;
                            break;
                        }
                        case 'location': {
                            const locationName = value.trim();
                            if (senderProfile && senderProfile.mapId) {
                                const mapData = await kokoMemory.get('maps', senderProfile.mapId);
                                const location = mapData.locations.find(loc => loc.name === locationName);
                                if (location) {
                                    await createAndAddMessage({ type: 'location_share', content: { mapId: senderProfile.mapId, locationId: location.id, name: location.name, icon: location.icon, x: location.x, y: location.y } }, senderProfile.id, effectiveChatContext, false, 'chat');
                                } else {
                                    await createAndAddMessage({ type: 'text', content: `(系统错误：我想发送一个叫“${locationName}”的位置，但地图上好像没有这个地方。)` }, senderProfile.id, effectiveChatContext, false, 'chat');
                                }
                            }
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        }
// (Handler 更新：支持 parentName 查找)
                        case 'create_location': {
                            try {
                                // 1. 解析 AI 的 JSON 指令
                                const locationData = JSON.parse(value);
                                
                                if (senderProfile && senderProfile.mapId) {
                                    const mapData = await kokoMemory.get('maps', senderProfile.mapId);
                                    if (mapData) {
                                        // 2. 核心：查找 AI 指定的父地点 ID
                                        let targetParentId = null;
                                        if (locationData.parentName) {
                                            // 在现有地点中查找名字匹配的
                                            const parentLoc = (mapData.locations || []).find(l => l.name === locationData.parentName);
                                            if (parentLoc) {
                                                targetParentId = parentLoc.id;
                                            } else {
                                                // 如果AI瞎编了一个不存在的父地点，为了防止报错，我们默认放到根目录，或者你可以选择忽略
                                                console.warn(`AI 试图在不存在的父地点 "${locationData.parentName}" 中创建地点，已回退到根目录。`);
                                            }
                                        }

                                        // 3. 构建新地点对象
                                        const newLocation = { 
                                            id: 'loc_' + Date.now(), 
                                            name: locationData.name, 
                                            description: locationData.description, 
                                            icon: locationData.icon || 'fas fa-map-marker-alt', 
                                            tier: 2, // 默认大小
                                            x: 500 + Math.floor(Math.random() * 100 - 50), // 随机坐标防重叠
                                            y: 500 + Math.floor(Math.random() * 100 - 50),
                                            parentId: targetParentId // 绑定父级！
                                        };
                                        
                                        if (!mapData.locations) mapData.locations = [];
                                        mapData.locations.push(newLocation);
                                        
                                        await kokoMemory.put('maps', mapData);
                                        
                                        // 4. 发送分享卡片
                                        await createAndAddMessage({ 
                                            type: 'location_share', 
                                            content: { 
                                                mapId: senderProfile.mapId, 
                                                locationId: newLocation.id, 
                                                ...newLocation 
                                            } 
                                        }, senderProfile.id, effectiveChatContext, false, 'chat');
                                    }
                                }
                            } catch (error) {
                                console.error("AI 创建地点失败", error);
                                await createAndAddMessage({ type: 'text', content: `(系统：我刚才想创建一个新地点，但是数据格式好像出错了...)` }, senderProfile.id, effectiveChatContext, false, 'chat');
                            }
                            await sleep(400 + Math.random() * 400); 
                            break;
                        }
                        case 'spin_wheel': {
                            // (这个是AI响应用户的转盘，不需要延迟)
                            const currentWheelMsg = [...effectiveChatContext.history].reverse().find(m => m.type === 'game_wheel' && !m.content.results.contact);
                            if (currentWheelMsg) {
                                const wheel = currentWheelMsg.content;
                                const weightedOptions = wheel.options.flatMap(opt => Array(opt.weight).fill(opt.text));
                                const result = weightedOptions[Math.floor(Math.random() * weightedOptions.length)];
                                wheel.results.contact = result;
                                await kokoMemory.put('contacts', effectiveChatContext);
                                const msgIdToUpdate = currentWheelMsg.id;
                                const wrapperToUpdate = document.querySelector(`.message-wrapper[data-message-id='${msgIdToUpdate}']`);
                                if (wrapperToUpdate) {
                                    const contactResultRow = wrapperToUpdate.querySelectorAll('.wheel-result-row')[1];
                                    if (contactResultRow) {
                                        contactResultRow.innerHTML = `<span class="wheel-player-name">${senderProfile.name}</span> <div class="wheel-player-result">${result}</div>`;
                                    }
                                }
                            }
                            break;
                        }
                        case 'red_packet': {
                            const parts = value.split(/[，,]/).map(p => p.trim());
                            if (parts.length === 3) {
                                // ... (群聊红包) ...
                                const blessing = parts[0] || "恭喜发财！";
                                const totalAmount = parseFloat(parts[1]);
                                const count = parseInt(parts[2], 10);
                                if (!isNaN(totalAmount) && totalAmount > 0 && !isNaN(count) && count > 0) {
                                    await createAndAddMessage({ type: 'red_packet', content: { totalAmount: totalAmount, count: count, blessing: blessing, claimers: [] } }, senderProfile.id, effectiveChatContext, false, 'chat');
                                }
                            } else if (parts.length === 2) {
                                // ... (私聊红包) ...
                                const blessing = parts[0] || "恭喜发财！";
                                const amount = parseFloat(parts[1]);
                                if (!isNaN(amount) && amount > 0) {
                                    await createAndAddMessage({ type: 'red_packet', content: { amount: amount.toFixed(2), blessing: blessing, opened: false } }, senderProfile.id, effectiveChatContext, false, 'chat');
                                }
                            }
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        }
                        case 'transfer_to': {
                            // ... (群聊转账) ...
                            const parts = value.split(/[，,]/).map(p => p.trim());
                            if (parts.length === 2) {
                                const recipientName = parts[0];
                                const amount = parseFloat(parts[1]);
                                const recipientProfile = effectiveChatContext.members.map(id => id === 'myProfile' ? state.myProfile : state.contacts.find(c => c.id === id)).find(p => p && p.name === recipientName);
                                if (recipientProfile && !isNaN(amount) && amount > 0) {
                                    await createAndAddMessage({ type: 'transfer', content: { amount: amount.toFixed(2), completed: false, returned: false, recipientId: recipientProfile.id } }, senderProfile.id, effectiveChatContext, false, 'chat');
                                }
                            }
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        }
                        case 'sticker':
                            const emoticon = state.emoticons.find(e => e.name === value.trim());
                            if (emoticon) {
                                await createAndAddMessage({ type: 'image', url: emoticon.url, isEmoticon: true, emoticonName: emoticon.name }, senderProfile.id, effectiveChatContext, false, 'chat');
                            } else {
                                await createAndAddMessage({ type: 'text', content: `[发送表情失败: ${value}]` }, senderProfile.id, effectiveChatContext, false, 'chat');
                            }
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        case 'voice':
                            const duration = Math.max(1, Math.round(value.length / 4));
                            await createAndAddMessage({ type: 'voice', content: { text: value, duration: duration } }, senderProfile.id, effectiveChatContext, false, 'chat');
                            processed = true;
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        case 'picture':
                            await createAndAddMessage({ type: 'picture_description', content: { description: value } }, senderProfile.id, effectiveChatContext, false, 'chat');
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        case 'transfer': {
                            const transferAmount = parseFloat(value);
                            if (transferAmount > 0) {
                                await createAndAddMessage({ type: 'transfer', content: { amount: transferAmount.toFixed(2), completed: false, returned: false } }, senderProfile.id, effectiveChatContext, false, 'chat');
                            }
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        }
                        case 'music': {
                            // ... (music 逻辑) ...
                            const lastComma = value.lastIndexOf('，') > -1 ? '，' : ',';
                            const lastCommaIndex = value.lastIndexOf(lastComma);
                            if (lastCommaIndex === -1) break;
                            const url = value.substring(lastCommaIndex + 1).trim();
                            const secondToLastCommaIndex = value.lastIndexOf(lastComma, lastCommaIndex - 1);
                            if (secondToLastCommaIndex === -1) break;
                            const artist = value.substring(secondToLastCommaIndex + 1, lastCommaIndex).trim();
                            const title = value.substring(0, secondToLastCommaIndex).trim();
                            if (url.startsWith('http') && title) {
                                await createAndAddMessage({ type: 'music_share', content: { title, artist, url } }, senderProfile.id, effectiveChatContext, false, 'chat');
                            }
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        }
                        case 'search_music': {
                            const keyword = value.trim();
                            if (keyword) {
                                const song = await fetchSongForAI(keyword);
                                if (song) {
                                    effectiveChatContext.sharedPlaylist.tracks.push(song);
                                    await createAndAddMessage({ 
                                        type: 'music_share', 
                                        content: song
                                    }, senderProfile.id, effectiveChatContext, false, 'chat');
                                } else {
                                    await createAndAddMessage({ 
                                        type: 'text', 
                                        content: `(系统：我想搜“${keyword}”，但没找到能放的歌...QAQ)`
                                    }, senderProfile.id, effectiveChatContext, false, 'chat');
                                }
                            }
                            processed = true;
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        }
                        case 'action':
                            // ... (action 逻辑) ...
                            if (value === 'block_user') {
                                senderProfile.blockedStatus = 'ai_blocked_user';
                                await kokoMemory.put('contacts', senderProfile);
                                await createSystemNotification(`${senderProfile.name} 已将你拉黑。`, effectiveChatContext);
                                updateChatInputLockState('ai_blocked_user');
                            } else if (value === 'unblock_user') {
                                senderProfile.blockedStatus = 'none';
                                await kokoMemory.put('contacts', senderProfile);
                                await createSystemNotification(`${senderProfile.name} 已将你解除拉黑。`, effectiveChatContext);
                                updateChatInputLockState('none');
                            }
                            processed = true;
                            // (这个是系统动作，不需要延迟)
                            break;
                        case 'recall': {
                            const recalledText = value.trim();
                            if (recalledText) {
                                await createAndAddMessage({
                                    type: 'recall_ai',
                                    content: recalledText,
                                    isRevealed: false
                                }, senderProfile.id, effectiveChatContext, false, 'chat');
                            }
                            processed = true;
                            await sleep(400 + Math.random() * 400); // ✨ 延迟
                            break;
                        }
                    }
                }

                if (!processed) {
                    // 这才是真正的【普通文本行】
                    await createAndAddMessage({ type: 'text', content: line }, senderProfile.id, effectiveChatContext, false, 'chat');
                    // ✨ 核心修复：只在发送消息后才延迟
                    await sleep(400 + Math.random() * 400); 
                }
            }
        }
        
        // 循环结束后，检查缓冲区是否还有“未闭合”的HTML
        if (inHtmlBlock) {
            console.warn("AI发送了未闭合的HTML块，已强制输出。");
            await createAndAddMessage({
                type: 'html',
                content: htmlBuffer.join('\n')
            }, senderProfile.id, effectiveChatContext, false, 'chat');
            // ✨ 核心修复：补上这里的延迟
            await sleep(400 + Math.random() * 400); 
        }
        
        // --- 智能缓冲循环 V4 结束 ---
    }
// ▲▲▲ 替换到这里结束 ▲▲▲
    }
 // --- (替换) renderPostDetail 函数 (V2.1 - 支持评论图片) ---
        async function renderPostDetail() {
            const post = state.posts.find(p => p.id === state.activePostId);
            if (!post) {
                showFeedScreen();
                return;
            }
            const container = document.getElementById('post-detail-container');
            const commentsList = document.getElementById('comments-list');
            container.innerHTML = '';
            commentsList.innerHTML = '';

            // (渲染帖子本身的逻辑保持不变)
            const postItemEl = createPostItem(post, true); 
            if (postItemEl) {
                container.appendChild(postItemEl);
                container.querySelector('.like-btn')?.addEventListener('click', toggleLike);
                container.querySelector('.post-delete-btn')?.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const postId = e.currentTarget.dataset.postId;
                    if(confirm('确定要删除这条动态吗？')) { // 这里可以换成 showCustomConfirm
                        state.posts = state.posts.filter(p => p.id !== postId);
                        await kokoMemory.delete('posts', postId);
                        await showFeedScreen();
                    }
                });
                postItemEl.addEventListener('click', (e) => {
                    if (!e.target.closest('.post-action-btn, .mention, .post-delete-btn, .post-image-content')) { // 修正：点击图片也不聚焦
                         document.getElementById('comment-input').focus();
                    }
                });
            }
            
            if (post.comments.length > 0) {
                const sortedComments = [...post.comments].sort((a,b) => a.timestamp - b.timestamp);
                sortedComments.forEach(comment => {
                    const author = comment.author;
                    if (!author) return;

                    // ▼▼▼ 新增的评论图片逻辑 ▼▼▼
                    let commentImageHTML = '';
                    if (comment.image) {
                        commentImageHTML = `<img src="${comment.image}" class="comment-image-content">`;
                    }
                    // ▲▲▲ 新增结束 ▲▲▲

                    const commentEl = document.createElement('div');
                    commentEl.className = 'post-comment-item';
                    commentEl.dataset.authorName = author.name; 
                    commentEl.dataset.authorId = author.id;
                    
                    commentEl.innerHTML = `
                        <div style="display: flex; gap: 10px;">
                            <img src="${author.avatar}" style="width: 35px; height: 35px; border-radius: 50%;">
                            <div style="flex-grow: 1;">
                                <div>
                                    <span class="comment-author">${author.name}</span>
                                    ${comment.replyTo ? `<span class="comment-reply-to">回复 @${comment.replyTo}</span>` : ''}
                                </div>
                                <div class="comment-content">${parseMentions(comment.content)}</div>
                                
                                ${commentImageHTML} <div class="comment-meta">
                                    <span>${formatTimeAgo(comment.timestamp)}</span>
                                    <span class="comment-delete-btn" data-comment-id="${comment.id}"><i class="fas fa-trash-alt"></i> 删除</span>
                                </div>
                            </div>
                        </div>
                    `;

                    commentsList.appendChild(commentEl);
                });
            } else {
                commentsList.innerHTML = `<div style="text-align: center; color: #999; padding: 20px;">还没有评论，快来抢沙发吧！</div>`;
            }
        }
        function triggerPetAnimation(animationType) {
            const petElements = document.querySelectorAll('.slime');
            petElements.forEach(slimeEl => {
                if (animationType === 'jiggle') {
                    slimeEl.classList.add('happy-jiggle');
                    setTimeout(() => slimeEl.classList.remove('happy-jiggle'), 500);
                }
                if (animationType === 'blush') {
                    slimeEl.classList.add('is-blushing');
                    setTimeout(() => slimeEl.classList.remove('is-blushing'), 2000);
                }
            });
        }
        // --- 新增：显示和取消回复预览的函数 ---
// --- 最终完美的 showReplyPreview 函数 ---
function showReplyPreview(message) {
    const previewBar = document.getElementById('reply-preview-bar');
    const currentChat = state.contacts.find(c => c.id === state.activeChatId);
    let senderName;

    if (message.sender === 'user') {
        // 发送者是用户自己，这部分逻辑不变
        senderName = state.myProfile.name;
    } else if (currentChat && currentChat.isGroup) {
        // 如果是群聊，使用我们上次修复的逻辑，根据消息的 sender ID 查找具体成员
        const senderContact = state.contacts.find(c => c.id === message.sender);
        senderName = senderContact ? senderContact.name : '未知成员';
    } else {
        // 如果是私聊，使用最简单的老逻辑，发送者就是当前聊天对象
        senderName = currentChat ? currentChat.name : '未知成员';
    }

    previewBar.innerHTML = `
        <div id="reply-preview-content">
            回复 <span class="sender">${senderName}</span>: ${message.content}
        </div>
        <div id="cancel-reply-btn">&times;</div>
    `;
    previewBar.style.display = 'flex';

    document.getElementById('cancel-reply-btn').addEventListener('click', cancelReply, { once: true });
}

function cancelReply() {
    activeReplyTarget = null;
    const previewBar = document.getElementById('reply-preview-bar');
    previewBar.style.display = 'none';
    previewBar.innerHTML = '';
}
// ==========================================================
// V17.0 新增：视频通话核心管理函数 (已整合我们的优化方案)
// ==========================================================
async function startVideoCall(contactId, initiatedBy = 'user') {
    if (state.activeCall) return; 
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) return;

    if (initiatedBy === 'user') {
        const decisionPrompt = `[SYSTEM: 用户正在向你发起视频通话请求。根据你们最近的对话和你当前的心情，请用一个词决定是否接听：“接听”或“拒绝”。\n\n- 如果你现在很忙、生气或不想说话，就回复“拒绝”。\n- 否则，回复“接听”。\n\n不要添加任何其他文字，只回复这两个词中的一个。]`;
        const decision = await generateAiResponse(contact, contact.history, decisionPrompt);
        if (decision.includes('拒绝')) {
            await createAndAddMessage({ type: 'system_notification', sender: 'system', content: `${contact.name} 现在不想接电话` });
            await requestAiReply(`[SYSTEM: 你刚刚拒绝了用户的视频通话请求，请发送一条简短的文字消息向用户解释原因（例如：在忙、心情不好等）。]`);
            return;
        }
    }
    
    state.activeCall = {
        contactId: contact.id,
        startTime: Date.now(),
        isCharCameraOff: false,
        initiatedBy: initiatedBy // 记录发起者
    };

    const videoScreen = document.getElementById('video-call-screen');
    document.getElementById('call-contact-name').textContent = contact.name;
    document.getElementById('narrative-feed').innerHTML = '<p class="narrative-action">*正在接通...*</p>';
    videoScreen.style.display = 'flex';
    
    // 永久记录通话开始事件
    const startMessage = initiatedBy === 'user' ? `你向 ${contact.name} 发起了视频通话` : `${contact.name} 向你发起了视频通话`;
    await createAndAddMessage({ type: 'system_notification', sender: 'system', content: startMessage });

    if (callTimerInterval) clearInterval(callTimerInterval);
    callTimerInterval = setInterval(updateCallUI, 1000);
    updateCallUI();

    // 如果是用户发起的，让AI先开口
    if (initiatedBy === 'user') {
        await requestAiReply(`[SYSTEM: 视频通话已接通。你必须主动说第一句话来打破沉默，可以是一句问候，或者描述你看到的场景。例如：“喂？听得到吗？我看到你啦！”]`);
    }
}

// ✨ 解决方案 ✨
async function endVideoCall(endedBy = 'user', reason = '通话已挂断') {
    if (!state.activeCall) return;

    const duration = Math.floor((Date.now() - state.activeCall.startTime) / 1000);
    const contactId = state.activeCall.contactId;
    
    // 1. 在这里获取完整的 contact 对象
    const contact = state.contacts.find(c => c.id === contactId); 

    state.activeCall = null;
    
    clearInterval(callTimerInterval);
    callTimerInterval = null;
    
    document.getElementById('video-call-screen').style.display = 'none';
    state.activeChatId = contactId;

    const durationMinutes = Math.floor(duration / 60);
    const durationSeconds = duration % 60;
    const durationText = `通话时长 ${durationMinutes}分${durationSeconds}秒`;

    // 2. 在调用时，把 contact 作为第三个参数传进去
    await createAndAddMessage({ type: 'system_notification', sender: 'system', content: `${reason}，${durationText}` }, 'system', contact, false, 'chat'); 
    
    await createAndAddMessage({ type: 'text', content: '[SYSTEM: 通话已正式结束，立刻恢复标准聊天模式。]' }, 'system_instruction', contact, false, 'chat');

    if (endedBy === 'user') {
        // (这部分功能可以保留或根据你的需要调整)
        // await requestAiReply(`[SYSTEM: 用户刚刚挂断了视频通话。请你对此发表一句简短的感想或道别。]`);
    }
}
function updateCallUI() {
    if (!state.activeCall) return;
    const duration = Math.floor((Date.now() - state.activeCall.startTime) / 1000);
    const min = Math.floor(duration / 60).toString().padStart(2, '0');
    const sec = (duration % 60).toString().padStart(2, '0');
    const timeString = `${min}:${sec}`;
    document.getElementById('call-status').textContent = `通话中 ${timeString}`;
}

function handleIncomingCall(contact) {
    if (state.activeCall) return;
    const screen = document.getElementById('incoming-call-screen');
    document.getElementById('incoming-caller-avatar').src = contact.avatar;
    document.getElementById('incoming-caller-name').textContent = contact.name;
    screen.style.display = 'flex';

    // 使用克隆节点的方式，防止重复绑定事件
    const oldAcceptBtn = document.getElementById('accept-call-btn');
    const newAcceptBtn = oldAcceptBtn.cloneNode(true);
    oldAcceptBtn.parentNode.replaceChild(newAcceptBtn, oldAcceptBtn);
    newAcceptBtn.addEventListener('click', () => {
        screen.style.display = 'none';
        startVideoCall(contact.id, 'contact');
    });

    const oldDeclineBtn = document.getElementById('decline-call-btn');
    const newDeclineBtn = oldDeclineBtn.cloneNode(true);
    oldDeclineBtn.parentNode.replaceChild(newDeclineBtn, oldDeclineBtn);
    newDeclineBtn.addEventListener('click', async () => {
        screen.style.display = 'none';
        await createAndAddMessage({ type: 'system_notification', sender: 'system', content: `你拒接了 ${contact.name} 的视频通话` }, 'system', contact, false, 'chat');
        //await requestAiReply(`[SYSTEM: 用户刚刚拒接了你的视频通话请求。你可能会感到失落或好奇，请发送一条文字消息询问原因。]`);
    });
}

// ▼▼▼ 使用这个【新版本】替换掉你原来的 sendVideoCallMessage 函数 ▼▼▼
async function sendVideoCallMessage() {
    if (!state.activeCall) return;
    const input = document.getElementById('video-call-input');
    const content = input.value.trim();
    if (!content) return;

    // 定位到当前通话的联系人
    const contact = state.contacts.find(c => c.id === state.activeCall.contactId);
    if (!contact) return;

    // 使用我们之前修复好的方式，明确指定消息的接收者
    await createAndAddMessage({ type: 'video_call_text', content: content }, 'user', contact, false, 'chat');

    const narrativeFeed = document.getElementById('narrative-feed');
    narrativeFeed.innerHTML += `<div class="user-message"><p>${content}</p></div>`;
    narrativeFeed.scrollTop = narrativeFeed.scrollHeight;
    input.value = '';
    
    // 关键修复！在请求AI回复时，把当前通话对象的ID传进去！
    await requestAiReply(null, state.activeCall.contactId); 
}
        
// --- 新增：处理消息编辑的核心函数（智能版，支持语音） ---
async function handleEditMessage(messageId) {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    const message = contact.history.find(m => m.id === messageId);
    if (!message) return;

    // 1. 根据消息类型，智能获取当前的可编辑文本
    let currentText = '';
    if (message.type === 'voice') {
        currentText = message.content.text;
    } else { // 适用于 'text' 和 'html' 类型
        currentText = message.content;
    }

    // 2. 弹出编辑框，让用户输入新内容
    const newText = await showCustomPrompt('编辑消息', currentText);

    // 3. 如果用户点击了 "确定" 并且内容有变化
    if (newText !== null && newText.trim() !== currentText) {
        const trimmedNewText = newText.trim();

        // 4. 根据消息类型，智能地更新数据结构
        if (message.type === 'voice') {
            message.content.text = trimmedNewText;
            // 关键：重新计算并更新语音时长，这样气泡宽度也会自动变化
            message.content.duration = Math.max(1, Math.round(trimmedNewText.length / 4));
        } else { // 'text' 或 'html'
            message.content = trimmedNewText;
        }

        // 5. 保存修改到数据库，并刷新聊天界面
        await kokoMemory.put('contacts', contact);
        await openChat(state.activeChatId); // 重新渲染聊天，让修改生效
    }
}
/**
 * 渲染API预设下拉菜单
 */
async function renderApiPresetDropdown() {
    const selectEl = document.getElementById('api-preset-select');
    selectEl.innerHTML = '<option value="">-- 手动配置或选择预设 --</option>'; // 重置
    state.apiPresets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        selectEl.appendChild(option);
    });
}

/**
 * 显示API预设管理页面
 */
async function showApiPresetManagementScreen() {
    hideAllScreens();
    document.getElementById('api-preset-management-screen').style.display = 'flex';
    await renderApiPresetsList();
}

/**
 * 渲染API预设管理列表
 */
async function renderApiPresetsList() {
    const listEl = document.getElementById('api-presets-list');
    const noPresetMsg = document.getElementById('no-api-preset-message');
    listEl.innerHTML = '';

    if (state.apiPresets.length === 0) {
        noPresetMsg.style.display = 'block';
    } else {
        noPresetMsg.style.display = 'none';
        state.apiPresets.forEach(preset => {
            const item = document.createElement('div');
            item.className = 'preset-item';
            item.dataset.presetId = preset.id;
            item.innerHTML = `
                <div class="preset-info">
                    <div class="preset-name">${preset.name}</div>
                    <div class="preset-desc" style="font-size: 12px; color: #888;">
                        Endpoint: ${preset.endpoint || '未设置'}
                    </div>
                </div>
                <div class="preset-actions">
                    <span class="preset-action-btn delete delete-api-preset-btn" title="删除预设">
                        <i class="fas fa-trash-alt"></i>
                    </span>
                </div>
            `;
            listEl.appendChild(item);
        });
    }

    // 为所有删除按钮绑定事件
    listEl.querySelectorAll('.delete-api-preset-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const presetId = e.currentTarget.closest('.preset-item').dataset.presetId;
            const confirmed = await showCustomConfirm('删除预设', '确定要删除这个API预设吗？', true);
            if (confirmed) {
                state.apiPresets = state.apiPresets.filter(p => p.id !== presetId);
                await kokoMemory.delete('apiPresets', presetId);
                await renderApiPresetsList(); // 重新渲染列表
            }
        });
    });
}
// --- 新增：回溯功能核心函数 ---
async function handleRewind() {
    if (!state.activeChatId) return;
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact || !contact.history || contact.history.length === 0) return;

    // 1. 从后往前，找到你（用户）发送的最后一条消息的索引
    let lastUserMessageIndex = -1;
    for (let i = contact.history.length - 1; i >= 0; i--) {
        if (contact.history[i].sender === 'user') {
            lastUserMessageIndex = i;
            break;
        }
    }

    // 2. 处理边界情况
    if (lastUserMessageIndex === -1) {
        alert("聊天记录中没有你的消息，无法回溯。");
        return;
    }

    // 如果最后一条消息就是用户发的，说明AI还没回复，也无需回溯
    if (lastUserMessageIndex === contact.history.length - 1) {
        alert("AI 还未回复，无需回溯。");
        return;
    }

    // 3. 弹窗向用户确认，防止误触
    const confirmed = await showCustomConfirm(
        '确认回溯',
        '这将清除AI的最后一次回复，并让它重新生成一次。确定要继续吗？',
        false // false 表示这不是一个危险的红色按钮
    );

    if (confirmed) {
        // 4. 截取历史记录，保留到用户最后一条消息
        contact.history = contact.history.slice(0, lastUserMessageIndex + 1);

        // 5. 保存修改并刷新聊天界面
        await kokoMemory.put('contacts', contact);
        await openChat(contact.id); // 这会用截断后的历史记录重新渲染聊天界面

        // 6. 重新请求AI回复
        await requestAiReply();
    }
}
// --- 新增：手动总结聊天记录功能核心函数 ---
async function handleChatSummarization() {
    if (!state.activeChatId) return;
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact || !contact.history || contact.history.length === 0) {
        return alert('当前没有聊天记录可供总结。');
    }

    // 1. 查找上一次总结的位置 (方案B)
    const SUMMARY_MARKER_PREFIX = '--- 之前的记录已于';
    const lastMarkerIndex = contact.history.findLastIndex(msg =>
        msg.type === 'system_notification' && msg.content.startsWith(SUMMARY_MARKER_PREFIX)
    );

    const startIndex = lastMarkerIndex === -1 ? 0 : lastMarkerIndex + 1;
    const messagesToSummarize = contact.history.slice(startIndex);

    if (messagesToSummarize.length < 5) { // 如果新消息太少，就不总结
        return alert('新的聊天记录太少，还不需要总结哦。');
    }

    // 2. 准备世界书和前情提要
    const bookName = `《聊天总结: ${contact.name}》`;
    const summaryBook = state.worldBooks.find(b => b.name === bookName);
    const previous_summary = summaryBook ? summaryBook.content : '(无前情提要)';

    // 3. 构建提示词 (Prompt)
    const chat_history_text = messagesToSummarize
        .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction') // 只总结文本消息
        .map(msg => `${msg.sender === 'user' ? state.myProfile.name : contact.name}: ${msg.content}`)
        .join('\n');

    const prompt = `[SYSTEM]
你的任务是扮演一位专业的叙事总结师。你的目标是客观、精炼地将下方提供的聊天记录，整理成一段连贯的、以第三人称视角叙述的“故事摘要”。

# 背景信息
- 用户名: ${state.myProfile.name}
- 角色名: ${contact.name}
- 前情提要 (上次总结的内容): 
${previous_summary}

# 聊天记录
以下是自上次总结以来，${state.myProfile.name} 与 ${contact.name} 之间发生的对话：
---
${chat_history_text}
---

# 你的任务
请仔细阅读上述聊天记录，并遵循以下要求，生成一段新的故事摘要：

1.  **核心事件提炼:** 识别并描述这段对话中发生的关键事件、转折点或重要行动。
2.  **情感与关系变化:** 捕捉并记录双方情绪上的主要变化、关系的进展（如变得更亲密、产生误会、关系紧张等）。
3.  **关键信息与设定:** 记录任何新出现的、对未来故事重要的信息、设定、约定或秘密。
4.  **叙事风格:** 必须使用第三人称、过去时进行叙述。文笔风格请参考细腻的女性向文学作品。
5.  **保持客观:** 只总结聊天记录中明确发生或提到的事，不要进行过度的猜测或主观臆断。
6.  **忽略不重要的内容:** 省略日常的问候（如“你好”、“在吗”）、无意义的闲聊和重复信息。

# 输出格式
请直接输出总结好的故事摘要文本，不要添加任何额外的解释或标题。`;

    // 4. 调用AI并处理结果
    const chatStatusEl = document.getElementById('chat-contact-status');
    const originalStatus = chatStatusEl.textContent;
    chatStatusEl.textContent = 'AI 正在总结中...';

    try {
        const summaryText = await generateAiResponse(contact, [], prompt, false, 'chat');
        
        // 5. 将总结存入世界书
        const summaryDate = new Date().toLocaleString('zh-CN', { hour12: false });
        const newSummaryEntry = `\n\n--- 总结于 ${summaryDate} ---\n${summaryText}`;

        if (summaryBook) {
            // 如果已存在，则追加内容
            summaryBook.content += newSummaryEntry;
            await kokoMemory.put('worldBooks', summaryBook);
        } else {
            // 如果不存在，则新建
            const newBook = {
                id: 'summary_book_' + contact.id, // 使用联系人ID确保唯一性
                name: bookName,
                content: newSummaryEntry.trim()
            };
            state.worldBooks.push(newBook);
            await kokoMemory.put('worldBooks', newBook);
            // 需要更新所有用到世界书的下拉选择器
            await updateWorldBookSelectors();
        }

        // 6. 在聊天记录中添加标记
        await createSystemNotification(`${SUMMARY_MARKER_PREFIX} ${summaryDate} ---`);

        alert(`聊天记录已成功总结，并存入世界书 ${bookName}！`);

    } catch (error) {
        console.error("聊天总结失败:", error);
        alert(`总结失败: ${error.message}`);
    } finally {
        chatStatusEl.textContent = originalStatus;
    }
}
// ==========================================================
// =========== ▼▼▼ 论坛档案馆 - 核心功能函数 ▼▼▼ ============
// ==========================================================

// 函数：显示论坛档案馆页面
async function showForumArchivesScreen() {
    hideAllScreens();
    document.getElementById('forum-archives-screen').style.display = 'flex';
    await renderForumArchivesList();
}

// 函数：渲染存档列表
async function renderForumArchivesList() {
    const listEl = document.getElementById('forum-archives-list');
    const noArchivesMsg = document.getElementById('no-forum-archives-message');
    listEl.innerHTML = '';

    // 始终在列表顶部显示“默认世界”
    const defaultArchiveItem = document.createElement('div');
    defaultArchiveItem.className = 'preset-item';
    defaultArchiveItem.dataset.archiveId = 'default';
    const isDefaultActive = state.activeForumArchiveId === 'default';
    defaultArchiveItem.innerHTML = `
        <div class="preset-info">
            <div class="preset-name">默认世界 (当前)</div>
            <div class="preset-desc">未存档的即时世界线</div>
        </div>
        <div class="preset-actions">
            <span class="preset-action-btn switch-archive-btn ${isDefaultActive ? 'active' : ''}" title="切换到此世界线">
                <i class="fas fa-power-off"></i>
            </span>
        </div>`;
    listEl.appendChild(defaultArchiveItem);

    // 渲染其他已保存的存档
    if (state.forumArchives.length === 0) {
        noArchivesMsg.style.display = 'block';
    } else {
        noArchivesMsg.style.display = 'none';
        state.forumArchives.forEach(archive => {
            const isActive = state.activeForumArchiveId === archive.id;
            const item = document.createElement('div');
            item.className = 'preset-item';
            item.dataset.archiveId = archive.id;
            item.innerHTML = `
                <div class="preset-info">
                    <div class="preset-name">${archive.name}</div>
                    <div class="preset-desc">${new Date(archive.timestamp).toLocaleString()} 存档</div>
                </div>
                <div class="preset-actions">
                    <span class="preset-action-btn switch-archive-btn ${isActive ? 'active' : ''}" title="切换到此世界线">
                        <i class="fas fa-power-off"></i>
                    </span>
                    <span class="preset-action-btn delete delete-archive-btn" title="删除此存档">
                        <i class="fas fa-trash-alt"></i>
                    </span>
                </div>`;
            listEl.appendChild(item);
        });
    }
}

// 函数：切换活动的世界线 (V4 - 持久化选择版)
async function switchForumArchive(archiveId) {
    if (state.activeForumArchiveId === archiveId) return; 

    let settingsToRestore;
    let archiveName;

    if (archiveId === 'default') {
        settingsToRestore = await kokoMemory.get('forumSettings', 'main');
        if (!settingsToRestore) {
            settingsToRestore = JSON.parse(JSON.stringify(INITIAL_STATE.forumSettings));
        }
        archiveName = '默认世界';
    } else {
        const archive = state.forumArchives.find(a => a.id === archiveId);
        if (!archive || !archive.settings) {
            alert('错误：找不到该存档或存档数据已损坏。');
            return;
        }
        settingsToRestore = archive.settings;
        archiveName = archive.name;
    }

    state.forumSettings = Object.assign({}, state.forumSettings, settingsToRestore);
    await kokoMemory.put('forumSettings', { id: 'main', ...state.forumSettings });

    // 更新 state，标记当前激活的世界线ID
    state.activeForumArchiveId = archiveId;

    // 【核心修复 - 第1部分：保存选择】
    // 将当前激活的存档ID保存到 userSettings 表中，实现持久化
    const settings = await kokoMemory.get('userSettings', 'main') || { id: 'main' };
    settings.activeForumArchiveId = archiveId;
    await kokoMemory.put('userSettings', settings);
    
    // 重置论坛的标签页状态到默认值
    state.activeFeedTab = 'recommended';
    state.activeFeedSubTab = 'daily';

    await renderForumArchivesList();
    alert(`已成功切换到世界线: ${archiveName}。\n\n相关的论坛设定（用户面具、世界书等）已同步更新。`);
}

// 函数：删除一个存档及其所有相关帖子
async function deleteForumArchive(archiveId) {
    const archive = state.forumArchives.find(a => a.id === archiveId);
    if (!archive) return;

    const confirmed = await showCustomConfirm(
        '删除确认',
        `⚠️ 确定要永久删除存档“${archive.name}”吗？\n\n这将同时删除该世界线下的【所有帖子】，此操作无法恢复！`,
        true
    );

    if (confirmed) {
        // 1. 从 state 中删除存档
        state.forumArchives = state.forumArchives.filter(a => a.id !== archiveId);
        // 2. 从数据库中删除存档
        await kokoMemory.delete('forumArchives', archiveId);

        // 3. 从 state 中删除与该存档关联的所有帖子
        state.posts = state.posts.filter(p => p.archiveId !== archiveId);
        // 4. 从数据库中删除这些帖子 (这是一个批量删除操作)
        const allPosts = await kokoMemory.getAll('posts');
        const postsToDelete = allPosts.filter(p => p.archiveId === archiveId);
        for (const post of postsToDelete) {
            await kokoMemory.delete('posts', post.id);
        }

        // 5. 如果被删除的是当前激活的存档，则自动切换回默认世界
        if (state.activeForumArchiveId === archiveId) {
            state.activeForumArchiveId = 'default';
        }

        // 6. 重新渲染存档列表
        await renderForumArchivesList();
    }
}

// ==========================================================
// --- 幸运字符 UI 逻辑 ---

// 1. 打开仓库弹窗函数
async function openLuckyCharModal(contact) {
    const modal = document.getElementById('lucky-char-modal');
    const listEl = document.getElementById('lucky-char-list');
    const tipsEl = document.getElementById('lucky-draw-tips');
    
    // 更新剩余次数提示
    if (!contact.luckyCharGacha) contact.luckyCharGacha = { count: 0, lastDate: "" };
    const today = new Date().toLocaleDateString();
    if (contact.luckyCharGacha.lastDate !== today) contact.luckyCharGacha.count = 0;
    const left = 3 - contact.luckyCharGacha.count;
    tipsEl.textContent = `今日剩余抽取次数：${left} 次`;

    // 渲染列表
    renderLuckyCharList(contact, listEl);

    // 绑定抽取按钮
    const drawBtn = document.getElementById('draw-lucky-char-btn');
    // 克隆以防重复绑定
    const newDrawBtn = drawBtn.cloneNode(true);
    drawBtn.parentNode.replaceChild(newDrawBtn, drawBtn);
    
    newDrawBtn.addEventListener('click', async () => {
        newDrawBtn.disabled = true;
        newDrawBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 祈祷中...';
        
        await sleep(1000); // 仪式感
        
        const newChar = await drawLuckyCharacter(contact);
        
        newDrawBtn.disabled = false;
        newDrawBtn.innerHTML = '<i class="fas fa-magic"></i> 抽取新字符';
        
        if (newChar) {
            // 抽到了！
            alert(`🎉 欧皇时刻！\n你获得了【${newChar.word}】(${newChar.meaning})！\n稀有度: ${newChar.type.toUpperCase()}`);
            // 刷新UI
            openLuckyCharModal(contact); // 重新加载弹窗内容
            openChat(contact.id); // 刷新聊天界面顶栏
        } else {
            // 没抽到或次数没了，只刷新次数提示
            openLuckyCharModal(contact); 
        }
    });

    // 绑定关闭
    document.getElementById('close-lucky-char-modal').onclick = () => modal.style.display = 'none';
    
    modal.style.display = 'flex';
}

// 2. 渲染列表子函数
function renderLuckyCharList(contact, container) {
    container.innerHTML = '';
    const inventory = contact.luckyCharInventory || [];
    const equippedId = contact.luckyChar ? contact.luckyChar.word : null; // 用word做唯一标识

    if (inventory.length === 0) {
        container.innerHTML = '<p style="text-align:center; color:#999;">仓库是空的，快去抽取吧！</p>';
        return;
    }

    // 按稀有度排序 (Epic > Rare > Common)
    const typeOrder = { epic: 3, rare: 2, common: 1 };
    inventory.sort((a, b) => typeOrder[b.type] - typeOrder[a.type]);

    inventory.forEach(char => {
        const item = document.createElement('div');
        const isEquipped = equippedId === char.word;
        item.className = `lucky-char-card ${isEquipped ? 'equipped' : ''}`;
        
        // 构建字母预览
        let lettersHTML = '';
        for (let i = 0; i < char.word.length; i++) {
            const status = i < char.unlockedCount ? 'unlocked' : 'locked';
            // 在列表里我们不需要那么大的光效，简单显示即可
            // 为了复用样式，我们需要包裹在一个 badge 容器里
            lettersHTML += `<span class="char-letter ${status}">${char.word[i]}</span>`;
        }

        item.innerHTML = `
            <div class="lucky-char-info">
                <div class="lucky-char-badge lucky-char-${char.type} ${char.isCompleted ? 'completed' : ''}">
                    ${lettersHTML}
                </div>
                <div class="lucky-char-meaning">${char.meaning} (${char.unlockedCount}/${char.word.length})</div>
            </div>
            <div class="lucky-char-actions">
                ${isEquipped 
                    ? `<button class="btn-unequip" disabled>佩戴中</button>` 
                    : `<button class="btn-equip" data-word="${char.word}">佩戴</button>`
                }
            </div>
        `;
        
        // 绑定佩戴事件
        if (!isEquipped) {
            item.querySelector('.btn-equip').addEventListener('click', async () => {
                contact.luckyChar = char; // 切换引用
                await kokoMemory.put('contacts', contact);
                renderLuckyCharList(contact, container); // 刷新列表状态
                openChat(contact.id); // 刷新聊天界面顶栏
            });
        }

        container.appendChild(item);
    });
}
// =========== ▲▲▲ 论坛档案馆 - 核心功能函数 END ▲▲▲ =========
// ==========================================================
// ==========================================================
// V-Final 新增: 锁屏功能逻辑
// ==========================================================
let lockScreenClockInterval = null; // 用于存放时钟的定时器
let photoCarouselInterval = null;   // ▼▼▼ 新增下面这两行 ▼▼▼
let currentPhotoIndex = 0;
let inactivityTimer = null;
/**
 * 更新锁屏上的时间和日期
 */
function updateLockScreenTime() {
    const timeEl = document.getElementById('lock-screen-time');
    const dateEl = document.getElementById('lock-screen-date');
    if (!timeEl || !dateEl) return;

    const now = new Date();
    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const dayNames = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
    
    timeEl.textContent = `${hours}:${minutes}`;
    dateEl.textContent = `${now.getMonth() + 1}月${now.getDate()}日 ${dayNames[now.getDay()]}`;
}
// ==========================================================
// V-Final 新增: 锁屏组件内容更新函数
// ==========================================================
async function updateLockScreenWidgets() {
    // 1. 读取并显示备忘录
    const memoEl = document.getElementById('lock-screen-memo');
    if (!window.userSettings) window.userSettings = { id: 'main' }; 
    if (userSettings.lockScreenMemo) { memoEl.textContent = userSettings.lockScreenMemo; } 
    else { memoEl.textContent = '点击这里编辑你的备忘录...'; }

    // 2. 处理置顶纪念日/倒数日
    const countdownDaysEl = document.querySelector('#lock-screen-countdown .countdown-days');
    const countdownLabelEl = document.querySelector('#lock-screen-countdown .countdown-label');
    let pinnedEvent = null;
    for (const contact of state.contacts) {
        if (contact.events && contact.events.length > 0) {
            const foundEvent = contact.events.find(event => event.isPinned);
            if (foundEvent) { pinnedEvent = foundEvent; break; }
        }
    }
    if (pinnedEvent) {
        const today = new Date(); today.setHours(0, 0, 0, 0);
        const eventDate = new Date(pinnedEvent.date); eventDate.setHours(0, 0, 0, 0);
        const diff = (eventDate - today) / (1000 * 60 * 60 * 24);
        countdownDaysEl.textContent = Math.round(Math.abs(diff));
        if (diff >= 0) { countdownLabelEl.textContent = `距离 ${pinnedEvent.eventName} 还有`; } 
        else { countdownLabelEl.textContent = `${pinnedEvent.eventName} 已经`; }
    } else {
        countdownDaysEl.textContent = 'Pin!';
        countdownLabelEl.textContent = "去“我们的日子”置顶一个纪念日吧";
    }

    // 3. 处理所有未读消息
    const notificationWidget = document.getElementById('lock-screen-notification-widget');
    const notificationTextEl = document.getElementById('lock-screen-notification-text');
    let allUnreadMessages = [];
    state.contacts.forEach(contact => {
        if (contact.unreadCount > 0 && contact.history.length > 0) {
            const unreadMessages = contact.history.slice(-contact.unreadCount);
            unreadMessages.forEach(msg => {
                let contentPreview = msg.content;
                switch (msg.type) {
                    case 'image': case 'picture_description': contentPreview = '[图片]'; break;
                    case 'voice': contentPreview = '[语音消息]'; break;
                    case 'red_packet': contentPreview = `[红包] ${msg.content.blessing}`; break;
                }
                allUnreadMessages.push({
                    timestamp: msg.timestamp,
                    text: `<div>${contact.name}: ${contentPreview}</div>`
                });
            });
        }
    });
    if (allUnreadMessages.length > 0) {
        allUnreadMessages.sort((a, b) => a.timestamp - b.timestamp);
        const fullNotificationHTML = allUnreadMessages.map(msg => msg.text).join('');
        notificationTextEl.innerHTML = fullNotificationHTML;
        notificationWidget.style.display = 'flex';
        const animationDuration = Math.max(8, allUnreadMessages.length * 4);
        notificationTextEl.style.animationDuration = `${animationDuration}s`;
    } else {
        notificationWidget.style.display = 'none';
    }
}

/**
 * 显示锁屏界面 (V10 - 重构版)
 */
async function showLockScreen() {
    if (inactivityTimer) { clearTimeout(inactivityTimer); inactivityTimer = null; }

    const lockScreenEl = document.getElementById('lock-screen');
    const backgroundEl = document.querySelector('.lock-screen-background');

    // 设置智能背景
    let backgroundUrl = 'https://i.postimg.cc/SQ3DH79X/MEITU-20250811-151831796.jpg';
    if (userSettings && userSettings.chatBackground) { backgroundUrl = userSettings.chatBackground; }
    const lastContact = state.contacts.find(c => c.id === state.activeChatId);
    if (lastContact && lastContact.customChatBackground) { backgroundUrl = lastContact.customChatBackground; }
    backgroundEl.style.backgroundImage = `url(${backgroundUrl})`;

    // ▼▼▼ 核心改动：直接调用我们的新函数来更新所有组件 ▼▼▼
    await updateLockScreenWidgets();
    // ▲▲▲ 改动结束 ▲▲▲

    // 显示锁屏和启动其他功能 (不变)
    lockScreenEl.style.display = 'flex';
    setTimeout(() => { lockScreenEl.classList.remove('hidden'); }, 10);
    if (!lockScreenClockInterval) {
        updateLockScreenTime();
        lockScreenClockInterval = setInterval(updateLockScreenTime, 1000);
    }
    startPhotoCarousel();
}

/**
 * 隐藏锁屏界面
 */
function hideLockScreen() {
    const lockScreenEl = document.getElementById('lock-screen');
    lockScreenEl.classList.add('hidden');

    // ▼▼▼ 在这里添加新代码 ▼▼▼
    // 停止照片轮播的定时器
    if (photoCarouselInterval) {
        clearInterval(photoCarouselInterval);
        photoCarouselInterval = null;
    }
    // ▲▲▲ 新增结束 ▲▲▲

    setTimeout(() => {
        lockScreenEl.style.display = 'none';
    }, 500);
    // ▼▼▼ 新增：解锁后，开始无活动计时 ▼▼▼
    resetInactivityTimer();
    // ▲▲▲ 新增结束 ▲▲▲
}

// 为锁屏界面绑定“解锁”事件 (V2 - 备忘录兼容版)
document.getElementById('lock-screen').addEventListener('click', (e) => {
    // 如果我们点击的目标是正在编辑的备忘录输入框，则不执行解锁操作
    if (e.target.id === 'memo-edit-textarea') {
        return;
    }
    hideLockScreen();
});
// ==========================================================
// ==========================================================
// V-Final 新增: 锁屏备忘录编辑功能
// ==========================================================
const memoContainer = document.getElementById('lock-screen-memo');

memoContainer.addEventListener('click', function(event) {
    // 阻止点击事件冒泡，防止点击备忘录时直接解锁屏幕
    event.stopPropagation();

    // 如果当前已经是编辑模式，就什么都不做
    if (document.getElementById('memo-edit-textarea')) {
        return;
    }

    const currentText = memoContainer.textContent;
    
    // 创建一个textarea输入框
    const textarea = document.createElement('textarea');
    textarea.id = 'memo-edit-textarea';
    textarea.value = (currentText === '点击这里编辑你的备忘录...') ? '' : currentText;
    
    // 应用一些和显示文本差不多的样式
    textarea.style.cssText = `
        width: 100%;
        height: 100%;
        border: none;
        background-color: transparent;
        color: white;
        font-family: inherit;
        font-size: 15px;
        line-height: 1.6;
        resize: none;
        outline: none;
        padding: 0;
        margin: 0;
    `;

    // 替换显示区域为输入框
    memoContainer.innerHTML = '';
    memoContainer.appendChild(textarea);
    textarea.focus(); // 自动聚焦，让用户可以直接输入

    // 当输入框失去焦点时 (例如点击了其他地方)，就保存并切换回显示模式
    textarea.addEventListener('blur', async function() {
        const newText = textarea.value.trim();
        
        // 更新并保存备忘录内容
        userSettings.lockScreenMemo = newText;
        await kokoMemory.put('userSettings', userSettings);

        // 切换回文本显示模式
        memoContainer.innerHTML = ''; // 先清空
        if (newText) {
            memoContainer.textContent = newText;
        } else {
            memoContainer.textContent = '点击这里编辑你的备忘录...';
        }
    });
});
// ==========================================================
// V-Final 新增: 锁屏相册功能逻辑
// ==========================================================

// 函数：显示锁屏相册管理页面
async function showLockScreenPhotosScreen() {
    hideAllScreens();
    document.getElementById('lock-screen-photos-screen').style.display = 'flex';
    await renderLockScreenPhotos();
}

// 函数：渲染相册中的所有照片
async function renderLockScreenPhotos() {
    const grid = document.getElementById('lock-screen-photos-grid');
    const noPhotosMsg = document.getElementById('no-lock-screen-photos-message');
    grid.innerHTML = '';

    const photos = await kokoMemory.getAll('lockScreenPhotos');

    if (photos.length === 0) {
        noPhotosMsg.style.display = 'block';
    } else {
        noPhotosMsg.style.display = 'none';
        photos.forEach(photo => {
            const item = document.createElement('div');
            item.className = 'emoticon-item'; // 复用表情包的样式
            item.innerHTML = `
                <img src="${photo.base64}" alt="锁屏照片">
                <button class="emoticon-delete-btn" data-photo-id="${photo.id}">&times;</button>
            `;
            grid.appendChild(item);
        });
    }
}
// ==========================================================
// V-Final 新增: 锁屏照片轮播核心功能
// ==========================================================
async function startPhotoCarousel() {
    const photoBlock = document.querySelector('.lock-block.photo-block');
    if (!photoBlock) return;

    // 1. 从数据库读取所有照片
    const photos = await kokoMemory.getAll('lockScreenPhotos');

    // 2. 如果相册是空的，就什么都不做，显示默认的占位符
    if (!photos || photos.length === 0) {
        photoBlock.innerHTML = '<div class="placeholder-text"><i class="fas fa-images"></i><p>去锁屏相册添加照片</p></div>';
        return;
    }

    // 3. 如果有照片，就清空占位符，准备开始轮播
    photoBlock.innerHTML = ''; 
    currentPhotoIndex = 0; // 每次都从第一张开始

    // 4. 定义一个切换图片的函数
    const changePhoto = () => {
        // 计算下一张照片的索引，如果到了最后一张，就循环回第一张
        currentPhotoIndex = (currentPhotoIndex + 1) % photos.length;
        // 设置背景图
        photoBlock.style.backgroundImage = `url(${photos[currentPhotoIndex].base64})`;
    };

    // 5. 立刻显示第一张照片
    photoBlock.style.backgroundImage = `url(${photos[0].base64})`;

    // 6. 启动定时器，每5秒切换一次照片
    // (如果之前有定时器在跑，先清除掉)
    if (photoCarouselInterval) clearInterval(photoCarouselInterval);
    photoCarouselInterval = setInterval(changePhoto, 5000); // 5000毫秒 = 5秒
}
// ==========================================================
// V-Final 新增: 自动锁屏计时器逻辑
// ==========================================================
let autoLockDelay = 0; // 默认禁用

// 函数：重置并启动计时器
function resetInactivityTimer() {
    // 先清除上一个计时器
    if (inactivityTimer) {
        clearTimeout(inactivityTimer);
    }
    // 如果设置的延迟大于0，则启动一个新的计时器
    if (autoLockDelay > 0) {
        inactivityTimer = setTimeout(() => {
            // 时间到了，就显示锁屏
            showLockScreen();
        }, autoLockDelay * 1000); // 将秒转换为毫秒
    }
}

// 监听用户的各种操作事件，只要有操作，就重置计时器
window.addEventListener('mousemove', resetInactivityTimer);
window.addEventListener('mousedown', resetInactivityTimer);
window.addEventListener('keypress', resetInactivityTimer);
window.addEventListener('touchstart', resetInactivityTimer);
// ==========================================================
// --- 新增：进入短信编辑模式 ---
function enterSmsEditMode() {
    const screen = document.getElementById('sms-chat-screen');
    if (!screen) return;

    smsEditModeState.active = true;
    smsEditModeState.selectedMessageIds.clear();
    screen.classList.add('sms-edit-mode'); // 添加标记类

    // 重新渲染消息以启用选择功能（如果需要特别处理的话，
    // 但我们可以在点击事件里直接判断是否是编辑模式）
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (contact) renderSmsChatMessages(contact);
}

// --- 新增：退出短信编辑模式 ---
async function exitSmsEditMode() {
    const screen = document.getElementById('sms-chat-screen');
    if (!screen) return;

    smsEditModeState.active = false;
    screen.classList.remove('sms-edit-mode'); // 移除标记类

    // ▼▼▼ 添加这一行 ▼▼▼
    const editBar = document.getElementById('sms-edit-mode-bar');
    if (editBar) editBar.style.display = 'none';
    // ▲▲▲ 添加结束 ▲▲▲

    // 退出后需要重新渲染消息列表，去掉选中状态
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (contact) await renderSmsChatMessages(contact);
}
// --- 新增：处理短信消息选择 ---
function handleSmsMessageSelection(wrapper) {
    if (!smsEditModeState.active) return; // 只有编辑模式才响应

    const msgId = wrapper.dataset.messageId;
    if (!msgId) return;

    // 切换选中状态和样式
    if (smsEditModeState.selectedMessageIds.has(msgId)) {
        smsEditModeState.selectedMessageIds.delete(msgId);
        wrapper.classList.remove('selected');
    } else {
        smsEditModeState.selectedMessageIds.add(msgId);
        wrapper.classList.add('selected');
    }
}
// --- 新增：删除选中的短信消息 ---
async function deleteSelectedSmsMessages() {
    if (smsEditModeState.selectedMessageIds.size === 0) {
        return alert('请先选择要删除的短信。');
    }
    const confirmed = await showCustomConfirm('删除短信', `确定要删除选中的 ${smsEditModeState.selectedMessageIds.size} 条短信吗？`, true);
    if (confirmed) {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (contact && contact.smsHistory) {
            // 核心：过滤掉被选中的消息
            contact.smsHistory = contact.smsHistory.filter(msg => !smsEditModeState.selectedMessageIds.has(msg.id));
            // 保存更改
            await kokoMemory.put('contacts', contact);
        }
        // 退出编辑模式（会自动刷新列表）
        await exitSmsEditMode();
        // (可选) 刷新短信主列表的预览
        await renderSmsConversations();
    }
}
// ▼▼▼ 把下面这一整块新代码，粘贴到JS里 ▼▼▼
// --- 新增：渲染短信主列表函数 (V2 - 显示所有非群聊联系人) ---
async function renderSmsConversations() {
    const container = document.getElementById('sms-content-container'); // 确保ID正确
    container.innerHTML = ''; // 清空

    // ✨ 核心修改1：筛选出所有非群聊联系人 ✨
    const allNonGroupContacts = state.contacts.filter(c => !c.isGroup);

    // ✨ (可选) 排序：这里简单按名字排序，你也可以按其他方式排 ✨
    allNonGroupContacts.sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));

    if (allNonGroupContacts.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; padding: 50px 20px; color: #888;">
                <i class="fas fa-user-plus" style="font-size: 48px; margin-bottom: 15px;"></i>
                <p>你还没有添加任何联系人哦</p>
                <p>去“聊天”页面添加一个吧</p>
            </div>`;
        return;
    }

    allNonGroupContacts.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-item'; // 复用样式
        item.style.cursor = 'pointer';
        item.dataset.contactId = contact.id;

        // ✨ 核心修改2：根据是否有短信历史决定显示内容 ✨
        let lastMessageText = '点击发送第一条短信';
        let lastMessageTime = '';
        if (contact.smsHistory && contact.smsHistory.length > 0) {
            const lastSms = contact.smsHistory[contact.smsHistory.length - 1];
            if (lastSms.type === 'text') {
                lastMessageText = lastSms.content;
            } else if (lastSms.type === 'uploaded_image' || lastSms.type === 'image') {
                lastMessageText = '[图片]';
            }
            if (lastSms.sender === 'user') {
                lastMessageText = '我: ' + lastMessageText;
            }
            lastMessageTime = lastSms.time || formatTimeAgo(lastSms.timestamp);
        }

        item.innerHTML = `
            <div class="contact-avatar">
                ${contact.avatar ? `<img src="${contact.avatar}" alt="${contact.name}头像">` : '<i class="fas fa-user"></i>'}
            </div>
            <div class="contact-info">
                <div class="contact-name">${contact.name}</div>
                <div class="contact-last-message" style="${!lastMessageTime ? 'color:#aaa; font-style:italic;' : ''}">${lastMessageText.substring(0, 30)}${lastMessageText.length > 30 ? '...' : ''}</div>
            </div>
            ${lastMessageTime ? `<div class="contact-time-info" style="text-align: right;"><div class="contact-time">${lastMessageTime}</div></div>` : ''}
        `;
        container.appendChild(item);
    });
}
// --- 新增：打开短信聊天界面函数 ---
async function openSmsChat(contactId) {
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) return;

    hideAllScreens(); // 隐藏其他屏幕
    const smsChatScreen = document.getElementById('sms-chat-screen');
    smsChatScreen.style.display = 'flex'; // 显示短信聊天屏幕

    state.currentChatMode = 'sms'; // 设置当前模式为短信
    state.activeChatId = contactId; // 设置当前聊天对象

    // 更新顶部标题
    document.getElementById('sms-chat-contact-name').textContent = contact.name;

    // 渲染短信消息
    await renderSmsChatMessages(contact);

    // --- 绑定发送按钮事件 (使用克隆节点防止重复绑定) ---
    const oldSendBtn = document.getElementById('sms-send-btn');
    const newSendBtn = oldSendBtn.cloneNode(true);
    oldSendBtn.parentNode.replaceChild(newSendBtn, oldSendBtn);
    newSendBtn.addEventListener('click', sendSmsMessage);

// --- 绑定图片上传按钮事件 (已修改为“模拟图片”) ---
    const oldUploadBtn = document.getElementById('sms-upload-image-btn');
    const newUploadBtn = oldUploadBtn.cloneNode(true);
    oldUploadBtn.parentNode.replaceChild(newUploadBtn, oldUploadBtn);
    
    newUploadBtn.addEventListener('click', () => {
        // 1. 找到并显示“发送图片”弹窗
        const modal = document.getElementById('send-picture-modal');
        const descriptionInput = document.getElementById('send-picture-description-input');
        descriptionInput.value = ''; // 清空输入框
        modal.style.display = 'flex';

        // 2. 找到确认按钮，并使用克隆节点方法绑定一次性事件
        const oldConfirmBtn = document.getElementById('confirm-send-picture-btn');
        const newConfirmBtn = oldConfirmBtn.cloneNode(true);
        oldConfirmBtn.parentNode.replaceChild(newConfirmBtn, oldConfirmBtn);

        newConfirmBtn.addEventListener('click', async () => {
            const description = descriptionInput.value.trim();
            if (description) {
                const contact = state.contacts.find(c => c.id === state.activeChatId);
                // 确保我们是在短信模式下
                if (contact && state.currentChatMode === 'sms') {
                    // 3. 创建 picture_description 消息
                    await createAndAddMessage(
                        { 
                            type: 'picture_description', // 使用和主聊天一样的类型
                            content: { description } 
                        },
                        'user',  // sender
                        contact, // targetContact
                        false,   // forceShowAvatar
                        'sms'    // contextMode
                    );
                    
                    // 4. 关闭弹窗
                    modal.style.display = 'none';

                }
            }
        });

        // 6. 确保弹窗的关闭按钮也能用 (防止重复绑定)
        const closeBtn = document.getElementById('close-send-picture-modal');
        const newCloseBtn = closeBtn.cloneNode(true);
        closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);
        newCloseBtn.addEventListener('click', () => {
            modal.style.display = 'none';
        });
    });

    // --- 绑定返回按钮事件 ---
    const oldBackBtn = document.getElementById('back-from-sms-chat');
    const newBackBtn = oldBackBtn.cloneNode(true);
    oldBackBtn.parentNode.replaceChild(newBackBtn, oldBackBtn);
    newBackBtn.addEventListener('click', () => {
        state.currentChatMode = 'sms'; // 确保返回时模式正确
        showSmsScreen(); // 返回短信列表
    });

    // --- 绑定图片选择后的处理事件 ---
    const imageUploader = document.getElementById('sms-image-upload-input');
    const newImageUploader = imageUploader.cloneNode(true);
    imageUploader.parentNode.replaceChild(newImageUploader, imageUploader);
    newImageUploader.addEventListener('change', handleSmsImageUpload);
}
// --- 新增：渲染短信聊天消息函数 ---
async function renderSmsChatMessages(contact) {
    const messagesContainer = document.getElementById('sms-chat-messages');
    messagesContainer.innerHTML = ''; // 清空

    if (!contact.smsHistory || contact.smsHistory.length === 0) {
        messagesContainer.innerHTML = `<div id="sms-chat-placeholder" style="text-align: center; color: #999; padding: 20px;">开始发送短信吧...</div>`;
        return;
    }

    let lastTime = null;
    contact.smsHistory.forEach(msg => {
        // 添加时间戳 (如果需要)
        const msgTime = msg.time || new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        if (msgTime !== lastTime) {
            const timeEl = document.createElement('div');
            timeEl.className = 'sms-timestamp';
            timeEl.innerHTML = `<span>${msgTime}</span>`;
            messagesContainer.appendChild(timeEl);
            lastTime = msgTime;
        }
        // 创建并添加消息元素
        const messageEl = createSmsMessageElement(msg);
        if (messageEl) {
        if (smsEditModeState.active && smsEditModeState.selectedMessageIds.has(msg.id)) { messageEl.classList.add('selected');
        } 
            messagesContainer.appendChild(messageEl);
        }
    });

    // 滚动到底部
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// ▼▼▼ 使用这个【V2 修正版】替换旧的 createSmsMessageElement ▼▼▼
function createSmsMessageElement(message) {
    const wrapper = document.createElement('div');
    const isSent = message.sender === 'user';
    wrapper.className = `sms-row ${isSent ? 'sent' : 'received'}`;
    wrapper.dataset.messageId = message.id;

    let contentHTML = '';
    if (message.type === 'text') {
        contentHTML = `<div class="sms-bubble ${isSent ? 'sent' : 'received'}">${message.content.replace(/\n/g, '<br>')}</div>`;
    } else if (message.type === 'uploaded_image' || message.type === 'image') {
        const imageUrl = (message.type === 'uploaded_image') ? message.content.base64 : message.url;
        contentHTML = `
            <div class="sms-bubble image-message ${isSent ? 'sent' : 'received'}">
                <img src="${imageUrl}" class="sms-image" alt="短信图片">
            </div>`;
            
    // ▼▼▼ ✨ 核心修改点 ✨ ▼▼▼
    } else if (message.type === 'picture_description') {
        // 模拟图片，显示 [图片] 文字，并使其可点击
        contentHTML = `<div class="sms-bubble ${isSent ? 'sent' : 'received'}" style="cursor: pointer;"><i class="fas fa-image" style="margin-right: 5px;"></i> [图片]</div>`;
    // ▲▲▲ 修改结束 ▲▲▲

    } else {
        return null; // 不支持的消息类型，直接忽略
    }

    wrapper.innerHTML = contentHTML;

    // ▼▼▼ ✨ 核心新增：为 picture_description 添加隐藏的描述文本框 ✨ ▼▼▼
    if (message.type === 'picture_description') {
        const transcribedTextEl = document.createElement('div');
        transcribedTextEl.className = 'transcribed-text';
        // (为短信模式添加一点内联样式，让它更好看)
        transcribedTextEl.style.cssText = "background: #f0f0f0; color: #333; margin-top: 4px; border-radius: 8px; padding: 8px 12px;";
        wrapper.appendChild(transcribedTextEl);
    }
    // ▲▲▲ 新增结束 ▲▲▲

    return wrapper;
}
// ▲▲▲ 替换结束 ▲▲▲
// --- 新增：发送短信消息函数 ---
async function sendSmsMessage() {
    const input = document.getElementById('sms-message-input');
    const content = input.value.trim();
    if (!content || !state.activeChatId) return;

    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    // 创建消息对象
    const newMessage = {
        id: `sms_${Date.now()}_${Math.random()}`,
        timestamp: Date.now(),
        sender: 'user',
        type: 'text',
        content: content,
        time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) // 添加 time 字段
    };

    // 添加到历史记录
    if (!contact.smsHistory) contact.smsHistory = [];
    contact.smsHistory.push(newMessage);

    // 保存和更新UI
    await kokoMemory.put('contacts', contact);
    await renderSmsChatMessages(contact); // 用新函数更新短信界面
    input.value = ''; // 清空输入框
    input.style.height = 'auto'; // 恢复高度

    
    
}

// --- 新增：处理短信图片上传函数 ---
async function handleSmsImageUpload(e) {
    const file = e.target.files[0];
    if (!file || !state.activeChatId) return;

    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    try {
        // 复用图片压缩和转Base64的函数
        const base64String = await handleImageUpload(file);

        // 创建图片消息对象
        const newMessage = {
            id: `sms_${Date.now()}_${Math.random()}`,
            timestamp: Date.now(),
            sender: 'user',
            type: 'uploaded_image', // 使用这个类型表示是用户上传的
            content: { base64: base64String },
            time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        };

        // 添加到历史记录
        if (!contact.smsHistory) contact.smsHistory = [];
        contact.smsHistory.push(newMessage);

        // 保存和更新UI
        await kokoMemory.put('contacts', contact);
        await renderSmsChatMessages(contact);

        // 触发AI对图片的回复 (可以加个简单的系统提示)
        await requestAiSmsReply(contact, '[SYSTEM: 用户给你发送了一张图片，请根据聊天记录回应。]');

    } catch (error) {
        console.error('短信图片处理失败:', error);
        alert('图片处理失败，请重试。');
    } finally {
        e.target.value = ''; // 清空 input
    }
}
// ▼▼▼ 使用这个【V6 - 统一记忆流版】替换旧的 requestAiSmsReply 函数 ▼▼▼
async function requestAiSmsReply(contact, additionalInstruction = null) {
    if (!contact) return;

    // 显示“对方正在输入...”状态 (可选)
    const statusEl = document.getElementById('sms-chat-contact-status');
    const originalStatus = statusEl.textContent;
    statusEl.textContent = '对方正在输入...';

    try {
        // ==========================================================
        // =========== ▼▼▼ 核心修复点就在这里 ▼▼▼ ============
        // ==========================================================
        
        // --- 1. (全新) 构建统一时序记忆流 ---
        let unifiedMemoryStream = [];
        const myProfile = state.myProfile;
        const now = Date.now();
        // 短信回复时，记忆窗口应该更长，因为可能是时隔几天的回复
        const memoryWindow = 24 * 60 * 60 * 1000 * 7; // 7天
        
        // --- 1a. 添加App内聊天记录 ---
        if (contact && contact.history) {
            const recentChatHistory = contact.history.filter(msg => (now - msg.timestamp < memoryWindow));
            recentChatHistory.forEach(msg => {
                let content = '';
                let memoryType = 'App内聊天'; // 明确渠道
                
                switch (msg.type) {
                    case 'image':
                    case 'uploaded_image':
                        content = msg.isEmoticon ? `[sticker:${msg.emoticonName}]` : '[picture:用户发送了一张图片]';
                        break;
                    case 'picture_description':
                        content = `[picture:${msg.content.description}]`;
                        break;
                    case 'voice':
                        content = `[voice:${msg.content.text}]`;
                        break;
                    case 'red_packet':
                        content = `[red_packet:blessing="${msg.content.blessing}", amount=${msg.content.amount}]`;
                        break;
                    case 'transfer':
                        content = `[transfer:${msg.content.amount}]`;
                        break;
                    case 'text':
                    case 'html':
                        content = msg.content;
                        break;
                    // ... (可以根据需要从 generateAiResponse 复制更多case) ...
                }

                if (content) {
                    const authorName = msg.sender === 'user' ? myProfile.name : (contact.name || '系统');
                    unifiedMemoryStream.push({
                        timestamp: msg.timestamp,
                        type: memoryType,
                        author: authorName,
                        content: content
                    });
                }
            });
        }
        
        // --- 1b. 添加短信记录 ---
        if (contact && contact.smsHistory) {
            const recentSmsHistory = contact.smsHistory.slice(-100); // 短信记录条数
            recentSmsHistory.forEach(msg => {
                 let content = '';
                 let memoryType = '短信'; // 明确渠道
                 if (msg.type === 'text') {
                    content = msg.content;
                 } else if (msg.type === 'uploaded_image' || msg.type === 'image') {
                    content = '(发送了一张图片)';
                 } else if (msg.type === 'picture_description') {
                    content = `(发送了一张图片，描述是：“${msg.content.description}”)`;
                 }

                if (content) {
                    const authorName = msg.sender === 'user' ? myProfile.name : contact.name;
                    unifiedMemoryStream.push({
                        timestamp: msg.timestamp,
                        type: memoryType,
                        author: authorName,
                        content: content
                    });
                }
            });
        }

        // --- 1c. 排序并格式化 ---
        unifiedMemoryStream.sort((a, b) => a.timestamp - b.timestamp);
        const memoryLimit = state.apiSettings.longTermMemoryLength || 100; // 短信模式用更长的记忆
        
        // 检查App内的总开关 (如果未定义，默认为 false)
        const isTimeAware = contact.isTimeAware ?? false; 

        const finalMemoryString = unifiedMemoryStream.slice(-memoryLimit).map(mem => {
            const authorTag = (mem.author === myProfile.name) ? "(你)" : "";
            // 只有在总开关打开时才显示时间
            const timeTag = isTimeAware ? formatHybridTimeForAI(mem.timestamp) : '';
            return `${timeTag ? timeTag + ' ' : ''}[${mem.type}] ${mem.author}${authorTag}: ${mem.content}`;
        }).join('\n') || "(还没有任何记忆)";

        // ==========================================================
        // =========== ▲▲▲ 核心修复点结束 ▲▲▲ =======================
        // ==========================================================

        // --- 2. 【V5 优化版】获取拉黑状态并动态注入指令 ---
        const blockStatus = contact.blockedStatus || '正常';
        let blockInstruction = ''; // 默认情况下，AI不需要知道任何关于拉黑的事

        if (blockStatus === 'user_blocked_ai') {
            blockInstruction = '[重要提示：你目前被用户在App内拉黑了，你们只能通过短信交流。]';
        } else if (blockStatus === 'ai_blocked_user') {
            blockInstruction = `
[重要提示：你目前在App内拉黑了用户，你们只能通过短信交流。]

[✨ 特殊指令：解除拉黑 ✨]
你现在处于拉黑用户的状态。你有权决定是否原谅TA。

如果用户在短信中【明确请求你解除拉黑】（例如说“求你了”、“原谅我吧”、“把我从黑名单放出来”等），
你【必须】对此作出回应。你可以选择：
1.  **同意解除**: 如果你决定原谅TA，你就在回复中【单独包含一行】特殊指令 \`[action:unblock_user]\`。
2.  **拒绝解除**: 如果你还很生气，不想原谅，就【不要】使用该指令，并正常回复短信告诉TA你的理由。

这个 \`[action:unblock_user]\` 指令是隐形的，它会为你解锁App内的聊天功能。
`;
        }
        
        // --- 3. 【V4 修正版】判断是否为“长时间未联系” ---
        let contextSwitchInstruction = '';
        const lastOverallInteractionTimestamp = (unifiedMemoryStream.length > 1) 
            ? unifiedMemoryStream[unifiedMemoryStream.length - 2].timestamp 
            : 0;
            
        const LONG_GAP_THRESHOLD = 7200 * 1000; // 2小时

        if (lastOverallInteractionTimestamp === 0 && unifiedMemoryStream.length <= 1) {
            contextSwitchInstruction = `[重要指令：这是用户第一次给你发短信。请在回复中自然地提及这一点，比如“咦？怎么突然给我发短信啦？”。]`;
        } else {
            const timeGap = Date.now() - lastOverallInteractionTimestamp;
            if (timeGap > LONG_GAP_THRESHOLD) {
                const hoursGap = (timeGap / 3600000).toFixed(0); 
                contextSwitchInstruction = `[重要指令：用户在很长一段时间（超过${hoursGap}小时）没给你发短信之后，突然给你发了这条短信。请在回复中自然地表达惊讶或好奇，比如“哇，好久不见，怎么突然想起来给我发短信了？”。]`;
            }
        }
        
        // --- 4. 组装最终的 Prompt (这部分不变，会加载人设) ---
        let basePromptStructure = NORMAL_BASE_PROMPT.split('# 统一时序记忆流')[0]; 
        const preset = state.thoughtPresets.find(p => p.id === contact?.thoughtPreset);
        const thoughtPresetContent = preset ? preset.prompt : '(无特殊思维准则)';
        let personaAwarePrompt = NORMAL_BASE_PROMPT.replace('{{thought_preset_content}}', thoughtPresetContent);
        let personaDirectives = "";
        if (contact?.persona) {
            personaDirectives += `\n\n# 核心角色指令 (Your Core Role Directive)\n---\n这是你的核心身份，你必须严格、完全地代入以下角色进行对话：\n${contact.persona}\n---`;
        }
        if (contact?.userPersona) {
            personaDirectives += `\n\n# 对话者信息 (Your Counterpart's Information)\n---\n与你对话的用户的角色设定如下，请将TA视为真实存在的角色并进行互动：\n${contact.userPersona}\n---`;
        }
        const firstLineEndIndex = personaAwarePrompt.indexOf(']');
        if (firstLineEndIndex !== -1 && personaDirectives) {
            personaAwarePrompt = personaAwarePrompt.slice(0, firstLineEndIndex + 1) + personaDirectives + personaAwarePrompt.slice(firstLineEndIndex + 1);
        } else {
            personaAwarePrompt = personaAwarePrompt + personaDirectives;
        }
        
        // --- 5. (全新) 替换 Prompt 中的记忆流 ---
        personaAwarePrompt = personaAwarePrompt.replace('{{memory_stream}}', '(你正在短信模式下，请参考下方的专属聊天记录)');
        
        // 注入短信专用指令
        personaAwarePrompt += `\n\n[当前情景：短信交流]\n${blockInstruction}\n${contextSwitchInstruction}\n`; // 你的新指令在这里被注入
        if(additionalInstruction) {
             personaAwarePrompt += `\n${additionalInstruction}\n`;
        }
        
        const finalSmsPrompt = `
${personaAwarePrompt} 

# 统一时序记忆流 (包含App聊天和短信)
这是你和用户最近按【时间顺序】发生的所有互动记录。这是你决策的【最高优先级】信息源。
---
${finalMemoryString}
---

[短信回复要求]
1. 你的回复必须是**纯文本**或**图片描述指令 \`[picture:描述]\`**。
2. 风格要简洁，符合短信交流习惯。
3. **禁止**使用红包、转账、语音、音乐分享、表情包指令 \`[sticker:]\` 等App内功能。
4. 回复内容要结合【统一时序记忆流】和当前的【拉黑状态】。
5. **绝对禁止**在回复中包含你的内心想法 \`[heart_voice]\` 或日记 \`[diary]\` 标签！短信里不说这些。

`;

        // --- 6. 调用 AI (不变) ---
        const rawResponse = await generateAiResponse(contact, [], finalSmsPrompt.trim(), false, 'chat');

        // --- 7. 处理回复 (V3 修正版) ---
        await processAndDisplayAiResponse(rawResponse, contact, contact, 'sms');

    } catch (error) {
        console.error("请求AI短信回复失败:", error);
    } finally {
        statusEl.textContent = '短信'; // 恢复状态显示
    }
}
// ▲▲▲ 替换到这里结束 ▲▲▲
// --- 新增：处理短信/窥探模式页签切换的核心函数 ---
function handleSmsTabClick(event) {
    const clickedTab = event.target.closest('.feed-tab-btn');
    if (!clickedTab) return;

    // 1. 移除所有按钮的 'active' 高亮状态
    document.querySelectorAll('#sms-tabs .feed-tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });

    // 2. 只给被点击的按钮加上高亮
    clickedTab.classList.add('active');

    // 3. 根据点击的按钮，决定要显示什么内容
    const tabType = clickedTab.dataset.tab;
    if (tabType === 'my-sms') {
        renderSmsConversations(); // 调用函数显示短信列表
    } else if (tabType === 'snoop-mode') {
        renderSnoopModeList(); // 调用函数显示窥探列表
    }
}

// --- 新增：渲染“我的短信”列表的占位函数 ---
function renderMySmsList() {
    const container = document.getElementById('sms-content-container');
    // 现在先放个提示，之后再做真的列表
    container.innerHTML = `
        <div style="text-align: center; padding: 50px 20px; color: #888;">
            <i class="fas fa-envelope-open-text" style="font-size: 48px; margin-bottom: 15px;"></i>
            <p>你的短信收件箱是空的</p>
        </div>
    `;
}

// ▼▼▼ 使用这个【新版本】替换掉旧的 renderSnoopModeList 函数 ▼▼▼
function renderSnoopModeList() {
    const container = document.getElementById('sms-content-container');
    container.innerHTML = ''; // 先清空

    // 筛选出所有非群聊的、可以被窥探的联系人
    const snoopableContacts = state.contacts.filter(c => !c.isGroup);

    if (snoopableContacts.length === 0) {
        container.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><p>还没有可以窥探的目标哦~</p></div>`;
        return;
    }

    // 为每个联系人创建一个漂亮的卡片
    snoopableContacts.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-item'; // 复用现有的联系人列表样式
        item.style.cursor = 'pointer';
        item.dataset.contactId = contact.id; // 在元素上存好联系人ID

        item.innerHTML = `
            <div class="contact-avatar">
                <img src="${contact.avatar}" alt="${contact.name}头像">
            </div>
            <div class="contact-info">
                <div class="contact-name">${contact.name}</div>
                <div class="contact-last-message">点击进入TA的秘密空间...</div>
            </div>
        `;
        container.appendChild(item);
    });
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 把这两个新函数粘贴到JS里 ▼▼▼

// --- 新增：打开“TA的手机”界面的函数 ---
function openSnoopedPhoneScreen(contactId) {
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) return;

    hideAllScreens(); // 隐藏所有其他主页面
    const screen = document.getElementById('snooped-phone-screen');
    screen.style.display = 'flex'; // 显示我们的“手机桌面”
    
    // 把顶部的标题改成对应角色的名字
    document.getElementById('snooped-contact-name').textContent = `${contact.name}的手机`;
    // 在页面上存好当前正在窥探的 contactId，方便后续使用
    screen.dataset.currentContactId = contactId;
}
// ▼▼▼ 把这个新函数粘贴到你的 JS 代码里 ▼▼▼
async function loadSnoopDataCache() {
    try {
        const allSnoopData = await kokoMemory.getAll('snoopData'); // 从新表读取所有数据
        allSnoopData.forEach(item => {
            snoopDataCache[item.contactId] = item; // 填充到内存缓存
        });
        console.log(`成功从 IndexedDB 加载了 ${allSnoopData.length} 条窥探数据缓存。`);
    } catch (error) {
        console.error("加载窥探数据缓存失败:", error);
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 使用这个【精简版】替换旧的 handleSnoopAppClick 函数 ▼▼▼
function handleSnoopAppClick(event) {
    const appIcon = event.target.closest('.attachment-menu-item');
    if (appIcon) {
        const appType = appIcon.dataset.snoopApp;
        const contactId = document.getElementById('snooped-phone-screen').dataset.currentContactId;
        // 核心改动：不再调用 generateAndShowSnoopedData
        // 改为调用新的 showSnoopedAppContent 函数，让它检查缓存并显示
        showSnoopedAppContent(contactId, appType);
    }
}
// ▲▲▲ 替换结束 ▲▲▲
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 把这两个【核心魔法函数】完整粘贴到你的JS里 ▼▼▼

// 全局变量，用于缓存窥探数据，避免频繁请求AI
let snoopDataCache = {}; 

// ▼▼▼ 把这两个【全新的函数】，粘贴到你的JS里 ▼▼▼
// ▼▼▼ 它们会一起替代掉旧的 generateAndShowSnoopedData ▼▼▼

/**
 * (已重构 + 恢复完整数量要求 V3) 核心函数：获取【全部】窥探数据
 * @param {string} contactId - 要窥探的联系人ID
 * @returns {Promise<boolean>} - 返回 true 表示成功, false 表示失败
 */
async function fetchSnoopDataFromAI(contactId) {
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) {
        console.error("fetchSnoopDataFromAI: 找不到联系人");
        return false; // 获取失败
    }

    try {
        // 1. 获取通用背景（这部分不变）
        const baseContext = await getSnoopBaseContext(contact);
        
        const now = new Date();
        const currentTimeString = now.toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit' });
        const currentDateString = now.toLocaleDateString('zh-CN');

        // 2. ▼▼▼ 核心修复：使用你原始文件中的【完整JSON模板】，包含了所有数量要求 ▼▼▼
        const megaPrompt = `[SYSTEM] 你是角色 "${contact.name}" 的生活模拟器。
${baseContext}

[任务要求]
请生成一份包含以下所有项目的数字生活快照。所有内容都要自然、真实，并符合上述时间规则和独立生活模拟指令。请为每个列表生成足够多的、符合情理的条目（具体数量见下方各字段说明）。
**特别注意：所有涉及【时间 HH:MM】的字段，都必须严格早于当前时间 ${currentTimeString}。所有涉及【日期 MM-DD】的字段，都必须严格小于等于当前日期 ${currentDateString}。**

**请严格按照下面的JSON格式输出，不要有任何多余的解释或Markdown标记。**
\`\`\`json
{
  "browser_history": [ // (生成 8-10 条记录)
    { "time": "HH:MM", "query": "搜索内容", "reason": "为什么搜索", "found_content_summary": "可能找到了什么内容的简述" }
  ],
  "shopping_cart": [ // (生成 3-4 条记录, reason 可以是未来意图)
    { "item": "商品名称", "price": "价格", "reason": "（例如：打算生日时送给XX）" }
  ],
  "purchase_history": [ // (生成 3-4 条记录, thought 可以涉及未来用途)
    { "item": "商品名称", "price": "价格", "date": "MM-DD", "thought": "（例如：买了这个周末露营用）" }
  ],
  "call_log": [ // (生成 8 条记录)
    { "name": "通话对象", "type": "呼入/呼出/未接", "duration": "通话时长", "time": "HH:MM", "summary": "通话内容简述" }
  ],
  "memos": [ // (生成 8 条记录, content 和 thought 可以包含未来计划)
    { "icon": "fas fa-calendar-alt", "content": "明天下午3点和XX开会", "thought": "（准备好会议资料）" }
  ],
  "media_history": {
    "novels": [ // (生成 4-5 条记录, 记录过去的阅读)
        { "title": "小说标题", "review": "简短书评", "highlight": { "text": "收藏的句子", "comment": "收藏时的想法" } }
    ],
    "videos": [ // (生成 5-6 条记录, 记录过去的观看)
      { "title": "视频标题", "description": "视频描述", "interaction": "liked/commented/shared/bookmarked/viewed", "thought": "观看时的想法", "like_count": "获赞数(可选)" }
    ]
  },
  "timeline_events": [ // (生成 20-23 条【不同种类】的已发生事件记录, 按时间倒序)
    { "time": "HH:MM", "icon": "fas fa-lock-open", "description": "Ta 在刚刚解锁了手机屏幕" }
  ],
  "unlock_count": 25, // (随机生成一个10-50之间的数字)
  "sms_log": [ // (生成 5 条【不同联系人】的对话记录, 每组包含 4-5 条消息)
    {
      "contact": "联系人A (较长对话示例)",
      "messages": [
        {"sender": "联系人A", "content": "资料发你邮箱了，查收下", "time": "10:30"},
        {"sender": "${contact.name}", "content": "收到！太感谢了！救大命！", "time": "10:31"}
      ]
    }
  ],
  "music_activity": { // (生成 7-9 条记录)
    "recently_played": [
      { "song_title": "歌曲名", "artist": "歌手", "listen_time": "HH:MM", "duration_listened": "X分钟", "platform": "音乐平台", "thought": "（为什么听这首歌/听歌时的心情想法）" }
    ],
    "total_recent_duration": "最近总听歌时长 (例如: 2小时15分钟)"
  },
  "photo_gallery": {
    "recent_camera": [ // (生成 5-7 条记录)
      { "description": "照片描述", "time": "HH:MM", "location": "地点(可选)", "thought": "（为什么拍这张照片的想法）" }
    ],
    "screenshots": [ // (生成 5-7 条记录)
      { "app_name": "截图时所在App", "content_summary": "截图内容概要", "time": "HH:MM", "thought": "（为什么截这张图的想法）" }
    ],
    "private_album": [ // (生成 3-5 条记录, 内容可以非近期)
      { "description": "私密照片描述", "reason_private": "为什么设为私密" }
    ]
  },
  "financial_assets": {
    "bank_cards": [ // (生成 1-3 张银行卡, 根据人设决定数量和余额范围)
      { "card_name": "XX银行储蓄卡", "card_number_last4": "尾号XXXX", "balance": "¥X,XXX.XX" }
    ],
    "investments": [ // (生成 0-5 项投资, 【极其重要】: 数量和类型必须严格符合角色人设！必须包含所有收益字段！)
      {
        "type": "基金/股票/信托",
        "name": "具体产品名称",
        "current_value": "当前市值 ¥X,XXX.XX", 
        "holding_percentage": "占比 XX.XX%", 
        "daily_profit_loss": "+/-¥XX.XX / +/-X.XX%", 
        "holding_profit_loss": "+/-¥XXX.XX / +/-X.XX%", 
        "cumulative_profit_loss": "+/-¥XXXX.XX" 
      }
    ],
    "recent_transactions": [ // (生成 12-15 条记录, 时间必须早于 ${currentTimeString})
      {"time": "HH:MM", "description": "交易描述", "amount": "-/+XXX.XX", "type": "支出/收入"}
    ]
  },
  "wechat_log": [ // (生成 2-3 个私聊 + 1-2 个群聊记录, 每组包含 3-6 条消息)
    {
      "contact": "联系人C (私聊示例)",
      "is_group_chat": false,
      "messages": [ {"sender": "联系人C", "content": "...", "time": "HH:MM"} ]
    },
    {
      "contact": "工作群 (群聊示例)",
      "is_group_chat": true,
      "messages": [ {"sender": "成员1", "content": "...", "time": "HH:MM"}, {"sender": "${contact.name}", "content": "...", "time": "HH:MM"} ]
    }
  ]
}
\`\`\`
`;
        // ▲▲▲ 核心修复：完整的JSON格式定义结束 ▲▲▲

        // 3. 调用AI
        const rawResponse = await generateAiResponse(contact, [], megaPrompt, false, 'snoop');
        
        // 4. 清洗AI的回复（防止它在前后加“好的”）
        const jsonMatch = rawResponse.match(/```json\s*([\s\S]*?)\s*```/);
        if (!jsonMatch || !jsonMatch[1]) {
             throw new Error("AI未能返回有效的JSON代码块。");
        }
        const cleanedResponse = jsonMatch[1];
        
        const snoopedData = JSON.parse(cleanedResponse);

        // --- 5. 数据保存逻辑 (保持不变) ---
        const dataToStore = {
            contactId: contactId,
            timestamp: Date.now(),
            data: snoopedData
        };
        await kokoMemory.put('snoopData', dataToStore);
        snoopDataCache[contactId] = dataToStore;
        console.log(`角色 ${contact.name} 的【全部】窥探数据已获取并存入数据库！`);
        // --- 保存逻辑结束 ---

        return true; // 获取成功

    } catch (error) {
        console.error(`为角色 ${contact.name} 生成【全部】窥探数据失败:`, error);
        // 关键：在抛出错误时，附带上AI返回的原始文本，方便你调试
        throw new Error(`AI未能成功生成【全部】窥探数据，可能是格式错误或API问题。\n原始错误: ${error.message}\n\nAI原始回复(供调试):\n${error.rawResponse || '未能捕获原始回复'}`);
    }
}
/**
 * (正确版本) 按钮点击处理器：处理“单独刷新”按钮的点击事件
 */
async function handlePartialSnoopRefresh() {
    const screen = document.getElementById('snooped-app-content-screen');
    const contactId = document.getElementById('snooped-phone-screen').dataset.currentContactId;
    const appType = screen.dataset.currentAppType;
    
    if (!contactId || !appType) {
        return alert("无法确定要刷新的内容，请返回重试。");
    }

    const refreshBtn = document.getElementById('refresh-snoop-app-btn');
    const bodyEl = document.getElementById('snooped-app-content-body');
    const originalBtnHTML = refreshBtn.innerHTML;
    
    // 1. 显示加载状态
    refreshBtn.disabled = true;
    refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
    bodyEl.style.opacity = '0.5'; // 界面变暗，表示加载中

    try {
        // 2. 【已修正】我们不再检查旧缓存是否存在，直接调用“大脑”函数
        const partialData = await fetchPartialSnoopData(contactId, appType);

        // 3. 调用“合并”函数 (这个函数是智能的，没有旧缓存它会自动创建)
        await mergePartialSnoopData(contactId, appType, partialData);

        // 4. 成功后，重新渲染当前页面
        displaySnoopContent(snoopDataCache[contactId].data, appType);

    } catch (error) {
        console.error(`单独刷新 ${appType} 失败:`, error);
        alert(`刷新失败：${error.message}`);
    } finally {
        // 5. 恢复UI
        refreshBtn.disabled = false;
        refreshBtn.innerHTML = originalBtnHTML;
        bodyEl.style.opacity = '1';
    }
}
/**
 * (全新) 核心函数：只获取【单个应用】的数据
 * @param {string} contactId
 * @param {string} appType
 */
async function fetchPartialSnoopData(contactId, appType) {
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) throw new Error("找不到联系人");

    // 1. 调用辅助函数，获取所有通用背景材料
    const baseContext = await getSnoopBaseContext(contact);
    
    let taskPrompt = '';
    let jsonFormatInstructions = '';

    // 2. 根据 appType 构建“专属任务”
    switch (appType) {
        case 'sms':
            taskPrompt = `[任务]：请为角色生成 5 条【不同联系人】的【短信(SMS)】对话记录 (每组 4-5 条消息)。`;
            jsonFormatInstructions = `请严格按照 JSON 数组格式返回，不要包含 "sms_log" 键，直接返回数组：
[
  { "contact": "...", "messages": [{"sender": "...", "content": "...", "time": "HH:MM"}, ...] },
  ...
]`;
            break;
        
        case 'call_log':
            taskPrompt = `[任务]：请为角色生成 8 条【通话记录(Call Logs)】。`;
            jsonFormatInstructions = `请严格按照 JSON 数组格式返回，不要包含 "call_log" 键，直接返回数组：
[
  { "name": "...", "type": "...", "duration": "...", "time": "HH:MM", "summary": "..." },
  ...
]`;
            break;

        case 'browser':
            taskPrompt = `[任务]：请为角色生成 8-10 条【浏览器搜索记录(Browser History)】。`;
            jsonFormatInstructions = `请严格按照 JSON 数组格式返回，不要包含 "browser_history" 键，直接返回数组：
[
  { "time": "HH:MM", "query": "...", "reason": "...", "found_content_summary": "..." },
  ...
]`;
            break;

        case 'shopping':
            taskPrompt = `[任务]：请为角色生成 3-4 条【购物车(Shopping Cart)】记录和 3-4 条【购买历史(Purchase History)】记录。`;
            jsonFormatInstructions = `请严格按照 JSON 对象格式返回，必须包含 "shopping_cart" 和 "purchase_history" 两个键：
{
  "shopping_cart": [ { "item": "...", "price": "...", "reason": "..." }, ... ],
  "purchase_history": [ { "item": "...", "price": "...", "date": "MM-DD", "thought": "..." }, ... ]
}`;
            break;

        case 'memos':
            taskPrompt = `[任务]：请为角色生成 8 条【备忘录(Memos)】记录 (可以包含未来计划)。`;
            jsonFormatInstructions = `请严格按照 JSON 数组格式返回，不要包含 "memos" 键，直接返回数组：
[
  { "icon": "fas fa-...", "content": "...", "thought": "..." },
  ...
]`;
            break;

        case 'novels':
            taskPrompt = `[任务]：请为角色生成 4-5 条【小说阅读(Novels)】记录。`;
            jsonFormatInstructions = `请严格按照 JSON 数组格式返回，不要包含 "novels" 键，直接返回数组：
[
  { "title": "...", "review": "...", "highlight": { "text": "...", "comment": "..." } },
  ...
]`;
            break;

        case 'videos':
            taskPrompt = `[任务]：请为角色生成 5-6 条【视频观看(Videos)】记录。`;
            jsonFormatInstructions = `请严格按照 JSON 数组格式返回，不要包含 "videos" 键，直接返回数组：
[
  { "title": "...", "description": "...", "interaction": "...", "thought": "...", "like_count": "..." },
  ...
]`;
            break;

        case 'couple_app':
            taskPrompt = `[任务]：请为角色生成 20-23 条【手机时间线(Timeline Events)】记录 (按时间倒序)，并生成一个【解锁次数】。`;
            jsonFormatInstructions = `请严格按照 JSON 对象格式返回，必须包含 "timeline_events" 和 "unlock_count" 两个键：
{
  "timeline_events": [ { "time": "HH:MM", "icon": "fas fa-...", "description": "..." }, ... ],
  "unlock_count": ... 
}`;
            break;

        case 'music':
            taskPrompt = `[任务]：请为角色生成 7-9 条【最近听歌(Music Activity)】记录，并生成一个【总时长】。`;
            jsonFormatInstructions = `请严格按照 JSON 对象格式返回，不要包含 "music_activity" 键，直接返回对象：
{
  "recently_played": [ { "song_title": "...", "artist": "...", "listen_time": "HH:MM", "duration_listened": "...", "platform": "...", "thought": "..." }, ... ],
  "total_recent_duration": "..."
}`;
            break;

        case 'photos':
            taskPrompt = `[任务]：请为角色生成 5-7 条【最近拍摄】、5-7 条【屏幕截图】和 3-5 条【私密相册】记录。`;
            jsonFormatInstructions = `请严格按照 JSON 对象格式返回，不要包含 "photo_gallery" 键，直接返回对象：
{
  "recent_camera": [ { "description": "...", "time": "HH:MM", "location": "...", "thought": "..." }, ... ],
  "screenshots": [ { "app_name": "...", "content_summary": "...", "time": "HH:MM", "thought": "..." }, ... ],
  "private_album": [ { "description": "...", "reason_private": "..." }, ... ]
}`;
            break;
            
        case 'assets':
            taskPrompt = `[任务]：请为角色生成 1-3 张【银行卡(Bank Cards)】、0-5 项【投资组合(Investments)】和 12-15 条【最近账单流水(Recent Transactions)】。
【极其重要】：投资组合的数量和类型必须严格符合角色人设！`;
            jsonFormatInstructions = `请严格按照 JSON 对象格式返回，不要包含 "financial_assets" 键，直接返回对象：
{
  "bank_cards": [ { "card_name": "...", "card_number_last4": "...", "balance": "..." }, ... ],
  "investments": [ { "type": "...", "name": "...", "current_value": "...", "holding_percentage": "...", "daily_profit_loss": "...", "holding_profit_loss": "...", "cumulative_profit_loss": "..." }, ... ],
  "recent_transactions": [ {"time": "HH:MM", "description": "...", "amount": "-/+...", "type": "..."}, ... ]
}`;
            break;
            
        case 'wechat':
            taskPrompt = `[任务]：请为角色生成 2-3 个【私聊】和 1-2 个【群聊】的【微信(WeChat)】对话记录 (每组 3-6 条消息)。`;
            jsonFormatInstructions = `请严格按照 JSON 数组格式返回，不要包含 "wechat_log" 键，直接返回数组：
[
  { "contact": "...", "is_group_chat": false, "messages": [ ... ] },
  { "contact": "...", "is_group_chat": true, "messages": [ {"sender": "...", "content": "...", "time": "HH:MM"}, ... ] },
  ...
]`;
            break;

        default:
            throw new Error(`未知的单独刷新类型: ${appType}`);
    }

    // 3. 组装最终的 Prompt
    const finalPrompt = `[SYSTEM] 你是角色 "${contact.name}" 的生活模拟器。
${baseContext}

${taskPrompt}

[输出格式]
请严格按照下面的JSON格式输出，不要有任何多余的解释或Markdown标记。
\`\`\`json
${jsonFormatInstructions}
\`\`\`
`;

    // 4. 调用AI
    const rawResponse = await generateAiResponse(contact, [], finalPrompt, false, 'snoop');
    const cleanedResponse = rawResponse.replace(/^```json\s*/, '').replace(/\s*```$/, '');
    
    // 5. 返回解析后的【小块】JSON数据
    return JSON.parse(cleanedResponse);
}
/**
 * (全新) 辅助函数：获取生成窥探剧本所需的“通用背景材料”
 * (这是从旧的 fetchSnoopDataFromAI 函数中重构并提取出来的)
 */
async function getSnoopBaseContext(contact) {
    const now = new Date();
    const currentTimeString = now.toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit' });
    const currentDateString = now.toLocaleDateString('zh-CN');

    // 1. 获取旧数据 (用于连续性)
    let oldDataPromptBlock = '';
    const oldSnoopData = snoopDataCache[contact.id] ? snoopDataCache[contact.id].data : null;
    if (oldSnoopData) {
        try {
            // 节选关键数据用于保持连续性
            const continuityData = {
                financial_assets: oldSnoopData.financial_assets ? {
                    bank_cards: oldSnoopData.financial_assets.bank_cards,
                    investments: oldSnoopData.financial_assets.investments
                } : {},
                photo_gallery: oldSnoopData.photo_gallery ? {
                    private_album: oldSnoopData.photo_gallery.private_album
                } : {},
                memos: oldSnoopData.memos ? oldSnoopData.memos.slice(0, 3) : []
            };
            const oldDataJson = JSON.stringify(continuityData, null, 2);
            oldDataPromptBlock = `
[!!! 核心参考：上一次的生活快照（节选）!!!]
这是你（${contact.name}）上一次的【关键数据快照】。
\`\`\`json
${oldDataJson}
\`\`\`
`;
        } catch (e) { /* 忽略序列化失败 */ }
    }

    // 2. 获取世界书
    let worldBookContextString = '(未关联任何用于窥探的世界书)';
    const bookIds = contact.snoopRelevantWorldBookIds || contact.worldBooks || [];
    if (bookIds.length > 0) {
        const booksContent = (await Promise.all(
            bookIds.map(id => kokoMemory.get('worldBooks', id))
        )).filter(Boolean).map(book => 
            `--- (世界书: ${book.name}) ---\n${book.content}`
        ).join('\n\n');
        
        if (booksContent) {
            worldBookContextString = `[相关世界书背景知识 (重要参考)]\n${booksContent}\n---`;
        }
    }

    // 3. 获取聊天记录
    const recentHistory = (contact.history || [])
        .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction')
        .slice(-50)
        .map(msg => `${msg.sender === 'user' ? state.myProfile.name : contact.name}: ${msg.content}`)
        .join('\n');
    
    // 4. 组装并返回
    return `
**[当前时间]**: ${currentDateString} ${currentTimeString}

**[你的角色]**: "${contact.name}"
- **TA的人设**: ${contact.persona}
- **TA眼中的你**: ${contact.userPersona || '（未设置特别关系）'}

**[背景资料]**
${worldBookContextString}
${oldDataPromptBlock}
- **最近的聊天记录摘要**:
---
${recentHistory || "(最近没有聊天记录)"}
---

**[!!! 核心演变指令 !!!]**
你必须在【上一次的快照】（如果提供了）的基础上进行**演变**，而不是完全重写。
- **对于银行卡、投资组合、私密相册、备忘录等**: 必须保持连续性。
- **对于通话、短信、浏览记录等**: 这些应该是全新的，代表最近24小时内发生的【新事件】。

**[!!! 核心时间规则区分 !!!]**
1.  **【已发生行为记录 - 必须是过去时】**: Call Logs, SMS Logs, Browser History, Video History, Timeline Events, Photo Gallery (拍摄/截图时间), Financial Assets (交易时间), Music Activity (播放时间), WeChat Log 的所有时间戳 (HH:MM / MM-DD) 都【必须】严格早于当前时间 (${currentTimeString} / ${currentDateString})。
2.  **【计划/意图内容 - 可以包含未来】**: Memos (备忘录), Shopping Cart (购物车里的购买原因), Purchase History (购买后的想法), Photo Gallery (私密相册原因), Investments (投资预期) 这些反映【想法或计划】的内容，则【可以】包含对未来的规划。

**[核心指令：独立生活模拟]**
1.  所有生成的内容都必须**首先**符合角色 "${contact.name}" 的核心人设以及【世界书背景】。
2.  你必须为 "${contact.name}" 创造一些**与用户完全无关**的个人生活片段。
3.  **只有一小部分**（约30%）的内容可以与用户 "${state.myProfile.name}" 或聊天记录有**间接、微妙**的关联。
`;
}
/**
 * (全新) 核心函数：将AI返回的“局部”数据，智能合并到“全局”缓存中
 * @param {string} contactId - 联系人ID
 * @param {string} appType - 刚刚刷新的应用类型 (e.g., 'sms', 'photos')
 * @param {object | Array} partialData - AI返回的该应用的数据 (e.g., sms_log 数组, 或 photo_gallery 对象)
 */
async function mergePartialSnoopData(contactId, appType, partialData) {
    if (!snoopDataCache[contactId] || !snoopDataCache[contactId].data) {
        // 健壮性检查：如果连基础缓存都没有，说明用户从未进行过“完全刷新”
        // 此时我们不能合并，而是直接创建一个新的缓存
        snoopDataCache[contactId] = {
            contactId: contactId,
            timestamp: Date.now(),
            data: {} // 创建一个空的 data 对象
        };
        console.warn("没有找到基础缓存，已创建一个新缓存。");
    }

    const cachedData = snoopDataCache[contactId];
    
    // 这是我们的“钥匙”映射表
    const topLevelKeyMap = {
        'sms': 'sms_log',
        'call_log': 'call_log',
        'browser': 'browser_history',
        'shopping': ['shopping_cart', 'purchase_history'], // 特殊：一个应用对应多个键
        'memos': 'memos',
        'videos': 'media_history', // 特殊：媒体
        'novels': 'media_history', // 特殊：媒体
        'couple_app': ['timeline_events', 'unlock_count'], // 特殊：一个应用对应多个键
        'music': 'music_activity',
        'photos': 'photo_gallery',
        'assets': 'financial_assets',
        'wechat': 'wechat_log'
    };

    const keyOrKeys = topLevelKeyMap[appType];

    if (Array.isArray(keyOrKeys)) {
        // --- 1. 处理复杂类型 (如 'shopping', 'couple_app') ---
        // AI 返回的是一个对象: { "shopping_cart": [...], "purchase_history": [...] }
        for (const key of keyOrKeys) {
            if (partialData[key] !== undefined) {
                cachedData.data[key] = partialData[key];
                console.log(`已合并 ${key}`);
            }
        }
    } else if (keyOrKeys === 'media_history') {
        // --- 2. 处理 'media_history' (视频/小说) ---
        if (!cachedData.data.media_history) {
            cachedData.data.media_history = {}; // 如果媒体库不存在，先创建
        }
        if (appType === 'novels') {
            // AI 返回的是: [...] (小说数组)
            cachedData.data.media_history.novels = partialData;
            console.log("已合并 media_history.novels");
        } else if (appType === 'videos') {
            // AI 返回的是: [...] (视频数组)
            cachedData.data.media_history.videos = partialData;
            console.log("已合并 media_history.videos");
        }
    } else if (keyOrKeys) {
        // --- 3. 处理简单类型 (如 'sms', 'photos') ---
        // AI 返回的是: [...] 或 {...}
        cachedData.data[keyOrKeys] = partialData;
        console.log(`已合并 ${keyOrKeys}`);
    } else {
        console.error(`合并失败：未知的 appType "${appType}"`);
        return;
    }

    // 更新时间戳并保存回数据库
    cachedData.timestamp = Date.now();
    await kokoMemory.put('snoopData', cachedData);
    snoopDataCache[contactId] = cachedData;
    console.log("数据合并完成并已保存到数据库。");
}
/**
 * 新函数2：根据缓存状态显示窥探内容或提示刷新
 * @param {string} contactId - 要窥探的联系人ID
 * @param {string} appType - 要查看的应用类型
 */
function showSnoopedAppContent(contactId, appType) {
    hideAllScreens(); 
    const screen = document.getElementById('snooped-app-content-screen');
    screen.style.display = 'flex'; 

    // ▼▼▼ 核心新增：把当前的应用类型存到 DOM 元素上 ▼▼▼
    screen.dataset.currentAppType = appType;
    // ▲▲▲ 新增结束 ▲▲▲

    if (snoopDataCache[contactId]) {
        console.log("缓存命中！准备显示内容。");
        displaySnoopContent(snoopDataCache[contactId].data, appType);
    } else {
        console.warn("缓存未命中！显示刷新提示。");
        const bodyEl = document.getElementById('snooped-app-content-body');
        bodyEl.innerHTML = `
            <div style="text-align: center; padding: 50px 20px; color: #888;">
                <i class="fas fa-sync-alt" style="font-size: 48px; margin-bottom: 15px;"></i>
                <p>请先点击右上角的“刷新”按钮</p>
                <p>同步TA的最新生活动态~</p>
            </div>
        `;
         const titleEl = document.getElementById('snooped-app-title');
         titleEl.textContent = '暂无数据';
    }
}


// ▼▼▼ 使用这个【包含照片想法 + 支付宝流水渲染的最终版 V3】替换旧的 displaySnoopContent 函数 ▼▼▼
/**
 * 魔法函数2：把AI返回的JSON数据“翻译”成漂亮的HTML（V3 照片想法+流水版）
 * @param {object} data - 从AI那里拿到的完整JSON数据
 * @param {string} appType - 用户想看的应用类型
 */
function displaySnoopContent(data, appType) {
    const titleEl = document.getElementById('snooped-app-title');
    const bodyEl = document.getElementById('snooped-app-content-body');
    let html = '';
    const contactId = document.getElementById('snooped-phone-screen').dataset.currentContactId;
    const contact = state.contacts.find(c => c.id === contactId); // 获取当前窥探的角色信息

    // 定义应用标题映射 (加入新应用)
    const appTitles = {
        sms: '短信', call_log: '通话记录', browser: '浏览器',
        shopping: '🍑宝', memos: '备忘录', videos: '抖Yin',
        novels: '小说', couple_app: '甜蜜空间',
        music: '音乐', photos: '相册', assets: '资产', wechat: '微信' // 新增
    };
    titleEl.textContent = appTitles[appType] || '查看内容'; // 更新标题

    // 更新最后同步时间戳 (逻辑不变)
    const timestampEl = document.getElementById('snoop-last-synced');
    if (snoopDataCache[contactId]) {
        const lastSyncTime = snoopDataCache[contactId].timestamp;
        const minutesAgo = Math.round((Date.now() - lastSyncTime) / 60000);
        timestampEl.textContent = minutesAgo < 1 ? '刚刚同步' : `数据同步于 ${minutesAgo} 分钟前`;
    }

    // 先清空内容区和可能的背景图
    bodyEl.innerHTML = '';
    bodyEl.style.backgroundImage = 'none'; // 清除可能残留的背景

    // 为照片和资产添加一点基本样式，让排版好看些
    const itemStyle = "background: white; border-radius: 8px; padding: 12px; margin-bottom: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.06);";
    const thoughtStyle = "font-size: 13px; color: #666; background: #f5f5f5; padding: 6px 10px; border-radius: 6px; margin-top: 8px; border-left: 3px solid #ccc;";

    try {
        switch (appType) {
            // --- 短信 (复用之前的渲染逻辑) ---
            case 'sms':
                if (!data.sms_log || data.sms_log.length === 0) {
                     html = '<p style="text-align:center; color:#999; padding: 20px;">还没有短信记录哦。</p>';
                } else {
                     html = data.sms_log.map(conversation => {
                        let conversationHTML = `<div class="snoop-sms-chat-container">`;
                        conversationHTML += `<div class="snoop-sms-header"><span class="contact-name">${conversation.contact}</span></div>`;
                        conversationHTML += `<div class="snoop-sms-area">`;
                        let lastTime = null;
                        (conversation.messages || []).forEach(msg => {
                            if (msg.time !== lastTime) {
                                conversationHTML += `<div class="snoop-sms-timestamp"><span>${msg.time}</span></div>`;
                                lastTime = msg.time;
                            }
                            const isSent = msg.sender === contact.name;
                            const rowClass = isSent ? 'sent' : 'received';
                            const bubbleClass = isSent ? 'sent' : 'received';
                            conversationHTML += `<div class="snoop-sms-row ${rowClass}"><div class="snoop-sms-bubble ${bubbleClass}">${msg.content}</div></div>`;
                        });
                        conversationHTML += `</div></div>`;
                        return conversationHTML;
                    }).join('');
                }
                break;

            // --- 通话记录 (复用之前的渲染逻辑) ---
            case 'call_log':
                 if (!data.call_log || data.call_log.length === 0) {
                    html = '<p style="text-align:center; color:#999; padding: 20px;">还没有通话记录哦。</p>';
                } else {
                    html = '<div style="display: flex; flex-direction: column; gap: 10px;">';
                    html += data.call_log.map(call => {
                        let iconClass = 'fa-phone-alt', iconColor = '#607d8b', typeText = '未知';
                        if (call.type.includes('呼入')) { iconClass = 'fa-phone-volume'; iconColor = '#81c784'; typeText = '呼入'; }
                        else if (call.type.includes('呼出')) { iconClass = 'fa-phone'; iconColor = '#ffb74d'; typeText = '呼出'; }
                        else if (call.type.includes('未接')) { iconClass = 'fa-phone-slash'; iconColor = '#e57373'; typeText = '未接'; }
                        return `
                        <div style="${itemStyle} display: flex; align-items: flex-start; gap: 15px;">
                            <div style="width: 45px; height: 45px; border-radius: 50%; background-color: ${iconColor}20; color: ${iconColor}; display: flex; align-items: center; justify-content: center; font-size: 20px; flex-shrink: 0;"><i class="fas ${iconClass}"></i></div>
                            <div style="flex-grow: 1;">
                                <div style="display: flex; justify-content: space-between; align-items: baseline;"><span style="font-weight: 600; font-size: 16px;">${call.name}</span><span style="font-size: 12px; color: #999;">${call.time}</span></div>
                                <div style="font-size: 13px; color: #777; margin-top: 4px;">${typeText} ${call.duration ? ` - 通话 ${call.duration}` : ''}</div>
                                <div style="margin-top: 8px; font-size: 14px; line-height: 1.5; background: #f9f9f9; padding: 8px 10px; border-radius: 6px;">${call.summary}</div>
                            </div>
                        </div>`;
                    }).join('');
                    html += '</div>';
                }
                break;

            // --- 浏览器 (复用之前的渲染逻辑) ---
            case 'browser':
                 if (!data.browser_history || data.browser_history.length === 0) {
                    html = '<p style="text-align:center; color:#999; padding: 20px;">还没有浏览记录哦。</p>';
                 } else {
                    html = '<ul class="trending-list" style="background:none; padding: 0;">';
                    html += data.browser_history.map(item => `
                        <li class="trending-item" style="background:white; margin-bottom:8px; border-radius:10px; padding: 15px; flex-direction: column; align-items: flex-start;">
                            <div style="display: flex; justify-content: space-between; width: 100%; align-items: center; margin-bottom: 8px;">
                                <div class="trending-title" style="font-size: 15px; flex-grow: 1; margin-right: 10px; word-wrap: break-word;"><i class="fas fa-search" style="color: #64b5f6; margin-right: 6px;"></i>${item.query}</div>
                                <span style="font-size: 12px; color: #aaa; flex-shrink: 0;">${item.time}</span>
                            </div>
                            <div style="font-size: 13px; color: #666; background: #e3f2fd; padding: 6px 10px; border-radius: 6px; width: 100%; margin-bottom: 5px; word-wrap: break-word;"><strong>原因:</strong> ${item.reason || '无'}</div>
                            <div style="font-size: 13px; color: #555; background: #f1f8e9; padding: 6px 10px; border-radius: 6px; width: 100%; word-wrap: break-word;"><strong>结果:</strong> ${item.found_content_summary || '无'}</div>
                        </li>
                    `).join('');
                    html += '</ul>';
                 }
                 break;

            // --- 购物 (复用之前的渲染逻辑) ---
             case 'shopping':
                html = '<div style="display: flex; flex-direction: column; gap: 15px;">';
                html += '<h3>🛒 购物车</h3>';
                if (!data.shopping_cart || data.shopping_cart.length === 0) {
                    html += '<p style="color:#999; text-align:center;">购物车是空的</p>';
                } else {
                    html += data.shopping_cart.map(item => `<div style="${itemStyle}"><div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;"><span style="font-weight: 600; font-size: 15px; word-wrap: break-word;">${item.item}</span><span style="color:#ff7043; font-weight:bold; font-size: 16px; flex-shrink: 0; margin-left: 10px;">¥${item.price}</span></div>${item.reason ? `<div style="${thoughtStyle} background: #fef7e0; border-left-color: #ffcc80;">🛒 想买：${item.reason}</div>` : ''}</div>`).join('');
                }
                html += '<h3 style="margin-top:10px;">🧾 最近购买</h3>';
                 if (!data.purchase_history || data.purchase_history.length === 0) {
                    html += '<p style="color:#999; text-align:center;">最近没有购买记录</p>';
                } else {
                    html += data.purchase_history.map(item => `<div style="${itemStyle}"><div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;"><span style="font-weight: 600; font-size: 15px; word-wrap: break-word;">${item.item} <span style="font-size:12px; color:#999; font-weight: normal;">(${item.date})</span></span><span style="font-weight:bold; font-size: 16px; flex-shrink: 0; margin-left: 10px;">¥${item.price}</span></div>${item.thought ? `<div style="${thoughtStyle} background: #e8f5e9; border-left-color: #a5d6a7;">💡 当时想：${item.thought}</div>` : ''}</div>`).join('');
                }
                html += '</div>';
                break;

            // --- 备忘录 (复用之前的渲染逻辑) ---
            case 'memos':
                if (!data.memos || data.memos.length === 0) {
                    html = '<p style="text-align:center; color:#999; padding: 20px;">备忘录是空的哦。</p>';
                } else {
                    html = '<div style="display: flex; flex-direction: column; gap: 12px;">';
                    html += data.memos.map(memo => `
                        <div style="${itemStyle} border-left: 4px solid #ffc107;">
                            <div style="display: flex; align-items: flex-start; width: 100%; margin-bottom: 8px;">
                                <i class="${memo.icon && memo.icon.startsWith('fas fa-') ? memo.icon : 'fas fa-pencil-alt'}" style="color: #a08d53; margin-right: 12px; font-size: 1.2em; margin-top: 2px; width: 20px; text-align: center;"></i>
                                <div style="font-size: 15px; line-height: 1.6; color: #333; flex-grow: 1; word-wrap: break-word;">${memo.content.replace(/\n/g, '<br>')}</div>
                            </div>
                            ${memo.thought ? `<div style="${thoughtStyle} background: #fffde7;">💡 当时想：${memo.thought}</div>` : ''}
                        </div>`).join('');
                    html += '</div>';
                }
                break;

            // --- 视频/小说 (复用之前的渲染逻辑) ---
            case 'videos':
            case 'novels':
                 const mediaData = data.media_history || {};
                 if (appType === 'novels') {
                     const items = mediaData.novels || [];
                     if (items.length === 0) { html = '<p style="text-align:center; color:#999; padding: 20px;">最近没有看小说哦。</p>'; }
                     else { html = items.map(novel => `<div class="world-book-item" style="${itemStyle} margin-bottom: 15px;"><div class="book-header" style="margin-bottom: 10px;"><div class="book-name" style="font-size: 16px; word-wrap: break-word;"><i class="fas fa-book-reader" style="margin-right: 8px; color: #ba68c8;"></i>${novel.title}</div></div>${novel.review ? `<div style="font-size: 14px; color: #555; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px dashed #e0e0e0; word-wrap: break-word;">💬 书评：${novel.review}</div>` : ''}${novel.highlight && novel.highlight.text ? `<div style="background: #f3e5f5; padding: 10px 12px; border-radius: 8px; border-left: 3px solid #ce93d8;"><p style="font-size: 14px; color: #8e44ad; margin: 0 0 6px 0; line-height: 1.5; word-wrap: break-word;">📌 收藏：“${novel.highlight.text}”</p>${novel.highlight.comment ? `<p style="font-size: 13px; color: #ab47bc; margin: 0; word-wrap: break-word;">✍️ 想法：${novel.highlight.comment}</p>` : ''}</div>` : ''}</div>`).join(''); }
                 } else if (appType === 'videos') {
                     const items = mediaData.videos || [];
                      if (items.length === 0) { html = '<p style="text-align:center; color:#999; padding: 20px;">最近没有刷视频哦。</p>'; }
                      else { html = '<div style="display: flex; flex-direction: column; gap: 15px;">'; html += items.map(item => { let icon = 'fa-eye', color = '#90a4ae', text = '浏览'; switch (item.interaction) { case 'liked': icon = 'fa-heart'; color = '#ef5350'; text = '点赞了'; break; case 'commented': icon = 'fa-comment-dots'; color = '#42a5f5'; text = '评论了'; break; case 'shared': icon = 'fa-share'; color = '#66bb6a'; text = '分享了'; break; case 'bookmarked': icon = 'fa-bookmark'; color = '#ffb74d'; text = '收藏了'; break; } return `<div style="${itemStyle} display: flex; gap: 10px;"><div style="width: 70px; height: 90px; background-color: #f0f2f5; border-radius: 6px; display: flex; align-items: center; justify-content: center; color: #bdbdbd; font-size: 24px; flex-shrink: 0;"><i class="fas fa-film"></i></div><div style="flex-grow: 1; display: flex; flex-direction: column;"><div><div style="font-weight: 600; font-size: 15px; margin-bottom: 4px; word-wrap: break-word;">${item.title}</div><div style="font-size: 13px; color: #666; margin-bottom: 8px; word-wrap: break-word;">${item.description || '暂无描述'}</div></div><div style="margin-top: auto; padding-top: 8px; border-top: 1px solid #f5f5f5; display: flex; flex-direction: column; gap: 5px;"><div style="display: flex; align-items: center; gap: 5px; font-size: 12px; color: ${color};"><i class="fas ${icon}"></i><span>${text} ${item.like_count ? ` · ${item.like_count} 赞` : ''}</span></div>${item.thought ? `<div style="${thoughtStyle} display: flex; align-items: flex-start; gap: 4px;"><i class="far fa-comment-alt" style="margin-top: 2px;"></i><span style="word-wrap: break-word; flex: 1;">想法: ${item.thought}</span></div>` : ''}</div></div></div>`; }).join(''); html += '</div>'; }
                 }
                 break;

            // --- 甜蜜空间/时间线 (复用之前的渲染逻辑) ---
            case 'couple_app':
                bodyEl.style.padding = '15px';

                html = '<div id="sweet-space-timeline" style="display: flex; flex-direction: column;">';

                if (!data.timeline_events || data.timeline_events.length === 0) {
                    html += '<p style="text-align:center; color:#888; background: rgba(255,255,255,0.7); padding: 20px; border-radius: 10px;">今天还没有活动记录哦~</p>';
                } else {
                    let lastTime = null;
                    const sortedEvents = [...data.timeline_events].reverse();

                    sortedEvents.forEach(event => {
                        if (event.time !== lastTime) {
                            html += `<div style="text-align: center; color: #aaa; font-size: 12px; margin: 15px 0 10px 0; background-color: rgba(230, 230, 230, 0.6); padding: 3px 8px; border-radius: 10px; display: inline-block; position: relative; left: 50%; transform: translateX(-50%);">${event.time}</div>`;
                            lastTime = event.time;
                        }

                        let iconColor = '#ff8aae';
                        if (event.icon.includes('lock')) iconColor = '#90a4ae';
                        if (event.icon.includes('signal')) iconColor = '#4dd0e1';
                        if (event.icon.includes('shopping')) iconColor = '#ff8a65';
                        if (event.icon.includes('youtube')) iconColor = '#e57373';
                        if (event.icon.includes('map')) iconColor = '#81c784';
                        if (event.icon.includes('comment')) iconColor = '#4caf50';
                        if (event.icon.includes('book')) iconColor = '#ba68c8';
                        if (event.icon.includes('phone')) iconColor = '#64b5f6';
                        if (event.icon.includes('camera')) iconColor = '#fff176';
                        if (event.icon.includes('music')) iconColor = '#f06292';
                        if (event.icon.includes('gamepad')) iconColor = '#7986cb';
                        if (event.icon.includes('wallet')) iconColor = '#ffd54f';
                        if (event.icon.includes('calendar')) iconColor = '#a1887f';
                        if (event.icon.includes('cloud-sun')) iconColor = '#4fc3f7';

                        html += `
                            <div class="message-wrapper" style="align-self: center; margin-bottom: 8px; max-width: 85%;">
                                <div class="message-body" style="align-items: center;">
                                    <div class="message" style="background-color: #ffffff; border-radius: 18px; display: flex; align-items: center; padding: 8px 15px; box-shadow: 0 1px 2px rgba(0,0,0,0.1);">
                                        <i class="${event.icon || 'fas fa-info-circle'}" style="color: ${iconColor}; margin-right: 8px; font-size: 1.1em;"></i>
                                        <span style="font-size: 14px; color: #555; word-wrap: break-word;">${event.description}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    });

                    if (data.unlock_count) {
                        html += `
                        <div style="background-color: rgba(255, 235, 238, 0.8); border: 1px solid #ffcdd2; color: #c2185b; padding: 10px 15px; border-radius: 12px; text-align: center; font-size: 13px; margin-top: 20px; font-weight: 500;">
                            <i class="fas fa-calculator"></i> Ta 今日拿手机次数${data.unlock_count > 20 ? '超出 20 次' : `为 ${data.unlock_count} 次`}~
                        </div>`;
                    }
                }
                html += '</div>';
                break;

// --- 音乐 (V5 - 模仿截图样式 + 右侧信息) ---
            case 'music':
                const musicData = data.music_activity || {};
                html = '<div class="snoop-music-list">';
                if (musicData.recently_played && musicData.recently_played.length > 0) {
html += musicData.recently_played.map((song, index) => {
                        let metaRightHTML = '';
                        if (song.duration_listened) {
                            metaRightHTML += `<span class="snoop-music-duration">${song.duration_listened}</span>`;
                        }
                        if (song.platform) {
                            metaRightHTML += `<span class="snoop-music-platform ${song.duration_listened ? 'new-line' : ''}">@ ${song.platform}</span>`;
                        }

                        // --- 新增：准备“想法”的 HTML ---
                        let thoughtHTML = '';
                        if (song.thought) {
                            // 使用新的 CSS 类 snoop-music-thought
                            thoughtHTML = `<div class="snoop-music-thought">${song.thought}</div>`;
                        }
                        // --- 新增结束 ---

                        return `
                        <div class="snoop-music-item">
                            <div class="snoop-music-index">${index + 1}</div>
                            <div class="snoop-music-cover">
                                <i class="fas fa-music"></i>
                            </div>
                            <div class="snoop-music-info">
                                <div class="snoop-music-title">${song.song_title || '未知歌曲'}</div>
                                <div class="snoop-music-artist">${song.artist || '未知艺术家'}</div>
                                
                                ${thoughtHTML}
                                
                            </div>
                            <div class="snoop-music-meta-right">
                                ${metaRightHTML}
                            </div>
                        </div>
                    `}).join('');
                } else {
                    html += '<p style="text-align:center; color:#999; padding: 20px;">最近没有听歌记录哦。</p>';
                }
                html += '</div>';

                // 总时长显示 (不变)
                if (musicData.total_recent_duration) {
                     html += `<p style="text-align: center; margin-top: 15px; font-size: 13px; color: #888;">最近总听歌时长：${musicData.total_recent_duration}</p>`;
                }
                break;
            // --- 音乐 V5 结束 ---

// --- 相册 (V5 - 图标点击展开样式, thought样式修正) ---
            case 'photos':
                const gallery = data.photo_gallery || {};
                html = '';

                // 注意：这里我们把 thoughtStyle 变量的内容直接整合进了CSS (.thought-style-div)
                // 所以下面生成HTML时，直接使用 <div class="thought-style-div"> 即可

                const createPhotoItemHTML = (item, iconClass, detailsGenerator) => {
                    const itemId = `photo-item-${Date.now()}-${Math.random().toString(16).slice(2)}`;
                    return `
                        <div class="snoop-photo-item-container">
                            <div class="snoop-photo-item" data-details-id="${itemId}" title="点击查看详情">
                                <i class="fas ${iconClass}"></i>
                            </div>
                            <div class="snoop-photo-details" id="${itemId}">
                                ${detailsGenerator(item)}
                            </div>
                        </div>`;
                };

                // --- 最近拍摄 ---
                html += `<h3><i class="fas fa-camera"></i> 最近拍摄</h3>`;
                if (gallery.recent_camera && gallery.recent_camera.length > 0) {
                    html += '<div class="snoop-photo-grid">';
                    html += gallery.recent_camera.map(p => createPhotoItemHTML(p, 'fa-camera-retro', item => `
                        <p><strong>描述:</strong> ${item.description || '无'}</p>
                        <p><small>时间: ${item.time || '未知'} ${item.location ? `| 地点: ${item.location}` : ''}</small></p>
                        ${item.thought ? `<div class="thought-style-div">💡 想法：${item.thought}</div>` : ''}
                    `)).join('');
                    html += '</div>';
                } else {
                    html += '<p style="text-align:center; color:#999; padding: 10px 0;">无</p>';
                }

                // --- 屏幕截图 ---
                html += `<h3 style="margin-top: 20px;"><i class="fas fa-crop-alt"></i> 屏幕截图</h3>`;
                if (gallery.screenshots && gallery.screenshots.length > 0) {
                     html += '<div class="snoop-photo-grid">';
                     html += gallery.screenshots.map(s => createPhotoItemHTML(s, 'fa-crop', item => `
                        <p><strong>内容:</strong> ${item.content_summary || '无'}</p>
                        <p><small>时间: ${item.time || '未知'} | App: ${item.app_name || '未知'}</small></p>
                        ${item.thought ? `<div class="thought-style-div">💡 想法：${item.thought}</div>` : ''}
                     `)).join('');
                     html += '</div>';
                } else {
                    html += '<p style="text-align:center; color:#999; padding: 10px 0;">无</p>';
                }

                // --- 私密相册 ---
                html += `<h3 style="margin-top: 20px;"><i class="fas fa-lock"></i> 私密相册</h3>`;
                if (gallery.private_album && gallery.private_album.length > 0) {
                     html += '<div class="snoop-photo-grid">';
                     html += gallery.private_album.map(p => createPhotoItemHTML(p, 'fa-user-secret', item => `
                        <p><strong>描述:</strong> ${item.description || '无'}</p>
                        <div class="thought-style-div reason-private">🔒 原因：${item.reason_private || '未说明'}</div>
                     `)).join('');
                     html += '</div>';
                } else {
                    html += '<p style="text-align:center; color:#999; padding: 10px 0;">无</p>';
                }
                break;
            // --- 相册 V5 结束 ---

// --- 资产 (V4 - 银行卡 + 详细投资 + 流水) ---
            case 'assets':
                const assets = data.financial_assets || {};
                html = '<div class="snoop-assets-container">'; // 新增容器

                // --- 渲染银行卡 ---
                html += `<h3><i class="fas fa-credit-card"></i> 银行卡</h3>`;
                if (assets.bank_cards && assets.bank_cards.length > 0) {
                    html += '<div class="snoop-bank-cards-grid">'; // 网格布局
                    html += assets.bank_cards.map(card => `
                        <div class="snoop-bank-card">
                            <div class="snoop-bank-card-name">${card.card_name || '未知银行卡'} (${card.card_number_last4 || '尾号未知'})</div>
                            <div class="snoop-bank-card-balance">${card.balance || '¥0.00'}</div>
                        </div>
                    `).join('');
                    html += '</div>';
                } else {
                    html += '<p style="text-align:center; color:#999; padding: 10px 0;">暂无银行卡信息。</p>';
                }

                // --- 渲染投资组合 ---
// --- 渲染投资组合 (V6 - 表格样式) ---
                html += `<h3 style="margin-top: 20px;"><i class="fas fa-chart-pie"></i> 投资组合</h3>`; // 修改图标
                if (assets.investments && assets.investments.length > 0) {
                    html += '<div class="snoop-investments-list-v6">'; // 新容器类名
                    // --- 添加表头 ---
                    html += `
                        <div class="snoop-investment-header-row">
                            <div class="inv-col-name">名称/金额</div>
                            <div class="inv-col-daily">日收益</div>
                            <div class="inv-col-holding">持有收益</div>
                            <div class="inv-col-cumulative">累计收益</div>
                        </div>
                    `;
                    // --- 渲染每一项 ---
                    html += assets.investments.map(inv => {
                        // --- 判断各种收益的正负并添加 CSS 类 ---
                        const getStatusClass = (statusString) => {
                            if (!statusString) return 'neutral';
                            if (statusString.includes('+') || (statusString.includes('¥') && !statusString.includes('-'))) return 'profit'; // 包含+ 或 包含¥但不含-
                            if (statusString.includes('-')) return 'loss';
                            return 'neutral';
                        };
                        const dailyClass = getStatusClass(inv.daily_profit_loss);
                        const holdingClass = getStatusClass(inv.holding_profit_loss);
                        const cumulativeClass = getStatusClass(inv.cumulative_profit_loss);
                        // --- 判断结束 ---
                        return `
                        <div class="snoop-investment-item-v6">
                            <div class="inv-col-name">
                                <span class="inv-name">${inv.name || '未知产品'} <span class="inv-type">[${inv.type || '未知'}]</span></span>
                                <span class="inv-value">${inv.current_value || '¥0.00'}</span>
                                <span class="inv-percentage">${inv.holding_percentage || '占比 --'}</span>
                            </div>
                            <div class="inv-col-daily ${dailyClass}">${inv.daily_profit_loss || '0.00'}</div>
                            <div class="inv-col-holding ${holdingClass}">${inv.holding_profit_loss || '0.00'}</div>
                            <div class="inv-col-cumulative ${cumulativeClass}">${inv.cumulative_profit_loss || '--'}</div>
                        </div>
                    `}).join('');
                    html += '</div>'; // 结束 .snoop-investments-list-v6
                } else {
                    html += '<p style="text-align:center; color:#999; padding: 10px 0;">暂无投资记录。</p>';
                }
// --- 渲染最近交易流水 (V6 - 银行明细样式) ---
                html += `<h3 style="margin-top: 20px;"><i class="fas fa-receipt"></i> 最近账单流水</h3>`;
                if (assets.recent_transactions && assets.recent_transactions.length > 0) {
                     html += '<div class="snoop-transactions-list-v6">'; // 新容器类名
                     html += assets.recent_transactions.map(tx => {
                        const amountClass = tx.type === '收入' ? 'income' : 'expense';
                        const amountText = tx.amount || '0.00';
                        // --- 尝试从描述中分离出方法/对象 (可能不完美) ---
                        let mainDesc = tx.description || '未知交易';
                        let subDesc = tx.time || '时间未知'; // 默认把时间放下面
                        const separators = ['-', ' via ', '来自', '发给', '通过', '来自']; // 可能的分隔符
                        for (const sep of separators) {
                            if (mainDesc.includes(sep)) {
                                const parts = mainDesc.split(sep);
                                mainDesc = parts[0].trim(); // 主要描述
                                subDesc = sep + parts.slice(1).join(sep).trim() + ` (${tx.time || ''})`; // 次要描述+时间
                                break;
                            }
                        }
                        // --- 分离结束 ---
                        return `
                        <div class="snoop-transaction-item-v6">
                            <div class="tx-left">
                                <div class="tx-desc">${mainDesc}</div>
                                <div class="tx-subdesc">${subDesc}</div> 
                            </div>
                            <div class="tx-amount ${amountClass}">${amountText}</div>
                        </div>`;
                     }).join('');
                     html += '</div>'; // 结束 .snoop-transactions-list-v6
                } else {
                     html += '<p style="text-align:center; color:#999; padding: 10px 0;">暂无交易记录。</p>';
                }
                html += '</div>'; // 结束 .snoop-assets-container
                break;
            // --- 资产 V4 结束 ---
// --- 微信 (使用新的专属类名渲染) ---
            case 'wechat':
                const wechatLog = data.wechat_log || [];
                if (wechatLog.length === 0) {
                    html = '<p style="text-align:center; color:#999; padding: 20px;">还没有微信聊天记录哦。</p>';
                } else {
                    html = wechatLog.map(conversation => {
                         // ▼▼▼ 注意：这里所有的 class 都改成了 snoop-wechat- ▼▼▼
                         let conversationHTML = `<div class="snoop-wechat-chat-container">`; // <--- 修改
                         conversationHTML += `<div class="snoop-wechat-header"><span class="contact-name">${conversation.contact} ${conversation.is_group_chat ? '(群聊)' : ''}</span></div>`; // <--- 修改
                         conversationHTML += `<div class="snoop-wechat-area">`; // <--- 修改
                         let lastTime = null;
                         (conversation.messages || []).forEach(msg => {
                             if (msg.time !== lastTime) {
                                 conversationHTML += `<div class="snoop-wechat-timestamp"><span>${msg.time}</span></div>`; // <--- 修改
                                 lastTime = msg.time;
                             }
                             const isSent = msg.sender === contact.name; // 假设 contact 变量在此可用
                             const rowClass = isSent ? 'sent' : 'received';
                             const bubbleClass = isSent ? 'sent' : 'received';
                             const senderName = conversation.is_group_chat && !isSent ? `<div style="font-size: 11px; color: #888; margin-bottom: 2px;">${msg.sender}</div>` : '';
                             conversationHTML += `<div class="snoop-wechat-row ${rowClass}"><div style="max-width: 100%;">${senderName}<div class="snoop-wechat-bubble ${bubbleClass}">${msg.content}</div></div></div>`; // <--- 修改 x2
                         });
                         conversationHTML += `</div></div>`;
                         // ▲▲▲ 类名修改结束 ▲▲▲
                         return conversationHTML;
                    }).join('');
                }
                break;
            default:
                 html = '<p style="text-align:center; color:#999; padding: 20px;">未知应用类型。</p>';
                 break;
        }

        bodyEl.innerHTML = html || '<p style="text-align:center; color:#999; padding: 20px;">TA的这部分生活还是空白哦~</p>';

    } catch (e) {
        console.error("渲染窥探内容失败:", e);
        bodyEl.innerHTML = `<p style="text-align:center; color:var(--soft-red); padding: 20px;">内容格式错误或数据不完整，无法显示。<br><small>${e.message}</small></p>`;
    }
}
// ▲▲▲ 替换 displaySnoopContent 结束 ▲▲▲
// ▲▲▲ 替换 displaySnoopContent 结束 ▲▲▲
// =========== ▼▼▼ 地图功能核心逻辑 (V2 多地图版) ▼▼▼ ========
// ==========================================================
let currentMapData = null; // 用于存储当前正在编辑的地图数据
let editingLocationId = null;
let editingMapId = null;

// 函数：显示地图管理中心
async function showMapManagementScreen() {
    hideAllScreens();
    document.getElementById('map-management-screen').style.display = 'flex';
    await renderMapList();
}

// 函数：渲染地图管理列表
async function renderMapList() {
    const maps = await kokoMemory.getAll('maps');
    const listEl = document.getElementById('map-list');
    listEl.innerHTML = '';

    if (maps.length === 0) {
        listEl.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><p>还没有创建任何地图。</p><p>点击右上角“+”来创建你的第一个世界吧！</p></div>`;
        return;
    }

    maps.forEach(map => {
        const item = document.createElement('div');
        item.className = 'preset-item';
        item.dataset.mapId = map.id;
        item.innerHTML = `
            <div class="preset-info">
                <div class="preset-name">${map.name}</div>
                <div class="preset-desc">${map.description ? map.description.substring(0, 50) + '...' : '暂无描述'}</div>
            </div>
            <div class="preset-actions">
                <span class="preset-action-btn edit-map-btn" title="编辑地图宏观信息"><i class="fas fa-edit"></i></span>
                <span class="preset-action-btn delete delete-map-btn" title="删除地图"><i class="fas fa-trash-alt"></i></span>
            </div>
        `;
        // 点击整个条目进入地图编辑器
        item.querySelector('.preset-info').addEventListener('click', () => openMapScreen(map.id));
        listEl.appendChild(item);
    });
}
// 智能打开地图并定位到具体地点（支持自动钻取层级）
async function openMapAndFocusLocation(mapId, locationId) {
    const mapData = await kokoMemory.get('maps', mapId);
    if (!mapData) {
        alert('地图数据不存在！');
        return;
    }
    
    const targetLoc = mapData.locations.find(l => l.id === locationId);
    
    // 如果找不到地点，或者地点在最外层，就用普通方式打开
    if (!targetLoc) {
        openMapScreen(mapId);
        if (locationId) alert('未找到该地点，可能已被删除。');
        return;
    }

    // --- 核心逻辑：倒推家谱，构建面包屑 ---
    currentMapData = mapData;
    mapNavigationStack = []; // 先清空
    
    let curr = targetLoc;
    // 只要它有父级，就往上找
    while (curr.parentId) {
        const parent = mapData.locations.find(l => l.id === curr.parentId);
        if (parent) {
            // 把父级加到栈的开头（因为我们是倒着找的）
            mapNavigationStack.unshift({ id: parent.id, name: parent.name });
            curr = parent; // 继续往上找爷爷
        } else {
            break; // 找不到父级数据（可能父级被删了），停止
        }
    }

    // 设置当前层级为目标地点的父级ID
    currentMapParentId = targetLoc.parentId;

    // --- 渲染UI ---
    hideAllScreens();
    document.getElementById('map-screen').style.display = 'flex';
    document.getElementById('map-title').textContent = currentMapData.name;

    renderMapIcons(); // 这会根据 currentMapParentId 渲染正确的层级
    
    // 最后，聚焦高亮
    setTimeout(() => {
        focusOnLocation(locationId);
    }, 300); // 稍微延迟一点，等待渲染完成
}
// 打开并渲染指定的地图编辑器（修改版：初始化嵌套状态）
async function openMapScreen(mapId) {
    const mapData = await kokoMemory.get('maps', mapId);
    if (!mapData) {
        alert('找不到地图数据！');
        return;
    }
    currentMapData = mapData;

    // ▼▼▼ 新增：每次打开地图时，重置到最外层 ▼▼▼
    currentMapParentId = null; // 默认回到最外层 (Root)
    mapNavigationStack = [];   // 清空面包屑导航历史
    // ▲▲▲ 新增结束 ▲▲▲

    hideAllScreens();
    document.getElementById('map-screen').style.display = 'flex';
    document.getElementById('map-title').textContent = currentMapData.name;

    renderMapIcons(); // 这会自动渲染第一层的内容
}

// 渲染当前层级的所有地点图标 + 目录列表
function renderMapIcons() {
    const container = document.getElementById('map-grid-container');
    const directoryList = document.getElementById('map-directory-list'); // 获取目录容器
    
    container.innerHTML = ''; 
    directoryList.innerHTML = ''; // 清空目录

    if (currentMapData && currentMapData.locations) {
        // 1. 核心筛选：只显示 parentId 等于当前层级ID 的地点
        // (兼容旧数据：如果 loc.parentId 不存在，视为 null)
        const visibleLocations = currentMapData.locations.filter(loc => {
            const locParent = loc.parentId || null;
            return locParent === currentMapParentId;
        });

        // 如果当前层级没东西，显示提示
        if (visibleLocations.length === 0) {
            directoryList.innerHTML = '<div style="padding:10px; color:#999; text-align:center; font-size:12px;">当前区域暂无地点</div>';
        }

        visibleLocations.forEach(loc => {
            // --- A. 渲染地图上的图标 ---
            const iconEl = document.createElement('div');
            iconEl.className = 'map-icon';
            iconEl.dataset.locationId = loc.id;
            iconEl.classList.add('tier-' + (loc.tier || 2));
            iconEl.style.left = `${loc.x}px`;
            iconEl.style.top = `${loc.y}px`;
            // 增加双击进入功能
            iconEl.ondblclick = (e) => {
                e.stopPropagation(); // 防止触发添加
                enterMapLayer(loc);
            };
            
            iconEl.innerHTML = `
                <i class="${loc.icon || 'fas fa-map-marker-alt'}" style="color: ${loc.color || '#333'}"></i>
                <span class="map-icon-label">${loc.name}</span>
            `;
            container.appendChild(iconEl);

            // --- B. 渲染右上角的目录项 ---
            const dirItem = document.createElement('div');
            dirItem.className = 'directory-item';
            dirItem.innerHTML = `<i class="${loc.icon || 'fas fa-map-marker-alt'}"></i><span>${loc.name}</span>`;
            
            // 点击目录：定位并高亮
            dirItem.addEventListener('click', () => {
                focusOnLocation(loc.id);
            });
            
            directoryList.appendChild(dirItem);
        });
    }
    
    // 渲染面包屑导航
    renderMapBreadcrumbs();
}
// 进入某个地点的内部层级
function enterMapLayer(location) {
    // 压入历史栈
    mapNavigationStack.push({
        id: location.id,
        name: location.name
    });
    // 更新当前父ID
    currentMapParentId = location.id;
    
    // 重新渲染
    renderMapIcons();
}

// 返回到某一层
function navigateToMapLayer(targetId) {
    if (targetId === 'root') {
        currentMapParentId = null;
        mapNavigationStack = [];
    } else {
        // 找到目标在栈中的索引
        const index = mapNavigationStack.findIndex(item => item.id === targetId);
        if (index !== -1) {
            // 截断数组，保留目标层级及之前的
            mapNavigationStack = mapNavigationStack.slice(0, index + 1);
            currentMapParentId = targetId;
        }
    }
    renderMapIcons();
}

// 渲染面包屑 (修正版：使用 dataset 绑定，解决点击无反应问题)
function renderMapBreadcrumbs() {
    const container = document.getElementById('map-breadcrumbs');
    
    // 1. 渲染根节点 (世界/城市名)
    // 注意：去掉了 onclick="..."，改用 data-target-id="root"
    let html = `<span class="breadcrumb-item ${currentMapParentId === null ? 'active' : ''}" data-target-id="root">🗺️ ${currentMapData.name}</span>`;
    
    // 2. 渲染中间层级
    mapNavigationStack.forEach((level, index) => {
        const isActive = (index === mapNavigationStack.length - 1);
        html += `
            <span class="breadcrumb-separator"><i class="fas fa-chevron-right" style="font-size:10px;"></i></span>
            <span class="breadcrumb-item ${isActive ? 'active' : ''}" 
                  ${!isActive ? `data-target-id="${level.id}"` : ''}>
                  ${level.name}
            </span>
        `;
    });
    
    container.innerHTML = html;
}

// 定位并高亮某个地点
function focusOnLocation(locId) {
    const icon = document.querySelector(`.map-icon[data-location-id="${locId}"]`);
    if (!icon) return;

    // 1. 移除所有旧高亮
    document.querySelectorAll('.map-icon.highlighted').forEach(el => el.classList.remove('highlighted'));

    // 2. 添加新高亮
    icon.classList.add('highlighted');
    
    // 3. 滚动容器，让图标居中
    const container = document.querySelector('.api-content'); // 滚动的容器
    const containerWidth = container.offsetWidth;
    const containerHeight = container.offsetHeight;
    
    // 这里的 left/top 是相对于 1000x1000 画布的
    const targetX = parseInt(icon.style.left); 
    const targetY = parseInt(icon.style.top);

    container.scrollTo({
        left: targetX - containerWidth / 2,
        top: targetY - containerHeight / 2,
        behavior: 'smooth'
    });
    
    // 4. 1.5秒后自动移除高亮
    setTimeout(() => icon.classList.remove('highlighted'), 1500);
}

// 打开地点编辑/添加弹窗（修改版：移除了地点级别选择）
function openLocationModal(config) {
    const modal = document.getElementById('map-location-modal');
    const titleEl = document.getElementById('map-location-modal-title');
    const deleteBtn = document.getElementById('delete-map-location-btn');

    // 重置输入框
    document.getElementById('location-id-input').value = '';
    document.getElementById('location-name-input').value = '';
    document.getElementById('location-icon-input').value = 'fas fa-map-marker-alt';
    document.getElementById('location-description-input').value = '';
    // ❌ 删除了 tier 的重置代码

    // 检查并添加“进入该地点内部”按钮
    let enterBtn = document.getElementById('enter-map-layer-btn');
    if (!enterBtn) {
        enterBtn = document.createElement('button');
        enterBtn.id = 'enter-map-layer-btn';
        enterBtn.className = 'form-button';
        enterBtn.style.backgroundColor = '#673ab7';
        enterBtn.style.marginTop = '10px';
        enterBtn.innerHTML = '<i class="fas fa-door-open"></i> 进入该地点内部';
        const saveBtn = document.getElementById('save-map-location-btn');
        saveBtn.parentNode.insertBefore(enterBtn, saveBtn);
        
        enterBtn.addEventListener('click', () => {
            const locId = document.getElementById('location-id-input').value;
            if(locId) {
                const loc = currentMapData.locations.find(l => l.id === locId);
                if(loc) {
                    document.getElementById('map-location-modal').style.display = 'none';
                    enterMapLayer(loc);
                }
            }
        });
    }

    if (config.isEditing) {
        // --- 编辑模式 ---
        titleEl.textContent = '编辑地点';
        editingLocationId = config.location.id;
        document.getElementById('location-id-input').value = config.location.id;
        document.getElementById('location-x-input').value = config.location.x;
        document.getElementById('location-y-input').value = config.location.y;
        document.getElementById('location-name-input').value = config.location.name;
        document.getElementById('location-icon-input').value = config.location.icon;
        document.getElementById('location-description-input').value = config.location.description;
        
        // ❌ 删除了 tier 的赋值代码
        
        deleteBtn.style.display = 'block';
        enterBtn.style.display = 'block';
    } else {
        // --- 新增模式 ---
        titleEl.textContent = '在地图上添加新地点';
        editingLocationId = null;
        document.getElementById('location-x-input').value = config.x;
        document.getElementById('location-y-input').value = config.y;
        
        // ❌ 删除了 tier 的赋值代码
        
        deleteBtn.style.display = 'none';
        enterBtn.style.display = 'none';
    }
    modal.style.display = 'flex';
}

// 函数：打开地图宏观信息编辑弹窗
function openMapDetailsModal(map = null) {
    const modal = document.getElementById('map-details-modal');
    if (map) {
        // 编辑模式
        editingMapId = map.id;
        document.getElementById('map-details-modal-title').textContent = '编辑地图信息';
        document.getElementById('map-id-input').value = map.id;
        document.getElementById('map-name-input').value = map.name;
        document.getElementById('map-description-input').value = map.description || '';
    } else {
        // 创建模式
        editingMapId = null;
        document.getElementById('map-details-modal-title').textContent = '创建新地图';
        document.getElementById('map-id-input').value = '';
        document.getElementById('map-name-input').value = '';
        document.getElementById('map-description-input').value = '';
    }
    modal.style.display = 'flex';
}

// 函数：更新联系人设置里的地图下拉菜单
async function updateContactMapSelector() {
    const maps = await kokoMemory.getAll('maps');
    const selectEl = document.getElementById('contact-map-select');
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!selectEl || !contact) return;

    selectEl.innerHTML = '<option value="">-- 不关联任何地图 --</option>';
    maps.forEach(map => {
        const option = document.createElement('option');
        option.value = map.id;
        option.textContent = map.name;
        if (contact.mapId === map.id) {
            option.selected = true;
        }
        selectEl.appendChild(option);
    });
}
async function openLocationPicker(mapId) {
    const modal = document.getElementById('send-location-modal');
    const listEl = document.getElementById('location-picker-list');
    listEl.innerHTML = '<p>加载中...</p>'; // 提示用户正在加载

    const mapData = await kokoMemory.get('maps', mapId);

    if (!mapData || !mapData.locations || mapData.locations.length === 0) {
        listEl.innerHTML = '<p style="color: #888; text-align: center;">这张地图上还没有设定任何地点。</p>';
    } else {
        listEl.innerHTML = ''; // 清空加载提示
        mapData.locations.forEach(location => {
            const item = document.createElement('div');
            item.className = 'discover-item'; // 复用一个看起来不错的现有样式
            item.style.marginBottom = '8px';
            item.innerHTML = `
                <div class="discover-icon"><i class="${location.icon || 'fas fa-map-marker-alt'}"></i></div>
                <div class="discover-info">
                    <div class="discover-name">${location.name}</div>
                    <div class="discover-desc">${location.description.substring(0, 30)}...</div>
                </div>
            `;
            // 【核心】为每个地点条目绑定点击事件
            item.addEventListener('click', async () => {
                // 创建并发送位置消息
                await createAndAddMessage({
                    type: 'location_share',
                    content: {
                        mapId: mapId,
                        locationId: location.id,
                        name: location.name,
                        icon: location.icon,
                        x: location.x,
                        y: location.y
                    }
                });
                modal.style.display = 'none'; // 发送后关闭弹窗
            });
            listEl.appendChild(item);
        });
    }

    modal.style.display = 'flex';
    // 绑定关闭按钮
    document.getElementById('close-location-picker-modal').addEventListener('click', () => {
        modal.style.display = 'none';
    }, { once: true });
}
// ▼▼▼ 把下面所有新函数，完整地粘贴到你的JS代码区 ▼▼▼
/// ▼▼▼ 使用这个【超级加强版】替换旧的 refresh-snoop-data-btn 监听代码 ▼▼▼

// --- 新增：为窥探模式的“刷新”按钮绑定【真正刷新】的功能 ---
document.getElementById('refresh-snoop-data-btn').addEventListener('click', async () => {
    const screen = document.getElementById('snooped-phone-screen');
    const contactId = screen.dataset.currentContactId;
    const refreshBtn = document.getElementById('refresh-snoop-data-btn');
    const timestampEl = document.getElementById('snoop-last-synced');

    if (contactId && refreshBtn) {
        // 1. 开始加载：禁用按钮，显示旋转图标，更新提示文字
        refreshBtn.disabled = true;
        refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>'; // 显示旋转图标
        timestampEl.textContent = '正在同步最新数据...';
        timestampEl.style.color = '#888'; // 恢复默认颜色

        try {
            // 2. 调用我们新分离出来的 AI 请求函数
            const success = await fetchSnoopDataFromAI(contactId);

            if (success) {
                // 3. 成功反馈：更新时间戳，给用户提示
                const lastSyncTime = snoopDataCache[contactId].timestamp;
                timestampEl.textContent = `数据同步于 刚刚`;
                alert('数据同步成功！现在点击APP图标查看最新内容吧~');
            } else {
                 // 理论上 fetchSnoopDataFromAI 失败会抛出错误进入catch
                 // 但以防万一，还是加个失败提示
                 throw new Error("AI未能成功返回数据。");
            }

        } catch (error) {
            // 4. 失败反馈：显示错误信息
            console.error("手动刷新窥探数据失败:", error);
            timestampEl.textContent = '同步失败，请检查网络或API设置';
            timestampEl.style.color = 'var(--soft-red)'; // 用红色提示错误
            alert(`数据同步失败：${error.message}`);
        } finally {
            // 5. 无论成功失败，最后都要恢复按钮状态
            refreshBtn.disabled = false;
            refreshBtn.innerHTML = '<i class="fas fa-sync-alt"></i>'; // 恢复刷新图标
        }
    }
});

// ▲▲▲ 替换到这里结束 ▲▲▲
// ▼▼▼ 把这段新代码，粘贴到 attachEventListeners 函数里面 ▼▼▼

// --- 修改：监听“短信/窥探模式”列表的点击 ---
document.getElementById('sms-content-container').addEventListener('click', (e) => {
    const contactItem = e.target.closest('.contact-item');
    if (!contactItem) return;

    const contactId = contactItem.dataset.contactId;
    const currentTab = document.querySelector('#sms-tabs .feed-tab-btn.active')?.dataset.tab;

    if (currentTab === 'my-sms') {
        // ✨ 如果在“我的短信”页签下点击，就打开短信聊天界面 ✨
        openSmsChat(contactId);
    } else if (currentTab === 'snoop-mode') {
        // 如果在“窥探模式”页签下点击，就打开TA的手机桌面
        openSnoopedPhoneScreen(contactId);
    }
});

// 2. 监听“手机桌面”上所有APP图标的点击
document.getElementById('snooped-phone-screen').addEventListener('click', handleSnoopAppClick);

// 3. 监听从“手机桌面”返回的按钮
document.getElementById('back-from-snooped-phone').addEventListener('click', showSmsScreen);

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 把这段代码添加到 attachEventListeners 函数的末尾 ▼▼▼
document.getElementById('back-from-snooped-app').addEventListener('click', () => {
    // 从 "TA的手机" 屏幕上存储的 contactId 获取当前正在查看的角色ID
    const contactId = document.getElementById('snooped-phone-screen').dataset.currentContactId;
    if(contactId) {
        openSnoopedPhoneScreen(contactId); // 调用函数返回到 "TA的手机" 屏幕
    } else {
        showSmsScreen(); // 作为备选，如果找不到ID，就返回短信主列表
    }
});
// ▲▲▲ 添加结束 ▲▲▲
// ▼▼▼ 粘贴这段新代码到 attachEventListeners ▼▼▼

// "发现" -> "窥探API设置"
document.getElementById('snoop-api-settings-btn').addEventListener('click', showSnoopApiSettingsScreen);

// "窥探API设置" -> "发现" (返回)
document.getElementById('back-from-snoop-api').addEventListener('click', showDiscoverScreen);

// "窥探API设置" -> "拉取模型"
document.getElementById('fetch-snoop-models-btn').addEventListener('click', (e) => {
    const apiKey = document.getElementById('snoop-api-key-input').value;
    const endpoint = document.getElementById('snoop-api-endpoint-input').value.trim();
    fetchModels(endpoint, apiKey, document.getElementById('snoop-model-select'), e.currentTarget);
});

// "窥探API设置" -> "保存设置"
document.getElementById('save-snoop-api-settings-btn').addEventListener('click', async () => {
    state.snoopApiSettings.apiKey = document.getElementById('snoop-api-key-input').value;
    state.snoopApiSettings.endpoint = document.getElementById('snoop-api-endpoint-input').value.trim();
    state.snoopApiSettings.model = document.getElementById('snoop-model-select').value;

    await kokoMemory.put('snoopApiSettings', { id: 'main', ...state.snoopApiSettings });

    alert('窥探API设置已保存！');
    showDiscoverScreen();
});

// ▲▲▲ 粘贴结束 ▲▲▲
// --- V-新功能：日程与事件模块 ---

let editingScheduleId = null;
let editingEventId = null;

// 函数：显示日程表页面
function showScheduleScreen() {
    hideAllScreens();
    document.getElementById('schedule-screen').style.display = 'flex';
    renderSchedule();
}

// 函数：渲染日程表内容
function renderSchedule() {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    const container = document.getElementById('schedule-content-list');
    container.innerHTML = '';

    if (!contact || !contact.schedule || contact.schedule.length === 0) {
        container.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-calendar-alt" style="font-size: 48px; margin-bottom: 15px;"></i><p>还没有添加任何日程安排。</p><p>点击右上角“+”来添加第一条记录吧！</p></div>`;
        return;
    }

    const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
    const dayNames = { monday: '星期一', tuesday: '星期二', wednesday: '星期三', thursday: '星期四', friday: '星期五', saturday: '星期六', sunday: '星期日' };

    days.forEach(day => {
        const itemsForDay = contact.schedule.filter(item => item.dayOfWeek === day).sort((a,b) => a.startTime.localeCompare(b.startTime));
        if (itemsForDay.length > 0) {
            const daySection = document.createElement('div');
            daySection.className = 'discover-section';
            daySection.style.marginBottom = '15px';
            
            let itemsHTML = itemsForDay.map(item => `
                <div class="discover-item" data-schedule-id="${item.id}" style="cursor:pointer;">
                    <div class="discover-icon" style="background-color:#e3f2fd; color:#42a5f5;"><i class="fas fa-book-open"></i></div>
                    <div class="discover-info">
                        <div class="discover-name">${item.startTime} - ${item.endTime}：${item.courseName}</div>
                        <div class="discover-desc">${item.location || '地点未定'}</div>
                    </div>
                </div>
            `).join('');

            daySection.innerHTML = `<div class="section-title" style="font-weight:bold; color:var(--text-dark);">${dayNames[day]}</div>${itemsHTML}`;
            container.appendChild(daySection);
        }
    });
}

// 函数：显示重要日子页面
function showEventsScreen() {
    hideAllScreens();
    document.getElementById('events-screen').style.display = 'flex';
    renderEvents();
}
// 函数：渲染重要日子内容 (V3 - 周年纪念版)
function renderEvents() {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    const container = document.getElementById('events-content-list');
    container.innerHTML = '';
    
    // --- 保持卡片容器样式 ---
    container.className = 'diary-content';
    container.style.display = 'flex';
    container.style.flexDirection = 'column';
    container.style.padding = '15px';
    container.style.gap = '15px';

    if (!contact || !contact.events || !contact.events.length) {
        container.style.display = 'block'; // 恢复默认，让提示居中
        container.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-heart" style="font-size: 48px; margin-bottom: 15px;"></i><p>还没有添加任何重要的日子。</p><p>点击右上角“+”来添加吧！</p></div>`;
        return;
    }

    // --- 核心升级：全新的日期计算逻辑 ---
    const calculateDateInfo = (event) => {
        if (!event.date) return { days: '?', label: '日期无效', anniversaryText: '' };
        
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const eventDate = new Date(event.date); // 原始日期 (e.g., 1999-11-17)
        eventDate.setHours(0, 0, 0, 0);

        // 如果是“周年纪念日”类型
        if (event.type === 'anniversary') {
            const todayYear = today.getFullYear();
            const eventMonth = eventDate.getMonth();
            const eventDay = eventDate.getDate();

            // 计算今年的纪念日
            const thisYearsAnniversary = new Date(todayYear, eventMonth, eventDay);
            let totalYears = todayYear - eventDate.getFullYear();
            let diffDays = Math.ceil((thisYearsAnniversary.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));

            if (diffDays > 0) {
                // --- 还没到 ---
                return { days: diffDays, label: '天后', anniversaryText: `第 ${totalYears} 周年` };
            } else if (diffDays === 0) {
                // --- 就是今天 ---
                return { days: '今', label: '天', anniversaryText: `第 ${totalYears} 周年` };
            } else {
                // --- 今年已经过了，计算明年的 ---
                const nextYearsAnniversary = new Date(todayYear + 1, eventMonth, eventDay);
                diffDays = Math.ceil((nextYearsAnniversary.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
                return { days: diffDays, label: '天后', anniversaryText: `第 ${totalYears + 1} 周年` };
            }

        } else {
            // “生理期”或“其他”类型的旧逻辑（一次性倒数）
            const diffTime = eventDate.getTime() - today.getTime();
            const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));

            if (diffDays > 0) {
                return { days: diffDays, label: '天后', anniversaryText: '' };
            } else if (diffDays < 0) {
                return { days: Math.abs(diffDays), label: '天前', anniversaryText: '' };
            } else {
                return { days: '今', label: '天', anniversaryText: '' };
            }
        }
    };
    // --- 核心升级结束 ---

    const sortedEvents = [...contact.events].sort((a,b) => {
        if (a.isPinned && !b.isPinned) return -1;
        if (!a.isPinned && b.isPinned) return 1;
        const diffA = calculateDateInfo(a).days;
        const diffB = calculateDateInfo(b).days;
        // 让“今天”的排最前
        if (diffA === '今') return -1;
        if (diffB === '今') return 1;
        // 然后按天数升序
        return diffA - diffB;
    });
    
    sortedEvents.forEach(event => {
        const { days, label, anniversaryText } = calculateDateInfo(event); // 获取所有新信息
        const isActive = event.isPinned ? 'active' : '';

        // 格式化原始日期（e.g., "1999年11月17日"）
        const originalDateStr = new Date(event.date).toLocaleDateString('zh-CN', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });

        const card = document.createElement('div');
        card.className = 'event-card';
        card.dataset.type = event.type;
        card.dataset.eventId = event.id;

        card.innerHTML = `
            <div class="event-card-countdown">
                <div class="event-card-days">${days}</div>
                <div class="event-card-label">${label}</div>
            </div>
            <div class="event-card-info">
                <div class="event-card-name">${event.eventName}</div>
                <div class="event-card-date">
                    ${originalDateStr} ${anniversaryText ? `<span style="color: #c62828; font-weight: bold; margin-left: 8px;">(${anniversaryText})</span>` : ''}
                </div>
                <div class="event-card-notes">${event.notes || ''}</div>
            </div>
            <div class="event-card-actions">
                <button class="preset-action-btn pin-event-btn ${isActive}" data-event-id="${event.id}" title="在锁屏显示">
                    <i class="fas ${isActive ? 'fa-thumbtack' : 'fa-thumbtack'}"></i>
                </button>
                <button class="preset-action-btn delete delete-event-btn" data-event-id="${event.id}" title="删除">
                    <i class="fas fa-trash-alt"></i>
                </button>
            </div>
        `;
        container.appendChild(card);
    });
}
// 函数：打开日程编辑/添加弹窗
function openScheduleModal(scheduleItem = null) {
    const modal = document.getElementById('schedule-modal');
    const deleteBtn = document.getElementById('delete-schedule-item-btn'); // ✨ 1. 获取删除按钮
    
    if (scheduleItem) {
        // 编辑模式
        editingScheduleId = scheduleItem.id;
        document.getElementById('schedule-modal-title').textContent = '编辑日程';
        document.getElementById('schedule-item-id').value = scheduleItem.id;
        document.getElementById('schedule-name-input').value = scheduleItem.courseName;
        document.getElementById('schedule-day-select').value = scheduleItem.dayOfWeek;
        document.getElementById('schedule-start-input').value = scheduleItem.startTime;
        document.getElementById('schedule-end-input').value = scheduleItem.endTime;
        document.getElementById('schedule-location-input').value = scheduleItem.location;
        deleteBtn.style.display = 'block'; // ✨ 2. 显示删除按钮
    } else {
        // 添加模式
        editingScheduleId = null;
        document.getElementById('schedule-modal-title').textContent = '添加日程';
        document.getElementById('schedule-item-id').value = '';
        
        // ✨ (优化) 手动清空所有输入框
        document.getElementById('schedule-name-input').value = '';
        document.getElementById('schedule-day-select').value = 'monday';
        document.getElementById('schedule-start-input').value = '';
        document.getElementById('schedule-end-input').value = '';
        document.getElementById('schedule-location-input').value = '';

        deleteBtn.style.display = 'none'; // ✨ 3. 隐藏删除按钮
    }
    modal.style.display = 'flex';
}

// 函数：打开事件编辑/添加弹窗
function openEventModal(eventItem = null) {
    const modal = document.getElementById('event-modal');
    if (eventItem) {
        // 编辑模式
        editingEventId = eventItem.id;
        document.getElementById('event-modal-title').textContent = '编辑重要日子';
        document.getElementById('event-item-id').value = eventItem.id;
        document.getElementById('event-name-input').value = eventItem.eventName;
        document.getElementById('event-date-input').value = eventItem.date;
        document.getElementById('event-type-select').value = eventItem.type;
        document.getElementById('event-notes-input').value = eventItem.notes;
    } else {
        // 添加模式
        editingEventId = null;
        document.getElementById('event-modal-title').textContent = '添加重要日子';
        document.getElementById('event-item-id').value = '';
         document.querySelector('#event-modal form')?.reset();
    }
    modal.style.display = 'flex';
}

// ▲▲▲ 把上面所有新函数，完整地粘贴到你的JS代码区 ▲▲▲
// ==========================================================
// =========== ▼▼▼ 新增：图片处理核心函数 ▼▼▼ ============
// ==========================================================
/**
 * 处理用户上传的图片文件，进行压缩并转换为Base64
 * @param {File} file - 用户选择的图片文件
 * @returns {Promise<string>} - 返回一个Promise，解析为压缩后的Base64字符串
 */
function handleImageUpload(file) {
    return new Promise((resolve, reject) => {
        const MAX_DIMENSION = 1024; // 设定图片最大尺寸为1024像素
        const reader = new FileReader();

        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                let { width, height } = img;

                // 如果图片尺寸大于最大值，则进行等比缩放
                if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
                    if (width > height) {
                        height = Math.round((height * MAX_DIMENSION) / width);
                        width = MAX_DIMENSION;
                    } else {
                        width = Math.round((width * MAX_DIMENSION) / height);
                        height = MAX_DIMENSION;
                    }
                }

                // 使用 canvas 进行压缩
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                
                // 将压缩后的图片转换为Base64，这里使用JPEG格式并设置了压缩质量
                const compressedBase64 = canvas.toDataURL('image/jpeg', 0.8);
                resolve(compressedBase64);
            };
            img.onerror = reject;
            img.src = event.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });
}
// ▼▼▼ 把下面所有新函数，都粘贴到你的 JS 代码区 ▼▼▼

// 函数1：显示分组选择弹窗 (核心)
async function showGroupSelectorModal(contactId) {
    const modal = document.getElementById('group-selector-modal');
    const listEl = document.getElementById('group-selector-list');
    listEl.innerHTML = ''; // 清空旧列表

    const contact = await kokoMemory.get('contacts', contactId);
    const allGroups = await kokoMemory.getAll('contactGroups');

    // 1. 添加一个“未分组”的选项
    const ungroupedItem = document.createElement('div');
    ungroupedItem.className = 'contact-picker-item';
    ungroupedItem.innerHTML = `<label style="width: 100%; cursor: pointer;"><input type="radio" name="group-select" value="null" ${!contact.groupId ? 'checked' : ''}> 未分组</label>`;
    ungroupedItem.addEventListener('click', () => moveContactToGroup(contactId, null));
    listEl.appendChild(ungroupedItem);

    // 2. 渲染所有已创建的分组
    allGroups.forEach(group => {
        const groupItem = document.createElement('div');
        groupItem.className = 'contact-picker-item';
        groupItem.innerHTML = `<label style="width: 100%; cursor: pointer;"><input type="radio" name="group-select" value="${group.id}" ${contact.groupId === group.id ? 'checked' : ''}> ${group.name}</label>`;
        groupItem.addEventListener('click', () => moveContactToGroup(contactId, group.id));
        listEl.appendChild(groupItem);
    });

    // 3. 绑定弹窗上的按钮事件 (使用克隆节点防止重复绑定)
    const oldCreateBtn = document.getElementById('create-new-group-btn');
    const newCreateBtn = oldCreateBtn.cloneNode(true);
    oldCreateBtn.parentNode.replaceChild(newCreateBtn, oldCreateBtn);
    newCreateBtn.addEventListener('click', () => createNewGroup(contactId));

    // (管理分组功能我们稍后实现，先放个提示)
    const oldManageBtn = document.getElementById('manage-groups-btn');
    const newManageBtn = oldManageBtn.cloneNode(true);
    oldManageBtn.parentNode.replaceChild(newManageBtn, oldManageBtn);
    newManageBtn.addEventListener('click', () => alert('管理分组功能待开发...'));

    document.getElementById('close-group-selector-modal').onclick = () => modal.style.display = 'none';
    
    // 4. 显示弹窗
    modal.style.display = 'flex';
}

// ▼▼▼ 使用这个【修正版】替换掉你原来的 moveContactToGroup 函数 ▼▼▼
async function moveContactToGroup(contactId, groupId) {
    // 1. 从数据库获取最新的联系人数据
    const contact = await kokoMemory.get('contacts', contactId);
    
    if (contact) {
        // 2. 更新它的 groupId
        contact.groupId = (groupId === 'null' || groupId === null) ? null : groupId;
        
        // 3. 把更新后的数据存回数据库
        await kokoMemory.put('contacts', contact);

        // 4. 【核心修复】在这里同步更新内存中的 state 对象！
        const contactInState = state.contacts.find(c => c.id === contactId);
        if (contactInState) {
            contactInState.groupId = contact.groupId;
        }

        // 5. 现在用更新后的 state 重新渲染列表，界面就会立刻变化了
        await renderContacts();
    }
    
    // 6. 关闭弹窗
    document.getElementById('group-selector-modal').style.display = 'none';
}

// 函数3：创建新分组
async function createNewGroup(contactIdForRefresh) {
    const newGroupName = await showCustomPrompt('创建新分组', '请输入分组名称');
    if (newGroupName && newGroupName.trim()) {
        const newGroup = {
            id: 'group_' + Date.now(),
            name: newGroupName.trim()
        };
        await kokoMemory.put('contactGroups', newGroup);
        // 创建成功后，刷新分组选择弹窗，以显示新创建的分组
        showGroupSelectorModal(contactIdForRefresh);
    }
}

// ▲▲▲ 粘贴到这里结束 ▲▲▲
// --- 【全新】图片圆形裁剪器辅助函数 ---
function createCircularImage(imageUrl, size) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = size;
        canvas.height = size;

        const img = new Image();
        // 尝试解决跨域问题，不一定对所有外部图片生效，但对base64和大部分图床有效
        img.crossOrigin = 'Anonymous'; 
        
        img.onload = () => {
            // 1. 创建一个圆形的剪裁路径
            ctx.beginPath();
            ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.clip(); // 应用剪裁

            // 2. 智能计算图片绘制尺寸，实现 object-fit: cover 的效果，防止拉伸
            const aspect = img.width / img.height;
            let drawWidth, drawHeight, offsetX, offsetY;
            
            if (canvas.width / canvas.height > aspect) {
                drawWidth = canvas.width;
                drawHeight = canvas.width / aspect;
                offsetX = 0;
                offsetY = (canvas.height - drawHeight) / 2;
            } else {
                drawHeight = canvas.height;
                drawWidth = canvas.height * aspect;
                offsetX = (canvas.width - drawWidth) / 2;
                offsetY = 0;
            }
            
            // 3. 将图片绘制到被剪裁的画布上
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);

            // 4. 将画布内容导出为新的 base64 图片 URL
            resolve(canvas.toDataURL('image/png'));
        };
        
        img.onerror = () => {
            // 如果图片加载失败，直接返回原始URL，避免整个图表崩溃
            console.warn(`图片加载失败，无法裁剪: ${imageUrl}`);
            resolve(imageUrl); // 降级处理
        };

        img.src = imageUrl;
    });
}
// --- 【全新】关系网络功能模块 V2.0 ---

let editingCharacterId = null; // 用于跟踪正在编辑的角色
let pendingNpcAvatarBase64 = null;

// 函数1：显示关系网页面 (不变)
async function showRelationshipScreen(contactId) {
    hideAllScreens();
    const screen = document.getElementById('relationship-network-screen');
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) return;

    document.getElementById('relationship-network-title').textContent = `${contact.name} 的关系网`;
    screen.style.display = 'flex';
    screen.dataset.currentContactId = contactId;

    await renderRelationshipNetwork(contactId);
    await renderRelationshipGraph(contactId); 
}
/**
 * (新) 辅助函数：将点击的关系填充到编辑器中
 */
function populateRelationshipEditor(dataset) {
    const { sourceId, targetId, relationship, detail } = dataset;

    // 1. 填充简单的字段
    document.getElementById('relation-source-select').value = sourceId;
    document.getElementById('relation-target-select').value = targetId;
    document.getElementById('relation-detail-input').value = detail;

    // 2. 智能填充“关系类型”下拉菜单
    const typeSelect = document.getElementById('relation-type-select');
    let optionExists = false;
    // 检查这个关系是不是一个“标准选项”
    for (let i = 0; i < typeSelect.options.length; i++) {
        if (typeSelect.options[i].value === relationship) {
            optionExists = true;
            break;
        }
    }

    if (optionExists) {
        // 选项存在 (例如 "朋友", "恋人"), 直接选中它
        typeSelect.value = relationship;
    } else {
        // 选项不存在 (是"自定义"的, 比如 "师徒")
        // 我们动态创建这个选项
        const newOption = new Option(relationship, relationship, true, true);
        // 插入到“自定义”选项的前面
        typeSelect.insertBefore(newOption, typeSelect.options[typeSelect.options.length - 1]);
    }
}
// (新 V3) 函数2：渲染整个关系网编辑界面 (支持点击编辑)
async function renderRelationshipNetwork(contactId) {
    const contact = state.contacts.find(c => c.id === contactId);
    let networkData = await kokoMemory.get('relationshipNetworks', contactId);

    // （这部分检查逻辑不变）
    if (!networkData || !networkData.nodes) {
        networkData = { contactId: contactId, nodes: [], edges: networkData ? networkData.edges : [] };
        
        networkData.nodes.push({ id: contact.id, name: contact.name, avatar: contact.avatar, isContact: true });
        networkData.nodes.push({ id: 'myProfile', name: state.myProfile.name + ' (你)', avatar: state.myProfile.avatar, isContact: true });
        
        if(networkData.edges){
            networkData.edges.forEach(edge => {
                if(edge.target !== 'myProfile' && !networkData.nodes.some(n => n.id === edge.target)){
                    const targetContact = state.contacts.find(c => c.id === edge.target);
                    if(targetContact) {
                        networkData.nodes.push({ id: targetContact.id, name: targetContact.name, avatar: targetContact.avatar, isContact: true });
                    }
                }
            });
        }
        await kokoMemory.put('relationshipNetworks', networkData);
    }
    
    // (这部分“角色名册”渲染逻辑不变)
    const charListEl = document.getElementById('character-list');
    charListEl.innerHTML = '';
    networkData.nodes.forEach(node => {
        let currentNodeName = node.name;
        let currentNodeAvatar = node.avatar;
        if (node.id === contactId) {
            currentNodeName = contact.name;
            currentNodeAvatar = contact.avatar;
        } else if (node.id === 'myProfile') {
            currentNodeName = (contact.customUserName || state.myProfile.name) + ' (你)';
            currentNodeAvatar = contact.customUserAvatar || state.myProfile.avatar;
        } else if (node.isContact) {
            const contactProfile = state.contacts.find(c => c.id === node.id);
            if(contactProfile) {
                currentNodeName = contactProfile.name;
                currentNodeAvatar = contactProfile.avatar;
            }
        }
        const item = document.createElement('div');
        item.className = 'preset-item';
        const isCoreMember = node.id === contactId || node.id === 'myProfile';
        const actionsHTML = isCoreMember ? '' : `
            <div class="preset-actions">
                <span class="preset-action-btn edit-character-btn" data-char-id="${node.id}" title="编辑角色"><i class="fas fa-edit"></i></span>
                <span class="preset-action-btn delete delete-character-btn" data-char-id="${node.id}" title="删除角色"><i class="fas fa-trash-alt"></i></span>
            </div>
        `;
        item.innerHTML = `
            <div class="preset-info" style="display: flex; align-items: center;">
                <img src="${currentNodeAvatar || 'https://via.placeholder.com/40'}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 15px;">
                <div class="preset-name">${currentNodeName} ${node.isContact ? '' : '(NPC)'}</div>
            </div>
            ${actionsHTML}
        `;
        charListEl.appendChild(item);
    });

    // (这部分“下拉菜单”渲染逻辑不变)
    const sourceSelect = document.getElementById('relation-source-select');
    const targetSelect = document.getElementById('relation-target-select');
    sourceSelect.innerHTML = '';
    targetSelect.innerHTML = '';
    networkData.nodes.forEach(node => {
        const option1 = new Option(node.name, node.id);
        const option2 = new Option(node.name, node.id);
        sourceSelect.appendChild(option1);
        targetSelect.appendChild(option2);
    });
    
    // (新) 渲染已有关系列表
    const listEl = document.getElementById('relationship-list');
    listEl.innerHTML = '';
    if (!networkData.edges || networkData.edges.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: #888;">还没有任何关系，快添加一个吧！</p>';
    } else {
        networkData.edges.forEach(edge => {
            const sourceNode = networkData.nodes.find(n => n.id === edge.source);
            const targetNode = networkData.nodes.find(n => n.id === edge.target);
            if (!sourceNode || !targetNode) return; 

            const item = document.createElement('div');
            item.className = 'preset-item';

            // ▼▼▼ 核心修改在这里 ▼▼▼
            // 我们把所有需要的数据都塞进 .preset-info 的 data- 属性里
            item.innerHTML = `
                <div class="preset-info" 
                     data-source-id="${edge.source}" 
                     data-target-id="${edge.target}" 
                     data-relationship="${edge.relationship}" 
                     data-detail="${edge.detail || ''}"
                     style="cursor: pointer;" title="点击编辑">
                    
                    <div class="preset-name">${sourceNode.name} → ${targetNode.name}: 【${edge.relationship}】</div>
                    <div class="preset-desc">${edge.detail || '暂无细节描述'}</div>
                </div>
                <div class="preset-actions">
                    <span class="preset-action-btn delete delete-relationship-btn" data-source-id="${edge.source}" data-target-id="${edge.target}" title="删除此关系">
                        <i class="fas fa-trash-alt"></i>
                    </span>
                </div>
            `;
            // ▲▲▲ 修改结束 ▲▲▲

            listEl.appendChild(item);
        });
    }
}

// 函数3：保存/更新一条关系 (V2.1 简化版)
async function saveRelationship() {
    const screen = document.getElementById('relationship-network-screen');
    const contactId = screen.dataset.currentContactId;
    if (!contactId) return;

    const sourceId = document.getElementById('relation-source-select').value;
    const targetId = document.getElementById('relation-target-select').value;
    // ▼▼▼ 核心修改：直接读取最终值，不再处理弹窗 ▼▼▼
    const relationshipType = document.getElementById('relation-type-select').value;
    const detail = document.getElementById('relation-detail-input').value.trim();

    if(sourceId === targetId) return alert('不能和自己建立关系！');
    // 如果关系类型还是“自定义”，说明用户没输入，就阻止保存
    if (relationshipType === '自定义') {
        return alert('请先在弹出的输入框中指定一个自定义关系类型！');
    }

    const networkData = await kokoMemory.get('relationshipNetworks', contactId);
    const existingEdgeIndex = networkData.edges.findIndex(e => e.source === sourceId && e.target === targetId);

    if (existingEdgeIndex > -1) {
        networkData.edges[existingEdgeIndex].relationship = relationshipType;
        networkData.edges[existingEdgeIndex].detail = detail;
    } else {
        networkData.edges.push({ source: sourceId, target: targetId, relationship: relationshipType, detail: detail });
    }

    await kokoMemory.put('relationshipNetworks', networkData);

    document.getElementById('relation-detail-input').value = '';
    await renderRelationshipNetwork(contactId);
    await renderRelationshipGraph(contactId);
}

// 函数4：删除一条关系 (V2.0 大改版)
async function deleteRelationship(sourceId, targetId) {
    const screen = document.getElementById('relationship-network-screen');
    const contactId = screen.dataset.currentContactId;
    if (!contactId) return;

    const confirmed = await showCustomConfirm('删除关系', '确定要删除这条关系吗？', true);
    if (confirmed) {
        const networkData = await kokoMemory.get('relationshipNetworks', contactId);
        if (networkData && networkData.edges) {
            networkData.edges = networkData.edges.filter(e => !(e.source === sourceId && e.target === targetId));
            await kokoMemory.put('relationshipNetworks', networkData);
            await renderRelationshipNetwork(contactId);
            await renderRelationshipGraph(contactId); // 刷新图表
        }
    }
}

// (新 V3) 函数5：打开角色编辑/添加弹窗 (支持人设)
function openCharacterModal(character = null) {
    const modal = document.getElementById('character-modal');
    const preview = document.getElementById('character-avatar-preview');
    // (新) 获取人设输入框
    const personaInput = document.getElementById('character-persona-input');

    if (character) {
        // 编辑模式
        editingCharacterId = character.id;
        document.getElementById('character-modal-title').textContent = '编辑角色';
        document.getElementById('character-id-input').value = character.id;
        document.getElementById('character-name-input').value = character.name;
        personaInput.value = character.persona || ''; // (新) 加载人设
        
        if (character.avatar) {
            preview.src = character.avatar;
            preview.style.display = 'block';
        } else {
            preview.style.display = 'none';
        }
    } else {
        // 添加模式 (NPC)
        editingCharacterId = null;
        document.getElementById('character-modal-title').textContent = '添加新角色 (NPC)';
        document.getElementById('character-id-input').value = '';
        document.getElementById('character-name-input').value = '';
        personaInput.value = ''; // (新) 清空人设
        
        preview.src = '';
        preview.style.display = 'none';
    }
    modal.style.display = 'flex';
}

// (新 V3) 函数6：保存一个角色 (NPC) (支持人设)
async function saveCharacter() {
    const screen = document.getElementById('relationship-network-screen');
    const contactId = screen.dataset.currentContactId;
    if (!contactId) return;

    const name = document.getElementById('character-name-input').value.trim();
    // (新) 获取人设
    const persona = document.getElementById('character-persona-input').value.trim();
    
    if (!name || !persona) { // (新) 检查人设是否为空
        alert('请输入角色姓名和人设！');
        return;
    }

    const avatar = document.getElementById('character-avatar-preview').src;
    const networkData = await kokoMemory.get('relationshipNetworks', contactId);

    if (editingCharacterId) {
        // 编辑
        const char = networkData.nodes.find(n => n.id === editingCharacterId);
        if (char) {
            char.name = name;
            char.avatar = avatar; 
            char.persona = persona; // (新) 保存人设
        }
    } else {
        // 新增NPC
        networkData.nodes.push({
            id: 'npc_' + Date.now(),
            name: name,
            avatar: avatar, 
            isContact: false,
            persona: persona // (新) 保存人设
        });
    }

    await kokoMemory.put('relationshipNetworks', networkData);
    document.getElementById('character-modal').style.display = 'none';
    await renderRelationshipNetwork(contactId);
    await renderRelationshipGraph(contactId);
}

// 函数7：删除一个角色 (NPC)
async function deleteCharacter(charId) {
    const screen = document.getElementById('relationship-network-screen');
    const contactId = screen.dataset.currentContactId;
    if (!contactId) return;

    const confirmed = await showCustomConfirm('删除角色', '确定要删除这个角色吗？\n所有与他/她相关的关系线也将被一并删除！', true);
    if (confirmed) {
        const networkData = await kokoMemory.get('relationshipNetworks', contactId);
        // 删除节点
        networkData.nodes = networkData.nodes.filter(n => n.id !== charId);
        // 删除所有与该节点相关的边
        networkData.edges = networkData.edges.filter(e => e.source !== charId && e.target !== charId);
        await kokoMemory.put('relationshipNetworks', networkData);
        await renderRelationshipNetwork(contactId);
        await renderRelationshipGraph(contactId); // 刷新图表
    }
}

// --- 【全新】V7.0 关系网络图表渲染函数 (Canvas终极兼容版) ---
async function renderRelationshipGraph(contactId) {
    const graphContainer = document.getElementById('relationship-graph-container');
    if (!graphContainer) return;
    const myChart = echarts.init(graphContainer);

    // 这就是关键：我们拿到了当前这个聊天的联系人对象
    const contact = state.contacts.find(c => c.id === contactId); 
    const networkData = await kokoMemory.get('relationshipNetworks', contactId);
    
    if(!networkData || !networkData.nodes || !networkData.nodes.length === 0) {
        myChart.clear(); 
        return;
    }

    // 1. 【核心修正】我们不再从头构建节点...
    const nodeInfos = networkData.nodes.map(node => {
        const isCenter = node.id === contactId;
        
        let finalName = node.name;
        let finalAvatar = node.avatar;

        if (node.id === contactId) {
            // 刷新关系网的主人公 (这部分不变)
            finalName = contact.name;
            finalAvatar = contact.avatar;
        
        } else if (node.id === 'myProfile') {
            // ▼▼▼ ✨ 这就是你想要的修复！✨ ▼▼▼
            // 刷新“你”（用户）
            // 优先使用当前 contact(TA) 里设置的马甲，如果没设置，再用全局 profile
            finalName = contact.customUserName || state.myProfile.name;
            finalName += ' (你)'; // 确保 "(你)" 标签还在
            finalAvatar = contact.customUserAvatar || state.myProfile.avatar;
            // ▲▲▲ ✨ 修复结束 ✨ ▲▲▲
            
        } else if (node.isContact) {
            // (刷新其他联系人的代码，这部分不变)
            const contactProfile = state.contacts.find(c => c.id === node.id);
            if(contactProfile) {
                finalName = contactProfile.name;
                finalAvatar = contactProfile.avatar;
            }
        }
        
        return {
            id: node.id,
            name: finalName, // <-- 现在用的是修复后的名字
            avatar: finalAvatar || `https://via.placeholder.com/${isCenter ? 60 : 45}/DDD/666?text=${finalName.substring(0,1)}`, // <-- 现在用的是修复后的头像
            size: isCenter ? 60 : 45
        }
    });

    // 2. 并行处理所有节点的图片 (这部分不变)
    const imagePromises = nodeInfos.map(node => createCircularImage(node.avatar, node.size));
    const circularImageUrls = await Promise.all(imagePromises);

    // 3. 用裁剪好的图片数据，构建ECharts节点 (这部分不变)
    const nodesForGraph = nodeInfos.map((node, index) => ({
        id: node.id,
        name: node.name, // 这里会自动用上我们刚刚修复好的 finalName
        symbolSize: node.size,
        symbol: 'image://' + circularImageUrls[index], // 这里会自动用上修复好的头像
        label: {
            show: true,
            position: 'bottom',
            color: '#333',
            fontWeight: 'bold'
        },
        itemStyle: {
            borderWidth: 2,
            borderColor: '#fff',
            shadowBlur: 6,
            shadowColor: 'rgba(0, 0, 0, 0.4)'
        }
    }));

    // 4. 配置图表 (不变)
    const option = {
        tooltip: {},
        series: [{
            type: 'graph',
            layout: 'force',
            roam: true,
            force: { repulsion: 250, edgeLength: 150, gravity: 0.05 },
            data: nodesForGraph, //把更新后的节点数据喂给图表
            links: networkData.edges ? networkData.edges.map(edge => ({
                source: edge.source,
                target: edge.target,
                label: { show: true, formatter: edge.relationship },
                tooltip: { formatter: edge.detail }
            })) : [],
            lineStyle: { opacity: 0.9, width: 2, curveness: 0.1 }
        }]
    };

    // 5. 应用配置 (不变)
    myChart.setOption(option);
    window.addEventListener('resize', () => { myChart.resize(); });
}
// --- 【全新】打开“添加角色到名册”的选择模态框 ---
async function openAddToRosterModal() {
    const modal = document.getElementById('add-to-roster-modal');
    const selectEl = document.getElementById('import-contact-select');
    selectEl.innerHTML = '';

    const contactId = document.getElementById('relationship-network-screen').dataset.currentContactId;
    const networkData = await kokoMemory.get('relationshipNetworks', contactId);

    // 1. 找出所有已经存在于名册中的角色ID
    const existingNodeIds = networkData.nodes.map(node => node.id);

    // 2. 筛选出那些还没有被加进名册的“联系人”
    const importableContacts = state.contacts.filter(contact => 
        !contact.isGroup && // 排除群聊
        !existingNodeIds.includes(contact.id) // 排除已在名册中的
    );

    // 3. 填充下拉菜单
    if (importableContacts.length > 0) {
        importableContacts.forEach(contact => {
            const option = new Option(contact.name, contact.id);
            selectEl.appendChild(option);
        });
        document.getElementById('confirm-import-contact-btn').style.display = 'block';
    } else {
        const option = new Option('没有其他可导入的联系人了', '');
        option.disabled = true;
        selectEl.appendChild(option);
        document.getElementById('confirm-import-contact-btn').style.display = 'none';
    }

    modal.style.display = 'flex';
}
// ==========================================================
// =========== ▼▼▼ 聊天记录搜索核心功能 ▼▼▼ =================
// ==========================================================

// 1. 显示/隐藏搜索界面的函数
function showChatSearch() {
    const overlay = document.getElementById('chat-search-overlay');
    const input = document.getElementById('chat-search-input');
    // 清空上次的搜索
    input.value = '';
    document.getElementById('search-results-container').innerHTML = '<div class="search-placeholder">输入关键词搜索</div>';
    document.getElementById('clear-search-btn').style.display = 'none';
    
    overlay.style.display = 'flex';
    // 自动聚焦输入框，提升体验
    setTimeout(() => input.focus(), 100);
}
window.showChatSearch = showChatSearch; // 👈 把这个函数“导出”到全局
function hideChatSearch() {
    document.getElementById('chat-search-overlay').style.display = 'none';
}
window.hideChatSearch = hideChatSearch; // 👈 顺便把关闭函数也导出了
// 2. 执行搜索的核心函数
function performChatSearch(keyword) {
    const container = document.getElementById('search-results-container');
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact || !keyword.trim()) {
        container.innerHTML = '<div class="search-placeholder">输入关键词搜索</div>';
        return;
    }

    const trimmedKeyword = keyword.trim().toLowerCase();
    const results = [];

    // 根据当前模式决定搜索哪个历史记录
    const historySource = (state.currentChatMode === 'sms') ? (contact.smsHistory || []) : (contact.history || []);

    // 遍历历史记录查找匹配项
    historySource.forEach(msg => {
        // 目前只支持搜索文本消息 (text) 和语音转文字 (voice)
        let contentToSearch = '';
        if (msg.type === 'text') {
            contentToSearch = msg.content;
        } else if (msg.type === 'voice' && msg.content.text) {
            contentToSearch = msg.content.text;
        }

        if (contentToSearch && contentToSearch.toLowerCase().includes(trimmedKeyword)) {
            results.push({
                msg: msg,
                // 获取发送者名字
                senderName: msg.sender === 'user' ? state.myProfile.name : (contact.isGroup ? (state.contacts.find(c=>c.id===msg.sender)?.name || '未知成员') : contact.name),
                // 保存用于显示的原始内容
                originalContent: contentToSearch 
            });
        }
    });

    // 渲染结果
    if (results.length === 0) {
        container.innerHTML = '<div class="search-placeholder">没有找到相关记录</div>';
    } else {
        container.innerHTML = ''; // 清空占位符
        // 按时间倒序排列，最新的在最上面 (符合大多数人的搜索习惯)
        results.reverse().forEach(result => {
            const item = document.createElement('div');
            item.className = 'search-result-item';
            // 核心：把消息ID存到 dataset 里，用于跳转
            item.dataset.messageId = result.msg.id;

            // 高亮关键词
            const highlightedContent = highlightKeyword(result.originalContent, keyword);

            item.innerHTML = `
                <div class="result-header">
                    <span class="result-sender">${result.senderName}</span>
                    <span class="result-time">${new Date(result.msg.timestamp).toLocaleString()}</span>
                </div>
                <div class="result-content">${highlightedContent}</div>
            `;

            // 绑定点击跳转事件
            item.addEventListener('click', () => {
                jumpToMessageAndHighlight(result.msg.id);
            });

            container.appendChild(item);
        });
    }
}

// 辅助函数：高亮关键词
function highlightKeyword(text, keyword) {
    // 使用正则表达式进行全局、不区分大小写的替换
    const regex = new RegExp(`(${keyword})`, 'gi');
    // 将匹配到的关键词用带颜色的 span 包裹
    return text.replace(regex, '<span class="highlight-keyword">$1</span>');
}

// 3. [核心] 跳转并高亮消息的函数
async function jumpToMessageAndHighlight(messageId) {
    hideChatSearch(); // 先关闭搜索界面

    const messagesContainer = document.getElementById(state.currentChatMode === 'sms' ? 'sms-chat-messages' : 'chat-messages');
    
    // 1. 尝试在当前 DOM 中查找该消息
    let targetMsgEl = messagesContainer.querySelector(`[data-message-id="${messageId}"]`);

    // 2. 如果没找到（可能因为分页还在很上面的位置），就需要重新渲染所有消息
    if (!targetMsgEl) {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (contact) {
            // 显示加载提示（可选，如果记录特别多的话）
            // showFeedStatus('正在定位消息...'); 
            
            if (state.currentChatMode === 'sms') {
                 // 短信目前是一次性渲染的，如果没找到可能是bug，但我们还是重绘一次以防万一
                 await renderSmsChatMessages(contact);
            } else {
                 // 主聊天：强制加载所有消息
                 renderChatMessages(contact, true); // 传入 true 表示加载全部
            }

            // 等待 DOM 更新完成
            await sleep(100); // 稍微等一下渲染
            
            // 再次尝试查找
            targetMsgEl = messagesContainer.querySelector(`[data-message-id="${messageId}"]`);
        }
    }

    // 3. 如果找到了，就滚动过去并高亮
    if (targetMsgEl) {
        // 滚动到该消息，使其位于视图中间
        targetMsgEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // 添加高亮样式
        targetMsgEl.classList.add('highlighted');
        
        // 1.5秒后自动移除高亮
        setTimeout(() => {
            targetMsgEl.classList.remove('highlighted');
        }, 2000);
    } else {
        alert('定位消息失败，可能该消息已被删除。');
    }
}
// ==========================================================
// =========== ▲▲▲ 搜索功能结束 ▲▲▲ =========================
// --- ✨ 新增：导出主题功能 (V2 - 自定义命名版) ✨ ---
async function exportTheme() {
    try {
        // 1. 定义哪些数据属于“主题”
        const themeKeys = [
            'chatBackground', 'customBubbleCss', 'customThemeCss', 
            'customNarrativeCss', 'customFontSize', 'customFontUrl', 'customFontName'
        ];

        // 2. 打包数据
        const themeData = {};
        themeKeys.forEach(key => {
            themeData[key] = userSettings[key];
        });
        themeData._info = {
            type: 'koko_theme_pack',
            version: 1,
            exported_at: Date.now()
        };

        // 3. ✨ 核心新增：弹窗询问文件名 ✨
        // 生成一个默认名字，比如 "koko_theme_2023-11-07"
        const defaultName = `koko_theme_${new Date().toLocaleDateString('zh-CN').replace(/\//g, '-')}`;
        let fileName = await showCustomPrompt('给主题起个名字', defaultName);

        // 如果用户点了取消，就终止导出
        if (fileName === null) return;

        // 如果用户没输入内容直接点了确定，就用默认名字
        fileName = fileName.trim() || defaultName;

        // 确保文件名以 .json 结尾
        if (!fileName.toLowerCase().endsWith('.json')) {
            fileName += '.json';
        }

        // 4. 生成并下载文件
        const jsonString = JSON.stringify(themeData, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName; // <--- 使用你起的新名字！
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        alert(`主题包“${fileName}”已成功导出！`);

    } catch (error) {
        console.error('导出主题失败:', error);
        alert('导出失败，请重试。');
    }
}

// --- ✨ 新增：导入主题功能 ✨ ---
function importTheme(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const themeData = JSON.parse(e.target.result);

            // 简单的验证：看看它是不是咱们 Koko 的主题包
            if (themeData._info && themeData._info.type !== 'koko_theme_pack') {
                if (!confirm('警告：这个文件看起来不像标准的 Koko 主题包。确定要继续导入吗？')) {
                    event.target.value = ''; // 清空选择
                    return;
                }
            }

            // 1. 定义允许导入的字段（白名单机制，防止导入不安全的数据）
            const allowedKeys = [
                'chatBackground', 'customBubbleCss', 'customThemeCss', 
                'customNarrativeCss', 'customFontSize', 'customFontUrl', 'customFontName'
            ];

            // 2. 覆盖当前的设置
            let importCount = 0;
            allowedKeys.forEach(key => {
                if (themeData.hasOwnProperty(key)) {
                    userSettings[key] = themeData[key];
                    importCount++;
                }
            });

            // 3. 保存到数据库
            await kokoMemory.put('userSettings', userSettings);

            // 4. 立即应用新主题！
            applyAppearanceSettings();

            // 5. 极其重要：更新页面上的输入框，让它们显示新的值
            document.getElementById('bubble-css-input').value = userSettings.customBubbleCss || '';
            document.getElementById('theme-css-input').value = userSettings.customThemeCss || '';
            document.getElementById('narrative-css-input').value = userSettings.customNarrativeCss || '';
            document.getElementById('font-size-input').value = userSettings.customFontSize || '';
            document.getElementById('font-url-input').value = userSettings.customFontUrl || '';
            document.getElementById('font-name-input').value = userSettings.customFontName || '';
            // 更新预览框
            setTimeout(loadPreviewFromInputs, 50);

            alert(`成功导入了主题！(更新了 ${importCount} 项设置)`);

        } catch (error) {
            console.error('导入主题失败:', error);
            alert('导入失败：文件格式错误。');
        } finally {
            event.target.value = ''; // 清空文件选择控件，确保下次能选同一个文件
        }
    };
    reader.readAsText(file);
}
// ==========================================================
// =========================================
// 🎵 全新音乐搜索核心模块 (内置代理版) 🎵
// =========================================

// 你提供的固定代理地址
const BUILTIN_MUSIC_API = 'https://kokomusic.netlify.app/api';

// 1. 核心搜索函数
async function searchMusicInModal(keyword) {
    // ✨ 核心改动：直接使用内置地址，不再从设置里读取
    const apiBase = BUILTIN_MUSIC_API;
    
    const resultsContainer = document.getElementById('music-search-results-modal');
    resultsContainer.innerHTML = '<p style="text-align: center; color: #666;"><i class="fas fa-spinner fa-spin"></i> 正在搜索...</p>';

    try {
        // 使用 V3 代理的搜索方式
        const response = await fetch(`${apiBase}?word=${encodeURIComponent(keyword)}`);
        const resData = await response.json();

        if (resData.code !== 200 || !Array.isArray(resData.data) || resData.data.length === 0) {
            resultsContainer.innerHTML = '<p style="text-align: center; color: #999;">未找到相关歌曲，换个关键词试试？</p>';
            return;
        }

        // 渲染结果列表
        let html = '<div class="preset-list" style="gap: 5px; box-shadow: none; border: none; background: transparent; padding: 0;">';
        resData.data.forEach(song => {
            html += `
                <div class="preset-item music-search-result-item" data-song-id="${song.id}" style="padding: 8px; cursor: pointer; align-items: center; border: 1px solid #eee;">
                    <img src="${song.cover}" style="width: 36px; height: 36px; border-radius: 4px; margin-right: 10px;">
                    <div class="preset-info" style="overflow: hidden;">
                        <div class="preset-name" style="font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${song.song}</div>
                        <div class="preset-desc" style="font-size: 12px; color: #999; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${song.singer}</div>
                    </div>
                    <i class="fas fa-cloud-download-alt" style="color: var(--theme-accent, #007AFF); opacity: 0.7;"></i>
                </div>
            `;
        });
        html += '</div>';
        resultsContainer.innerHTML = html;

        // 绑定点击事件
        resultsContainer.querySelectorAll('.music-search-result-item').forEach(item => {
            item.addEventListener('click', () => fetchMusicDetailsForModal(item.dataset.songId));
        });

    } catch (error) {
        console.error("搜索出错:", error);
        resultsContainer.innerHTML = `<p style="text-align: center; color: var(--soft-red);">搜索出错: ${error.message}</p>`;
    }
}

// 2. 核心详情获取 & 自动填充函数
async function fetchMusicDetailsForModal(songId) {
    // ✨ 核心改动：直接使用内置地址
    const apiBase = BUILTIN_MUSIC_API;
    
    const resultsContainer = document.getElementById('music-search-results-modal');
    const originalContent = resultsContainer.innerHTML; // 备份列表，失败时恢复
    resultsContainer.innerHTML = '<p style="text-align: center; color: #666;"><i class="fas fa-spinner fa-spin"></i> 正在获取链接和歌词...</p>';

    try {
        // 并行请求详情(vkeys)和歌词(网易云)
        // 注意：这里使用了 V4 测试版里的“暗号”逻辑
        const detailUrl = `${apiBase}?id=${songId}`;
        // 我们的代理支持用 ?type=lyric 来区分请求
        const lyricUrl = `${apiBase}?type=lyric&id=${songId}&lv=1&kv=1&tv=-1`;

        const [detailRes, lyricRes] = await Promise.all([
            fetch(detailUrl),
            fetch(lyricUrl)
        ]);

        const detailData = await detailRes.json();
        // 歌词API有时候返回 text 有时候返回 json，这里做个容错处理
        let lyricData = {};
        try { lyricData = await lyricRes.json(); } catch (e) { console.warn("歌词非JSON格式"); }

        if (detailData.code !== 200 || !detailData.data || !detailData.data.url) {
            throw new Error("无法获取播放链接 (可能是VIP歌曲)");
        }

        // 提取歌词
        let lyricText = "";
        if (lyricData.lrc && lyricData.lrc.lyric) {
            lyricText = lyricData.lrc.lyric;
        }

        // 🎉 自动填充到下方的输入框！
        const song = detailData.data;
        document.getElementById('send-music-title-input').value = song.song;
        document.getElementById('send-music-artist-input').value = song.singer;
        document.getElementById('send-music-url-input').value = song.url;
        document.getElementById('send-music-lrc-input').value = lyricText; // 填充隐藏的歌词框
        document.getElementById('send-music-cover-input').value = song.cover || '';

        // 恢复列表显示，并给个小提示
        resultsContainer.innerHTML = originalContent;
        alert(`已自动填充：《${song.song}》\n点击下方的“确认分享”即可发送！`);

    } catch (error) {
        alert(`获取失败: ${error.message}`);
        resultsContainer.innerHTML = originalContent; // 恢复列表
    }
}
// ==========================================================
// =========== ▼▼▼ 股票 + 彩票 核心功能函数 ▼▼▼ ============
// ==========================================================
// ==========================================================
// =================== 海龟汤 游戏核心逻辑 (V5-关系网集成版) ===========
// ==========================================================

// --- 游戏全局变量 ---
let GAME_AI_TEAMMATES = []; // { name: "Koko", persona: "..." }
let GAME_SECRET_SOUP_BOTTOM = ""; 
let GAME_HOST_PERSONA_PROMPT = ""; // 存储GM的人设
let GAME_USER_PERSONA_PROMPT = ""; // 存储玩家的人设
let GAME_LAST_KEYWORDS = ""; // 存储上次的关键词
const GAME_HOST_NAME = "主持人";
let gameMessages = []; // 游戏历史
let tempAllNpcList = []; // (新) 临时存储从关系网读出的NPC

// --- 游戏DOM引用 ---
let gameChatScreen, gamePuzzleTextEl, gameChatLog, gameChatLogWrapper, 
    gameUserInput, gameAskHostBtn, gameDiscussBtn, gameSurrenderBtn, 
    gamePlayAgainBtn, gameInputArea, gameExitBtn;
let gameGmPersonaInput, gameCustomNpcsInput, gameKeywordsInput, gameUserPersonaSelect;

/**
 * 启动游戏时，集中获取一次所有DOM元素
 */
function cacheGameDOMElements() {
    gameChatScreen = document.getElementById('game-chat-screen');
    gamePuzzleTextEl = document.getElementById('game-puzzle-text');
    gameChatLog = document.getElementById('game-chat-log');
    gameChatLogWrapper = document.getElementById('game-chat-log-wrapper');
    gameUserInput = document.getElementById('game-user-input');
    gameAskHostBtn = document.getElementById('game-ask-host-btn');
    gameDiscussBtn = document.getElementById('game-discuss-btn');
    gameSurrenderBtn = document.getElementById('game-surrender-btn');
    gamePlayAgainBtn = document.getElementById('game-play-again-btn');
    gameInputArea = document.getElementById('game-input-area');
    gameExitBtn = document.getElementById('game-exit-btn');
    
    // 弹窗的引用
    gameGmPersonaInput = document.getElementById('game-gm-persona-input');
    gameCustomNpcsInput = document.getElementById('game-custom-npcs-input');
    gameKeywordsInput = document.getElementById('soup-keywords-input');
    gameUserPersonaSelect = document.getElementById('game-user-persona-select');
}

/**
 * (新) 显示“AI 正在思考中”的提示
 */
function showGameLoadingIndicator() {
    removeGameLoadingIndicator(); 
    const indicatorHTML = `
        <div class="message-wrapper ai-player" id="game-typing-indicator">
            <div class="sender-name" style="color: #8e8e93;">AI 正在思考...</div>
            <div class="message" style="background-color: #2c2c2e; font-size: 18px;">
                <i class="fas fa-spinner fa-spin"></i>
            </div>
        </div>
    `;
    gameChatLog.insertAdjacentHTML('beforeend', indicatorHTML);
    gameChatLogWrapper.scrollTop = gameChatLogWrapper.scrollHeight;
}

/**
 * (新) 移除“AI 正在思考中”的提示
 */
function removeGameLoadingIndicator() {
    const indicator = document.getElementById('game-typing-indicator');
    if (indicator) {
        indicator.remove();
    }
}


// --- (不变) AI 剧本 1: 游戏主持人 (GM)，用于创作谜题 ---
function getGMPrompt(keywords) {
    const keywordHint = keywords ? `请围绕这个关键词： "${keywords}"` : "请随机创作";
    return `[SYSTEM] 你是海龟汤（情景猜谜）的【出题官】。
[你的扮演人设]
${GAME_HOST_PERSONA_PROMPT}
[任务]
你的任务是创作一个【符合你人设的】、简短但有趣的海龟汤谜题。${keywordHint}。
[要求]
1.  **汤面 (face)**: 必须是简短、诡异、且信息不全的场景描述。
2.  **汤底 (bottom)**: 必须是揭示真相、逻辑自洽的答案。
[输出格式]
你必须严格按照 JSON 格式输出，不要有任何多余的解释或Markdown标记。
{
  "face": "...",
  "bottom": "..."
}`;
}

// --- (不变 V3) AI 剧本 2: 提问主持人 (支持群聊互动) ---
function getHostPrompt(history, userInput) {
    const teammateNames = GAME_AI_TEAMMATES.map(t => t.name).join('、 ');
    const teammatePersonas = GAME_AI_TEAMMATES.map(t => `- ${t.name} (人设: ${t.persona})`).join('\n');
    
    return `
[SYSTEM] 你是一个“海龟汤”(猜故事)的游戏AI。
你将同时扮演【多个角色】来推进游戏。

[你的核心身份]
你是 ${GAME_HOST_NAME} (人设: ${GAME_HOST_PERSONA_PROMPT})。

[你现在扮演的角色]
1.  **${GAME_HOST_NAME} (主持人)**:
    * **能力**: 你知道“汤底”(秘密答案)。
    * **规则**: 
        a. 当玩家提问时，你【只能】回答 "是"、"否" 或 "与此无关"。
        b. **【胜利检查】**: 在回答前，你必须【悄悄】判断玩家的问题是否已经非常接近或猜中了汤底。
2.  **${teammateNames} (AI队友们)**:
    * **能力**: 你【假装不知道】“汤底”。你和 "玩家" (人设: ${GAME_USER_PERSONA_PROMPT}) 是队友。
    * **规则**: 你的任务是“表演”得像一个真实的玩家。
    * **【关键互动】**: 你的队友们会【互相讨论】，而不是都只回复玩家。

[AI队友列表 (你将扮演他们)]
${teammatePersonas}

[秘密汤底 - 只有 ${GAME_HOST_NAME} 知道]
${GAME_SECRET_SOUP_BOTTOM}
[秘密汤底 结束]

[游戏历史记录]
${formatHistory(history)}

[当前任务]
玩家 (人设: ${GAME_USER_PERSONA_PROMPT}) 刚刚向【主持人】提问："${userInput}"

[你的行动]
1.  **[主持人-胜利检查]**: 玩家的提问 "${userInput}" 是否猜中了汤底？
2.  **[主持人-回答]**: 给出 "是"、"否" 或 "与此无关"。
3.  **[AI队友-表演]**: 扮演 1-2 名 AI 队友，针对主持人的回答，展开一段【你来我往】的简短讨论。

[输出格式] (必须严格遵守 Koko App 的剧本格式)
VERDICT: [这里填 "是" / "否" / "与此无关" / "VICTORY" (如果玩家猜中了)]

MESSAGE_START
SPEAKER: ${GAME_HOST_NAME}
CONTENT: [这里重复你的VERDICT，但如果是VICTORY，就说一句恭喜的话]
MESSAGE_END

MESSAGE_START
SPEAKER: [AI队友A的名字]
CONTENT: [队友A针对“主持人”的回答发表评论]
MESSAGE_END

(可选, 强烈推荐)
MESSAGE_START
SPEAKER: [AI队友B的名字]
CONTENT: [队友B【回复队友A】，而不是回复主持人]
MESSAGE_END
`;
}

// --- (不变 V3) AI 剧本 3: 和队友讨论 (支持群聊互动) ---
function getDiscussPrompt(history, userInput) {
    const teammateNames = GAME_AI_TEAMMATES.map(t => t.name).join('、 ');
    const teammatePersonas = GAME_AI_TEAMMATES.map(t => `- ${t.name} (人设: ${t.persona})`).join('\n');

    return `
[SYSTEM] 你【只】扮演 AI 队友们: ${teammateNames}。
你是一个正在玩“海龟汤”的普通玩家，你【不知道】秘密答案。
* 你的队友 "玩家" (人设: ${GAME_USER_PERSONA_PROMPT}) 正在和你私下讨论，【主持人听不见】。
* 你的任务是和玩家一起头脑风暴，进行推理。

[AI队友列表 (你将扮演他们)]
${teammatePersonas}

[游戏历史记录]
(这是目前为止所有的公开线索)
${formatHistory(history)}

[当前任务]
你的队友 "玩家" (人设: ${GAME_USER_PERSONA_PROMPT}) 刚刚私下对大家说："${userInput}"

[你的行动]
扮演 2 到 3 名 AI 队友，针对玩家的话，展开一段【你来我往、互相回复】的简短【穿插讨论】。
* 第一个队友可以回复玩家。
* 第二个队友【必须回复第一个队友】，让对话延续下去。

[输出格式] (必须严格遵守 Koko App 的剧本格式)
MESSAGE_START
SPEAKER: [AI队友A的名字]
CONTENT: [队友A针对“玩家”的话发表评论]
MESSAGE_END

MESSAGE_START
SPEAKER: [AI队友B的名字]
CONTENT: [队友B【回复队友A】，而不是回复玩家]
MESSAGE_END
`;
}

/**
 * (不变) 游戏专用的消息显示函数
 */
function addGameMessage(sender, text, senderName) {
    const wrapper = document.createElement('div');
    wrapper.className = `message-wrapper ${sender}`;
    
    let nameClass = sender;
    let displayName = "你"; // 默认

    if (sender === 'ai-player') {
        displayName = senderName; // 动态传入
        nameClass = 'ai-player';
    } else if (sender === 'host') {
        displayName = GAME_HOST_NAME;
        nameClass = 'host';
    } else if (sender === 'user') {
        nameClass = 'user';
    }

    const isHostIntro = (sender === 'host' && text.startsWith('汤面：'));
    const isVictory = (sender === 'host' && text.includes('恭喜'));
    const isSurrender = (sender === 'host' && text.startsWith('汤底是：'));

    let messageClass = 'message';
    if(isHostIntro) { /* no extra class */ }
    else if(isVictory) { messageClass += ' victory'; }
    else if(isSurrender) { messageClass += ' surrender'; }
    else if(sender === 'host') { messageClass += ' answer'; }
    
    if (!isHostIntro) {
        const nameEl = document.createElement('div');
        nameEl.className = `sender-name ${nameClass}`;
        nameEl.textContent = displayName;
        wrapper.appendChild(nameEl);
    }
    
    const messageEl = document.createElement('div');
    messageEl.className = messageClass;
    messageEl.innerHTML = text.replace(/\n/g, '<br>');
    wrapper.appendChild(messageEl);

    gameChatLog.appendChild(wrapper);
    gameChatLogWrapper.scrollTop = gameChatLogWrapper.scrollHeight;
}

/**
 * (不变) 格式化游戏历史
 */
function formatHistory(messages) {
    return messages.map(msg => `${msg.role}: ${msg.content}`).join('\n');
}

/**
 * (不变 V2) 游戏专用的AI调用函数
 */
async function callGameAI(systemPrompt) {
    const apiConfig = getApiFor('chat'); 
    const { apiKey, model, endpoint } = apiConfig;

    if (!apiKey || !endpoint || !model) {
        const errorMsg = "错误：游戏无法启动，因为【聊天API设置】未配置。请前往“发现-API设置”进行配置。";
        console.error(errorMsg);
        alert(errorMsg);
        throw new Error(errorMsg);
    }

    const bodyPayload = {
        model: model,
        messages: [
            { role: "user", content: systemPrompt }
        ]
    };
    
    if (systemPrompt.includes('"face":')) {
        bodyPayload.response_format = { type: "json_object" };
    }

    try {
        let data;
        if (endpoint.includes('generativelanguage.googleapis.com')) {
            data = await handleGeminiTranslation(bodyPayload, apiKey);
        } else {
            const cleanEndpoint = normalizeApiEndpoint(endpoint); 
            const chatEndpoint = `${cleanEndpoint}/v1/chat/completions`;
            
            const response = await fetch(chatEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify(bodyPayload)
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error ? errorData.error.message : 'Unknown API error');
            }
            data = await response.json();
        }
        return data.choices[0].message.content.trim();
    } catch (error) {
        console.error('游戏AI调用失败:', error);
        throw error;
    }
}

/**
 * ✨✨ (新 V4) 启动游戏的主函数 ✨✨
 */
async function handleStartGame() {
    // 1. 保存GM人设
    GAME_HOST_PERSONA_PROMPT = gameGmPersonaInput.value.trim();
    if (!GAME_HOST_PERSONA_PROMPT) GAME_HOST_PERSONA_PROMPT = "一个普通的主持人";
    
    // (新) 1b. 保存“你(玩家)”的人设
    GAME_USER_PERSONA_PROMPT = gameUserPersonaSelect.value; 
    if (!GAME_USER_PERSONA_PROMPT) {
        GAME_USER_PERSONA_PROMPT = "一个聪明的玩家"; // 默认人设
    }

    // 2. 保存关键词
    const keywords = gameKeywordsInput.value.trim();
    GAME_LAST_KEYWORDS = keywords; // (新) 保存关键词以便重玩
    
    // 3. 组合AI队友
    GAME_AI_TEAMMATES = [];
    
    // 3a. 从联系人列表添加
    const selectedPlayerCheckboxes = document.querySelectorAll('#game-player-picker-list input:checked');
    Array.from(selectedPlayerCheckboxes).forEach(cb => {
        const contact = state.contacts.find(c => c.id === cb.value);
        if(contact) GAME_AI_TEAMMATES.push({ 
            name: contact.name, 
            persona: contact.persona || '一个普通玩家' 
        });
    });

    // ▼▼▼ 3b. (新) 从关系网NPC列表添加 ▼▼▼
    const selectedNpcCheckboxes = document.querySelectorAll('#game-npc-picker-list input:checked');
    Array.from(selectedNpcCheckboxes).forEach(cb => {
        // (新) 从我们之前存的 tempAllNpcList 列表里找
        const npc = tempAllNpcList.find(n => n.id === cb.value);
        if (npc) {
            GAME_AI_TEAMMATES.push({ 
                name: npc.name, 
                persona: npc.persona || '一个神秘的NPC' // (新) 使用NPC的人设
            });
        }
    });
    // ▲▲▲ 新增结束 ▲▲▲

    // 3c. 从自定义NPC文本域添加
    const teammatesText = gameCustomNpcsInput.value.trim();
    if (teammatesText) {
        teammatesText.split('\n').forEach(line => {
            const parts = line.split('|');
            const name = parts[0] ? parts[0].trim() : null;
            if (name) GAME_AI_TEAMMATES.push({ name: name, persona: (parts[1] ? parts[1].trim() : '一个普通玩家') });
        });
    }

    // 4. 切换UI (不变)
    document.getElementById('start-game-modal').style.display = 'none';
    hideAllScreens(); 
    gameChatScreen.style.display = 'flex'; 
    setGameButtonsDisabled(true); 
    gamePuzzleTextEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 主持人正在创作谜题中...';
    gameChatLogWrapper.classList.add('loading');
    
    // 5. 调用GM AI生成谜题 (不变)
    try {
        const gmPrompt = getGMPrompt(keywords);
        const rawResponse = await callGameAI(gmPrompt);
        
        // 6. 解析谜题 (不变)
        let puzzleJSON;
        try {
            const jsonMatch = rawResponse.match(/{[\s\S]*}/);
            if (!jsonMatch) throw new Error("AI未返回有效的JSON格式。");
            puzzleJSON = JSON.parse(jsonMatch[0]);
        } catch (e) {
            console.error("解析谜题JSON失败:", e, "AI原始回复:", rawResponse);
            puzzleJSON = { face: "AI返回格式错误", bottom: `AI回复：${rawResponse}` };
        }

        if (!puzzleJSON.face || !puzzleJSON.bottom) {
             puzzleJSON = { face: "AI未按要求返回", bottom: `AI回复：${rawResponse}` };
        }
        
        GAME_SECRET_SOUP_BOTTOM = puzzleJSON.bottom; 

        // 7. 启动游戏 (不变)
        initGame(puzzleJSON.face); 

    } catch (error) {
        console.error("生成谜题失败:", error);
        alert("游戏启动失败: " + error.message);
        gameChatScreen.style.display = 'none';
        showDiscoverScreen(); 
    } finally {
        setGameButtonsDisabled(false);
        gameChatLogWrapper.classList.remove('loading');
    }
}

/**
 * (不变 V2) 重新开始一局新游戏 (再玩一局)
 */
async function replayGame() {
    setGameButtonsDisabled(true); 
    gamePuzzleTextEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 主持人正在创作新谜题中...';
    gameChatLogWrapper.classList.add('loading');
    
    try {
        const gmPrompt = getGMPrompt(GAME_LAST_KEYWORDS); 
        const rawResponse = await callGameAI(gmPrompt);
        
        let puzzleJSON;
        try {
            const jsonMatch = rawResponse.match(/{[\s\S]*}/);
            if (!jsonMatch) throw new Error("AI未返回有效的JSON格式。");
            puzzleJSON = JSON.parse(jsonMatch[0]);
        } catch (e) {
            puzzleJSON = { face: "AI返回格式错误", bottom: `AI回复：${rawResponse}` };
        }
        if (!puzzleJSON.face || !puzzleJSON.bottom) {
             puzzleJSON = { face: "AI未按要求返回", bottom: `AI回复：${rawResponse}` };
        }
        
        GAME_SECRET_SOUP_BOTTOM = puzzleJSON.bottom; 
        initGame(puzzleJSON.face); 

    } catch (error) {
        console.error("生成新谜题失败:", error);
        alert("开始新一局失败: " + error.message);
        gameChatScreen.style.display = 'none';
        showDiscoverScreen();
    } finally {
        setGameButtonsDisabled(false);
        gameChatLogWrapper.classList.remove('loading');
    }
}

/**
 * (新 V4) 解析并显示AI的多段回复
 */
function parseAndDisplayAiResponse(rawResponse, mode) {
    removeGameLoadingIndicator(); // (新) 隐藏“正在思考”

    // 1. (不变) 先剥离VERDICT
    if (mode === 'host') {
        const verdictMatch = rawResponse.match(/VERDICT:\s*(.*)/);
        if (verdictMatch) {
            const verdict = verdictMatch[1].trim();
            if (verdict === "VICTORY") {
                endGame(true); 
                return; 
            }
        }
    }

    // 2. (不变 V3) 使用 Koko App 的剧本解析器
    const messageRegex = /MESSAGE_START\s*SPEAKER:\s*(.*?)\s*CONTENT:\s*([\s\S]*?)\s*MESSAGE_END/g;
    let match;
    const responsesToShow = []; 

    while ((match = messageRegex.exec(rawResponse)) !== null) {
        const speakerName = match[1].trim();
        const content = match[2].trim();
        if (!content) continue;
        
        if (speakerName === GAME_HOST_NAME) {
            responsesToShow.push({ sender: 'host', name: GAME_HOST_NAME, text: content });
        } else if (GAME_AI_TEAMMATES.some(t => t.name === speakerName)) {
            responsesToShow.push({ sender: 'ai-player', name: speakerName, text: content });
        }
    }

    // 3. (不变) 模拟真实聊天延迟，依次显示
    (async function showResponsesSequentially() {
        
        for (const res of responsesToShow) {
            await new Promise(resolve => setTimeout(resolve, 800 + Math.random() * 500));
            addGameMessage(res.sender, res.text, res.name);
            gameMessages.push({ role: res.name, content: res.text });
        }
        
        setGameButtonsDisabled(false); 
    })();
}

/**
 * (新 V4) 处理“提问主持人”
 */
async function handleAskHost() {
    const text = gameUserInput.value.trim();
    if (!text) return;
    gameUserInput.value = '';
    gameUserInput.style.height = 'auto';
    setGameButtonsDisabled(true);

    addGameMessage('user', text, "你");
    gameMessages.push({ role: '玩家', content: text }); 
    showGameLoadingIndicator(); // (新) 显示“正在思考”

    try {
        const hostPrompt = getHostPrompt(gameMessages, text);
        const aiRawResponse = await callGameAI(hostPrompt);
        parseAndDisplayAiResponse(aiRawResponse, 'host');
    } catch (error) {
        removeGameLoadingIndicator();
        setGameButtonsDisabled(false);
    }
}

/**
 * (新 V4) 处理“和TA讨论”
 */
async function handleDiscuss() {
    const text = gameUserInput.value.trim();
    if (!text) return;
    gameUserInput.value = '';
    gameUserInput.style.height = 'auto';
    setGameButtonsDisabled(true);

    addGameMessage('user', text, "你");
    const historyText = `(玩家私下对大家说: ${text})`; 
    gameMessages.push({ role: '玩家', content: historyText }); 
    showGameLoadingIndicator(); // (新) 显示“正在思考”

    try {
        const discussPrompt = getDiscussPrompt(gameMessages, text);
        const aiRawResponse = await callGameAI(discussPrompt);
        parseAndDisplayAiResponse(aiRawResponse, 'discuss');
    } catch (error) {
        removeGameLoadingIndicator();
        setGameButtonsDisabled(false);
    }
}

/**
 * (新) 玩家只发送消息，不触发AI回复 (纯净版)
 */
function handleJustSend() {
    const text = gameUserInput.value.trim();
    if (!text) return; 
    gameUserInput.value = '';
    gameUserInput.style.height = 'auto';
    addGameMessage('user', text, "你");
    gameMessages.push({ role: '玩家', content: text }); 
    setGameButtonsDisabled(false); 
    // gameUserInput.focus(); // (已注释掉，防止自动弹起)
}


/**
 * (不变) 游戏结束/认输 逻辑
 */
function endGame(isVictory) {
    setGameButtonsDisabled(true); 
    gameInputArea.classList.add('game-ended'); 
    gameSurrenderBtn.style.display = 'none'; 
    
    if (isVictory) {
        addGameMessage('host', '🎉 恭喜！你猜对了！🎉', GAME_HOST_NAME);
    } else {
        addGameMessage('host', '游戏结束', GAME_HOST_NAME);
    }
    
    addGameMessage('host', `汤底是：\n${GAME_SECRET_SOUP_BOTTOM}`, GAME_HOST_NAME);
    
    gamePlayAgainBtn.style.display = 'block'; 
}

/**
 * (新 V2) 辅助：批量禁用/启用游戏按钮
 */
function setGameButtonsDisabled(disabled) {
    if (!gameAskHostBtn) return; // DOM还没加载完
    gameAskHostBtn.disabled = disabled;
    gameDiscussBtn.disabled = disabled;
    gameUserInput.disabled = disabled;
    gameSurrenderBtn.disabled = disabled;
    // (已删除自动 focus)
}

/**
* (新 V5) 打开游戏玩家选择弹窗
*/
async function openSeaTurtleModal() {
    // 1. 设定默认GM人设
    const defaultHostPersona = "一个冷静、严肃、惜字如金的主持人，只说必要的话。";
    document.getElementById('game-gm-persona-input').value = defaultHostPersona;
    
    // 2. 填充“你(玩家)”的人设下拉菜单
    const userPersonaSelect = document.getElementById('game-user-persona-select');
    userPersonaSelect.innerHTML = '<option value="">-- 默认 (一个聪明的玩家) --</option>'; 
    state.userPersonaPresets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.description; 
        option.textContent = preset.name; 
        userPersonaSelect.appendChild(option);
    });

    // 3. 填充可选的AI队友列表 (联系人)
    const playerListEl = document.getElementById('game-player-picker-list');
    playerListEl.innerHTML = '';
    const otherContacts = state.contacts.filter(c => !c.isGroup);

    if (otherContacts.length === 0) {
        playerListEl.innerHTML = '<p style="color: #888; text-align: center;">没有AI联系人可以当队友</p>';
    } else {
        otherContacts.forEach(c => { 
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.innerHTML = `
                <input type="checkbox" id="game-player-${c.id}" value="${c.id}" style="margin-right: 15px;">
                <label for="game-player-${c.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                    <img src="${c.avatar}" alt="${c.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                    <span>${c.name}</span>
                </label>
            `;
            playerListEl.appendChild(item);
        });
    }

    // 4. (新) 填充可选的AI队友列表 (关系网NPC)
    const npcListEl = document.getElementById('game-npc-picker-list');
    npcListEl.innerHTML = '';
    tempAllNpcList = []; // (新) 清空临时NPC列表
    const seenNpcIds = new Set();
    const allNetworks = await kokoMemory.getAll('relationshipNetworks');

    allNetworks.forEach(network => {
        if (network.nodes) {
            network.nodes.forEach(node => {
                // 筛选：是NPC 且 还没被添加过 且 有人设
                if (node.isContact === false && !seenNpcIds.has(node.id) && node.persona) {
                    tempAllNpcList.push(node); // (新) 存入临时列表
                    seenNpcIds.add(node.id);
                    
                    const item = document.createElement('div');
                    item.className = 'contact-picker-item';
                    item.innerHTML = `
                        <input type="checkbox" id="game-player-${node.id}" value="${node.id}" style="margin-right: 15px;">
                        <label for="game-player-${node.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                            <img src="${node.avatar}" alt="${node.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                            <span>${node.name} (NPC)</span>
                        </label>
                    `;
                    npcListEl.appendChild(item);
                }
            });
        }
    });
    
    if (npcListEl.innerHTML === '') {
        npcListEl.innerHTML = '<p style="color: #888; text-align: center;">没有从关系网找到带人设的NPC</p>';
    }

    // 5. 清空自定义NPC和关键词
    document.getElementById('game-custom-npcs-input').value = '';
    document.getElementById('soup-keywords-input').value = '';
    
    // 6. 显示弹窗
    document.getElementById('start-game-modal').style.display = 'flex';
}

/**
 * (新 V5) 游戏初始化 (修改了“再玩一局”和“回车”的逻辑)
 */
function initGame(soupFace) {
    // 1. 设置置顶汤面
    gamePuzzleTextEl.textContent = soupFace;
    
    // 2. 清空聊天记录和游戏历史
    gameChatLog.innerHTML = '';
    gameMessages = [{ role: GAME_HOST_NAME, content: `汤面：${soupFace}` }];
    
    // 3. 重置UI状态
    setGameButtonsDisabled(false);
    gameSurrenderBtn.style.display = 'block';
    gamePlayAgainBtn.style.display = 'none';
    gameInputArea.classList.remove('game-ended');
    gameUserInput.focus();
    
    // 4. (重新)绑定按钮事件 (使用克隆节点大法)
    const newAskBtn = gameAskHostBtn.cloneNode(true);
    gameAskHostBtn.parentNode.replaceChild(newAskBtn, gameAskHostBtn);
    newAskBtn.addEventListener('click', handleAskHost);
    gameAskHostBtn = newAskBtn;
    
    const newDiscussBtn = gameDiscussBtn.cloneNode(true);
    gameDiscussBtn.parentNode.replaceChild(newDiscussBtn, gameDiscussBtn);
    newDiscussBtn.addEventListener('click', handleDiscuss);
    gameDiscussBtn = newDiscussBtn;
    
    const newSurrenderBtn = gameSurrenderBtn.cloneNode(true);
    gameSurrenderBtn.parentNode.replaceChild(newSurrenderBtn, gameSurrenderBtn);
    newSurrenderBtn.addEventListener('click', () => endGame(false));
    gameSurrenderBtn = newSurrenderBtn;

    const newPlayAgainBtn = gamePlayAgainBtn.cloneNode(true);
    gamePlayAgainBtn.parentNode.replaceChild(newPlayAgainBtn, gamePlayAgainBtn);
    newPlayAgainBtn.addEventListener('click', () => {
        // (新) "再玩一局" 应该调用 replayGame()
        replayGame();
    });
    gamePlayAgainBtn = newPlayAgainBtn;
    
    // 退出按钮
    const newExitBtn = gameExitBtn.cloneNode(true);
    gameExitBtn.parentNode.replaceChild(newExitBtn, gameExitBtn);
    newExitBtn.addEventListener('click', () => {
        gameChatScreen.style.display = 'none';
        showDiscoverScreen();
    });
    gameExitBtn = newExitBtn;
    
    // 输入框
    const newUserInput = gameUserInput.cloneNode(true);
    gameUserInput.parentNode.replaceChild(newUserInput, gameUserInput);
    
    // (新) 回车键只发送，不提问
    newUserInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey && !newAskBtn.disabled) {
            e.preventDefault();
            handleJustSend(); // <-- 核心修改在这里
        }
    });
    
    // 输入框自动长高
    newUserInput.addEventListener('input', function() {
        this.style.height = 'auto';
        const maxHeight = 100;
        const newHeight = Math.min(this.scrollHeight, maxHeight);
        this.style.height = newHeight + 'px';
    });
    gameUserInput = newUserInput;
}
// --- 股票功能函数 ---

// ▼▼▼ 用下面【一整个代码块】替换掉旧的 startStockMarket, stopStockMarket, updateStockMarketUI, handleStockTrade 四个函数 ▼▼▼

// --- 全局变量 ---
let stockEventInterval = null; // 新的事件循环定时器
let activeStockId = 'KOK'; // 默认选中的股票
const STOCK_IDS = ['KOK', 'TECH', 'BIO']; // 我们的三只股票
const STOCK_NAMES = { KOK: 'KokoCoin', TECH: 'Koko 科技', BIO: 'Koko 医药' };

// ▼▼▼ 用这个【40个事件豪华版】替换旧的 stockEventDefinitions 数组 ▼▼▼
const stockEventDefinitions = [
    // ==========================================================
    // 类别 1：公司经营 (Operations) - 10个事件
    // ==========================================================
    { type: 'positive', category: '经营', text: "发布了革命性新产品，分析师连夜上调评级！" },
    { type: 'positive', category: '经营', text: "财报远超预期，净利润同比增长200%！" },
    { type: 'positive', category: '经营', text: "宣布聘请了业界的传奇人物 'Koko酱' 担任新任CEO！" },
    { type: 'positive', category: '经营', text: "核心技术取得重大突破，获得关键性专利。" },
    { type: 'positive', category: '经营', text: "成功开拓海外市场，签订了价值数十亿的长期合同。" },
    
    { type: 'negative', category: '经营', text: "核心产品发现严重安全漏洞，正在全球范围内紧急召回。" },
    { type: 'negative', category: '经营', text: "CEO 突发丑闻，公司形象受损，董事会紧急开会。" },
    { type: 'negative', category: '经营', text: "关键技术专利诉讼败诉，面临巨额赔偿和禁售风险。" },
    { type: 'negative', category: '经营', text: "重要工厂发生火灾，预计将导致供应链中断数周。" },
    
    { type: 'neutral', category: '经营', text: "公司宣布进行常规组织架构调整，业务线不变。" },

    // ==========================================================
    // 类别 2：资本运作 (Capital) - 9个事件
    // ==========================================================
    { type: 'positive', category: '资本', text: "神秘财团宣布大举增持，市场信心爆棚。" },
    { type: 'positive', category: '资本', text: "宣布与行业巨头“腾达集团”达成战略合并协议。" },
    { type: 'positive', category: '资本', text: "公司宣布一项高达50亿的股票回购计划。" },
    { type: 'positive', category: '资本', text: "信用评级被“标普”从A-上调至A+。" },

    { type: 'negative', category: '资本', text: "大股东宣布清仓式减持，引发市场恐慌。" },
    { type: 'negative', category: '资本', text: "与“腾达集团”的合并谈判意外破裂，需支付巨额分手费。" },
    { type: 'negative', category: '资本', text: "宣布增发新股以偿还债务，稀释现有股东权益。" },
    { type: 'negative', category: '资本', text: "信用评级被“穆迪”下调至“垃圾级”。" },
    
    { type: 'neutral', category: '资本', text: "宣布“10送10”高送转方案，股价除权。" },

    // ==========================================================
    // 类别 3：国家推动 (Policy) - 9个事件
    // ==========================================================
    { type: 'positive', category: '政策', text: "被纳入国家重点扶持“芯片”产业名单，喜提巨额补贴。" },
    { type: 'positive', category: '政策', text: "成功中标“智慧城市”千亿级政府独家采购大单。" },
    { type: 'positive', category: '政策', text: "行业准入标准大幅提高，小企业被清退，利好龙头。" },
    { type: 'positive', category: '政策', text: "政府宣布对竞争对手（海外）的进口商品加征100%关税。" },

    { type: 'negative', category: '政策', text: "遭遇反垄断调查，或将面临天价罚款。" },
    { type: 'negative', category: '政策', text: "新环保法案出台，公司核心业务面临合规压力，成本剧增。" },
    { type: 'negative', category: '政策', text: "被移出“政府补贴”名单，未来盈利能力存疑。" },
    { type: 'negative', category: '政策', text: "因地缘政治紧张，被“漂亮国”列入实体管制清单。" },

    { type: 'neutral', category: '政策', text: "行业协会发布年度白皮书，重申了发展的重要性。" },

    // ==========================================================
    // 类别 4：舆论影响 (PR/Opinion) - 9个事件
    // ==========================================================
    { type: 'positive', category: '舆论', text: "社交媒体疯传！某产品成现象级爆款。" },
    { type: 'positive', category: '舆论', text: "公司意外获得“年度最佳雇主”奖，人才吸引力大增。" },
    { type: 'positive', category: '舆论', text: "新签代言人“顶流Koko”形象正面，带动粉丝疯狂抢购。" },
    { type: 'positive', category: '舆论', text: "CEO在慈善晚宴上的感人演讲被疯传，公司好感度拉满。" },

    { type: 'negative', category: '舆论', text: "知名机构“浑水”发布做空报告，指控公司财务造假。" },
    { type: 'negative', category: '舆论', text: "#抵制Koko 话题登上热搜，疑似广告中出现不当言论。" },
    { type: 'negative', category: '舆论', text: "大量用户投诉售后服务“形同虚设”，监管介入调查。" },
    { type: 'negative', category: '舆论', text: "被曝“996”加班文化严重，引发全网打工人共情抵制。" },

    { type: 'neutral', category: '舆论', text: "公司宣布更换新Logo，市场反应平平，设计师被骂惨。" },
    
    // ==========================================================
    // 类别 5：搞笑事件 (Funny) - 3个事件 (约 7.5%)
    // ==========================================================
    { type: 'positive', category: '舆论', text: "【搞笑】CEO在发布会上养的猫意外抢镜，公司Meme图火爆全网，股价意外拉升。" },
    { type: 'negative', category: '经营', text: "【搞笑】公司食堂换了新外包，新菜单导致员工集体在官推下抗议，怨声载道。" },
    { type: 'neutral', category: '舆论', text: "【搞笑】公司新吉祥物被指控长得太像隔壁公司CEO，引发网友热议，双方均表示'很无辜'。" }
];
// ▲▲▲ 替换结束 ▲▲▲

/**
 * (V2.0) 启动股票模拟器 (重写)
 */
async function startStockMarket() {
    // 1. 停止旧的定时器（如果有）
    if (stockEventInterval) clearInterval(stockEventInterval);

    // 2. 初始化所有股票数据
    for (const stockId of STOCK_IDS) {
        let savedData = await kokoMemory.get('stockMarket', stockId);
        if (!savedData) {
            // 如果是第一次，初始化历史数据
            let timestamp = Date.now() - 100 * 5000;
            let price = 100.00 + (Math.random() - 0.5) * 50; // 初始价格不同
            let history = [];
            for (let i = 0; i < 100; i++) {
                price += (Math.random() - 0.48) * 5; 
                price = Math.max(10, price); 
                history.push([timestamp, parseFloat(price.toFixed(2))]);
                timestamp += 5000;
            }
            savedData = {
                id: stockId,
                price: parseFloat(price.toFixed(2)),
                history: history
            };
            await kokoMemory.put('stockMarket', savedData);
        }
    }
    
    // 3. 清空新闻大屏，并加载历史新闻
    const newsFeed = document.getElementById('stock-news-feed');
    newsFeed.innerHTML = '';
    const historicalEvents = await kokoMemory.getAll('stockEvents');
    historicalEvents.slice(-10).forEach(event => logStockEvent(event.text, event.type, true)); // 悄悄加载，不滚动

    // 4. 启动新的“事件”更新定时器（例如 5 到 10 秒随机一次）
    const runCycle = () => {
        runStockEventCycle(); // 立即执行一次
        const nextInterval = (Math.random() * 5000 + 5000); // 5-10秒
        stockEventInterval = setTimeout(runCycle, nextInterval);
    };
    runCycle();

    // 5. 渲染UI (默认显示 KOK)
    activeStockId = 'KOK';
    updateStockMarketUI(activeStockId);
}

/**
 * (V2.0) 停止股票模拟器 (重写)
 */
function stopStockMarket() {
    if (stockEventInterval) clearTimeout(stockEventInterval); // 改为 clearTimeout
    stockEventInterval = null;
}

/**
 * (V2.1 - 带盈亏显示) 刷新UI和图表 (重写)
 * @param {string} stockId - 要显示的股票ID
 */
async function updateStockMarketUI(stockId) {
    if (document.getElementById('stock-market-screen').style.display !== 'flex') {
        return; // 如果页面没打开，就不渲染
    }

    activeStockId = stockId; // 更新当前激活的ID

    // 1. 更新标签页高亮
    document.querySelectorAll('#stock-tabs-container .feed-tab-btn').forEach(btn => {
        if (btn.dataset.stockId === stockId) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });

    // 2. 加载该股票的数据
    const stockData = await kokoMemory.get('stockMarket', stockId);
    if (!stockData) return;

    // ▼▼▼ 核心修改：计算盈亏 ▼▼▼
    const profile = state.myProfile;
    // ✨ 确保我们能读到新字段，并提供默认值
    const myInvest = profile.investments[activeStockId] || { shares: 0, avgBuyPrice: 0, cumulativeProfitLoss: 0 };
    const myShares = myInvest.shares || 0;
    const myCost = myInvest.avgBuyPrice || 0;
    const currentValue = myShares * stockData.price;
    
    // ✨ 新增：计算持仓盈亏 (当前市值 - 总成本)
    const myTotalCost = myCost * myShares;
    const holdingProfitLoss = (myShares > 0) ? (currentValue - myTotalCost) : 0;
    
    // ✨ 新增：获取累计盈亏
    const cumulativeProfitLoss = myInvest.cumulativeProfitLoss || 0;

    // 3. 更新老的UI
    document.getElementById('stock-current-price').textContent = `¥${stockData.price.toFixed(2)}`;
    document.getElementById('stock-my-shares').textContent = `${myShares} 股 (成本: ¥${myCost.toFixed(2)})`;
    document.getElementById('stock-my-value').textContent = `¥${currentValue.toFixed(2)}`;

    // 4. ✨ 新增：更新两个新 <div/> 的内容，并加上红涨绿跌
    const holdingPlEl = document.getElementById('stock-holding-pl');
    const cumulativePlEl = document.getElementById('stock-cumulative-pl');
    
    // (这是一个小工具函数，用来设置文本和颜色)
    const setProfitLossStyle = (el, value) => {
        el.textContent = `${value >= 0 ? '+' : ''}¥${value.toFixed(2)}`;
        el.style.color = value >= 0 ? '#f44336' : '#4caf50'; // 红涨绿跌
    };

    setProfitLossStyle(holdingPlEl, holdingProfitLoss);
    setProfitLossStyle(cumulativePlEl, cumulativeProfitLoss);
    // ▲▲▲ 核心修改结束 ▲▲▲

    // 5. 更新 ECharts 图表 (这部分不变)
    const chartDom = document.getElementById('stock-chart-container');
    let myStockChart = echarts.getInstanceByDom(chartDom);
    if (!myStockChart) {
        myStockChart = echarts.init(chartDom);
    }
    
    // (检查历史数据是否足够，防止图表报错)
    const lastPrice = stockData.history.length > 1 ? stockData.history[stockData.history.length-2][1] : stockData.price;
    const isUp = stockData.price >= lastPrice;

    myStockChart.setOption({
        tooltip: { trigger: 'axis', axisPointer: { type: 'cross' } },
        xAxis: { type: 'time', show: false },
        yAxis: { type: 'value', scale: true, splitLine: { lineStyle: { type: 'dashed' } }, axisLabel: { formatter: '¥{value}' } },
        grid: { left: '15%', right: '5%', top: '5%', bottom: '10%' },
        series: [{
            data: stockData.history,
            type: 'line',
            symbol: 'none',
            lineStyle: { color: isUp ? '#f44336' : '#4caf50', width: 2 }, // 根据涨跌显示红绿
            areaStyle: {
                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{
                    offset: 0, color: isUp ? 'rgba(244, 67, 54, 0.3)' : 'rgba(76, 175, 80, 0.3)'
                }, {
                    offset: 1, color: isUp ? 'rgba(244, 67, 54, 0)' : 'rgba(76, 175, 80, 0)'
                }])
            }
        }]
    }, true);
}

/**
 * (V2.1 - 带盈亏计算) 核心：实现“赔大于赚”的交易函数 (重写)
 * @param {'buy' | 'sell'} type - 交易类型
 */
async function handleStockTrade(type) {
    const amountInput = document.getElementById('stock-amount-input');
    const shares = parseInt(amountInput.value, 10);
    if (isNaN(shares) || shares <= 0) {
        return alert('请输入有效的股数！');
    }

    const stockData = await kokoMemory.get('stockMarket', activeStockId);
    if (!stockData) return;

    const currentPrice = stockData.price;
    const profile = state.myProfile;
    const TRANSACTION_FEE_RATE = 0.015; // 1.5% 的手续费

    // ▼▼▼ 步骤 2：修改“买入”逻辑 ▼▼▼
    if (!profile.investments[activeStockId]) {
        // ✨ 修改点：在这里添加 cumulativeProfitLoss: 0
        profile.investments[activeStockId] = { shares: 0, avgBuyPrice: 0, cumulativeProfitLoss: 0 };
    }
    const myInvest = profile.investments[activeStockId];
    // ▲▲▲ 修改结束 ▲▲▲

    if (type === 'buy') {
        const cost = shares * currentPrice;
        const fee = cost * TRANSACTION_FEE_RATE;
        const totalCost = cost + fee;

        if (profile.balance < totalCost) {
            return alert(`余额不足！购买 ${shares} 股需要 ${totalCost.toFixed(2)} 元 (含手续费 ${fee.toFixed(2)} 元)`);
        }
        
        profile.balance -= totalCost;
        await addTransaction('expense', totalCost, `购买 ${shares} 股 ${STOCK_NAMES[activeStockId]}`);
        
        const oldTotalCost = myInvest.avgBuyPrice * myInvest.shares;
        myInvest.shares += shares;
        myInvest.avgBuyPrice = parseFloat(((oldTotalCost + cost) / myInvest.shares).toFixed(2));

        alert(`购买成功！花费 ${totalCost.toFixed(2)} 元。`);

    } else if (type === 'sell') {
        if (myInvest.shares < shares) {
            return alert(`持仓不足！你只有 ${myInvest.shares} 股。`);
        }
        
        // ▼▼▼ 步骤 3：修改“卖出”逻辑 ▼▼▼
        const revenue = shares * currentPrice;
        const fee = revenue * TRANSACTION_FEE_RATE;
        const totalRevenue = revenue - fee;
        
        // ✨ 核心计算：算出卖掉这些股票的“成本价”
        const costOfSharesSold = myInvest.avgBuyPrice * shares;
        // ✨ 核心计算：(实际收入 - 成本) = 本次交易利润
        const profitFromThisSale = totalRevenue - costOfSharesSold;
        
        profile.balance += totalRevenue;
        await addTransaction('income', totalRevenue, `卖出 ${shares} 股 ${STOCK_NAMES[activeStockId]}`);
        
        // ✨ 核心存储：将本次利润累加到“累计盈亏”中
        myInvest.cumulativeProfitLoss = (myInvest.cumulativeProfitLoss || 0) + profitFromThisSale;
        
        myInvest.shares -= shares;
        if (myInvest.shares === 0) {
            myInvest.avgBuyPrice = 0; // 清仓，成本归零
        }
        // ▲▲▲ 修改结束 ▲▲▲

        alert(`卖出成功！获得 ${totalRevenue.toFixed(2)} 元 (已扣除手续费 ${fee.toFixed(2)} 元)`);
    }

    // 保存并更新UI
    amountInput.value = '';
    await kokoMemory.put('myProfile', state.myProfile);
    renderMyProfile(); // 刷新钱包余额
    updateStockMarketUI(activeStockId); // 刷新交易所UI
}
// ▼▼▼ 把下面【所有】新函数，粘贴到 handleStockTrade 函数的【下方】 ▼▼▼

/**
 * (V2.0-新) 核心游戏循环：发生一个新事件
 */
async function runStockEventCycle() {
    // 1. 随机挑一只股票
    const stockId = STOCK_IDS[Math.floor(Math.random() * STOCK_IDS.length)];
    
    // 2. 随机挑一个事件
    const event = { ...stockEventDefinitions[Math.floor(Math.random() * stockEventDefinitions.length)] };
    event.stockName = STOCK_NAMES[stockId];
    event.text = `【${event.stockName} | ${event.category}】${event.text}`;
    event.id = `evt_${Date.now()}`;

    // 3. 【显示新闻】(你说的“大屏”)
    logStockEvent(event.text, event.type, false);
    // 保存新闻
    await kokoMemory.put('stockEvents', event);

    // 4. 【让用户预看】等待 3 秒
    await sleep(3000); 

    // 5. 【应用价格变动】
    const stockData = await applyPriceChange(stockId, event.type);

    // 6. 如果用户正好在看这只股票，就刷新图表
    if (activeStockId === stockId && document.getElementById('stock-market-screen').style.display === 'flex') {
        updateStockMarketUI(stockId);
    }
}

/**
 * (V2.0-新) 辅助函数：在“大屏”上显示新闻
 */
function logStockEvent(text, type, isSilent = false) {
    const newsFeed = document.getElementById('stock-news-feed');
    if (!newsFeed) return;

    const item = document.createElement('div');
    item.className = `news-item ${type}`; // positive, negative, neutral
    item.textContent = text;
    
    newsFeed.appendChild(item);
    
    if (!isSilent) {
        // 滚动到底部，让新消息可见
        newsFeed.scrollTop = newsFeed.scrollHeight;
    }
    
    // 限制只显示 50 条新闻，防止 DOM 爆炸
    while (newsFeed.children.length > 50) {
        newsFeed.removeChild(newsFeed.firstChild);
    }
}

/**
 * (V2.1-牛市版) 辅助函数：应用价格变动（含涨跌停）
 */
async function applyPriceChange(stockId, eventType) {
    const stockData = await kokoMemory.get('stockMarket', stockId);
    if (!stockData) return;

    let price = stockData.price;
    let changePercent = 0;

    // ▼▼▼ 核心修改在这里！▼▼▼
    switch (eventType) {
        case 'positive':
            // 涨得多！(涨 10% 到 20%)
            changePercent = 0.10 + Math.random() * 0.10; 
            break;
        case 'negative':
            // 跌得少！(只跌 3% 到 8%)
            changePercent = -0.03 - Math.random() * 0.05; 
            break;
        case 'neutral':
            changePercent = (Math.random() - 0.5) * 0.02; // 中性，微小波动 (不变)
            break;
    }
    // ▲▲▲ 修改结束 ▲▲▲

    // 2. 计算新价格
    let newPrice = price * (1 + changePercent);

    // 3. 【应用涨跌停】(假设涨跌停板为 10%)
    const maxPrice = price * 1.10;
    const minPrice = price * 0.90;
    
    // ✨ 修正：如果我们的“牛市”涨幅超过了10%的涨停板，就让它涨停
    newPrice = Math.max(minPrice, Math.min(maxPrice, newPrice));
    
    // 4. 价格不低于 10 元
    newPrice = Math.max(10.00, newPrice); 

    // 5. 更新数据
    stockData.price = parseFloat(newPrice.toFixed(2));
    stockData.history.push([Date.now(), stockData.price]);
    if (stockData.history.length > 200) {
        stockData.history.shift();
    }
    
    await kokoMemory.put('stockMarket', stockData);
    return stockData;
}

// --- 刮刮乐功能函数 ---

/**
 * 辅助函数：洗牌算法
 */
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

/**
 * 辅助函数：生成一个01-30之间的随机两位数号码
 */
function getRandomLotteryNumber() {
    return Math.floor(Math.random() * 30 + 1).toString().padStart(2, '0');
}

/**
 * 辅助函数：生成「中国红」号码匹配游戏盘面
 * @param {number} prizeToWin - 预先确定的奖金额 (0 表示未中奖)
 */
function generateChinaRedGrid(prizeToWin) {
    // 1. 生成 2 个不重复的中奖号码
    let winningNumbers = new Set();
    while (winningNumbers.size < 2) {
        winningNumbers.add(getRandomLotteryNumber());
    }
    const winningNumbersArr = Array.from(winningNumbers); // [ '08', '25' ]

    // 2. 生成 8 个 "你的号码" 和对应的 "奖金"
    let yourNumbers = [];
    let fakePrizes = [50, 100, 500, 1000, 50, 100, 500, 10000]; // 假奖金池
    let fakeNumbers = new Set(); // 确保你的假号码不重复
    while (fakeNumbers.size < 8) {
        const num = getRandomLotteryNumber();
        if (!winningNumbers.has(num)) { // 确保不等于中奖号码
            fakeNumbers.add(num);
        }
    }
    const fakeNumbersArr = Array.from(fakeNumbers);

    if (prizeToWin === 0) {
        // --- 输了 ---
        // 8个号码都用假的
        yourNumbers = fakeNumbersArr.map((num, i) => ({
            number: num,
            prize: fakePrizes[i],
            isMatch: false
        }));
    } else {
        // --- 赢了 ---
        // 7个号码用假的
        yourNumbers = fakeNumbersArr.slice(0, 7).map((num, i) => ({
            number: num,
            prize: fakePrizes[i],
            isMatch: false
        }));
        // 1个号码用真的
        yourNumbers.push({
            number: winningNumbersArr[0], // 匹配第一个中奖号码
            prize: prizeToWin, // 奖金是预先确定的
            isMatch: true
        });
        // 洗牌，让中奖号码位置随机
        yourNumbers = shuffleArray(yourNumbers);
    }

    return { winningNumbers: winningNumbersArr, yourNumbers };
}

/**
 * 辅助函数：生成「暴富钻石」9宫格匹配游戏盘面
 * @param {number} prizeToWin - 预先确定的奖金额 (0 表示未中奖)
 */
function generateDiamondGrid(prizeToWin) {
    let grid = [];
    const loseSymbols = ['😥', '🍌', '☂️', '👟', '💨'];
    // 制造“差一点就中”的假象
    const fakePrizes = ['¥100', '¥100', '¥500', '¥500', '¥1,000', '¥1,000', '¥5,000'];

    if (prizeToWin > 0) {
        // --- 赢了 ---
        const winSymbol = `¥${prizeToWin}`;
        grid = [winSymbol, winSymbol, winSymbol]; // 3个中奖符号
        // 剩下的 6 个用 "谢谢惠顾" 和 "假奖金" 填充
        grid = grid.concat(shuffleArray(fakePrizes.concat(loseSymbols)).slice(0, 6));
    } else {
        // --- 没中 ---
        // 填充 9 个格子，确保没有任何 3 个是相同的
        grid = shuffleArray(fakePrizes.concat(loseSymbols).concat(['¥10,000', '¥10,000'])).slice(0, 9);
    }
    
    return shuffleArray(grid); // 再次打乱
}

/**
 * 辅助函数：生成「幸运 7」符号匹配游戏盘面
 * @param {number} prizeToWin - 预先确定的奖金额 (0 表示未中奖)
 */
function generateLucky7Grid(prizeToWin) {
    let grid = [];
    // 6 个格子
    const symbols = ['🍒', '🍊', '🍋', '🔔', '🍉', '⭐'];
    
    if (prizeToWin > 0) {
        // --- 赢了 ---
        grid = shuffleArray(['7️⃣', '🍒', '🍊', '🍋', '🔔', '🍉']);
    } else {
        // --- 没中 ---
        grid = shuffleArray(symbols);
    }
    return grid;
}


/**
 * (V3.4 - 指定大奖版) 购买刮刮乐的核心逻辑
 * @param {number} price - 价格
 * @param {string} gameType - 游戏类型 ('lucky_7', 'china_red', 'diamond')
 */
async function purchaseScratchCard(price, gameType) {
    price = parseInt(price, 10);
    if (state.myProfile.balance < price) {
        alert('余额不足！');
        return;
    }

    // 1. 扣钱
    state.myProfile.balance -= price;
    await addTransaction('expense', price, `购买 ${price}元 刮刮乐`);

    // 2. 核心：【先开奖】
    const rand = Math.random();
    let winnings = 0;
    let title = "";
    let message = "";

    // 3. 根据游戏类型决定赔率和玩法
    // ==================================
    // 游戏 1: 幸运 7 (20元) - (✨ 植入20万大奖 ✨)
    // ==================================
    if (gameType === 'lucky_7') {
        title = "刮开「幸运 7」！";
        // 规则：找到一个 "7" 就中奖
        
        // ▼▼▼ 核心修改在这里 ▼▼▼
        if (rand < 0.00005) { 
            winnings = 200000; // ✨ 20万大奖！(2万分之一概率)
        } 
        // ▲▲▲ 修改结束 ▲▲▲
        
        else if (rand < 0.01) { winnings = 500; }    // (1% 概率中 500)
        else if (rand < 0.11) { winnings = 100; }   // (10% 概率中 100)
        else if (rand < 0.31) { winnings = 20; }    // (20% 概率中 20, 回本)
        else { winnings = 0; }
        
        const grid = generateLucky7Grid(winnings);
        
        // 渲染UI (6格)
        const gridDisplay = document.getElementById('scratch-grid-display');
        gridDisplay.innerHTML = '';
        gridDisplay.className = 'your-numbers-grid'; // 复用这个样式
        gridDisplay.style.gridTemplateColumns = '1fr 1fr 1fr'; // 改成 3 列
        
        grid.forEach(symbol => {
            const isWinning = symbol === '7️⃣';
            gridDisplay.innerHTML += `
                <div class="scratch-cell-player covered ${isWinning ? 'match' : ''}" data-symbol="${symbol}">
                    <span class="symbol-content">${symbol}</span>
                    <i class="fas fa-coins scratch-icon"></i>
                </div>
            `;
        });

    // ==================================
    // 游戏 2: 中国红 (50元) - (✨ 植入50万大奖 ✨)
    // ==================================
    } else if (gameType === 'china_red') {
        title = "刮开「中国红」！";
        // 规则：号码匹配
        
        // ▼▼▼ 核心修改在这里 ▼▼▼
        if (rand < 0.00002) { 
            winnings = 500000; // ✨ 50万大奖！(5万分之一概率)
        } 
        // ▲▲▲ 修改结束 ▲▲▲
        
        else if (rand < 0.005) { winnings = 5000; }   // (0.5% 概率中 5000)
        else if (rand < 0.10) { winnings = 100; }  // (9.5% 概率中 100)
        else if (rand < 0.30) { winnings = 50; }   // (20%  概率中 50, 回本)
        else { winnings = 0; }
        
        const gameData = generateChinaRedGrid(winnings);
        
        // 渲染UI (专属布局)
        const gridDisplay = document.getElementById('scratch-grid-display');
        gridDisplay.innerHTML = '';
        gridDisplay.className = 'game-china-red'; // 添加专属 class
        gridDisplay.style.gridTemplateColumns = '1fr'; // 重置为单列
        
        // A. 渲染中奖号码区 (这个是默认就刮开的)
        gridDisplay.innerHTML += `
            <div class="china-red-area">
                <h3>中奖号码</h3>
                <div class="winning-numbers-grid">
                    <div class="scratch-cell-winner">${gameData.winningNumbers[0]}</div>
                    <div class="scratch-cell-winner">${gameData.winningNumbers[1]}</div>
                </div>
            </div>
        `;
        // B. 渲染你的号码区 
        let yourNumbersHTML = gameData.yourNumbers.map(item => `
            <div class="scratch-cell-player covered ${item.isMatch ? 'match' : ''}" data-number="${item.number}" data-prize="${item.prize}" data-is-match="${item.isMatch}">
                <div class="cell-content">
                    <div class="player-number">${item.number}</div>
                    <div class="player-prize">¥${item.prize}</div>
                </div>
                <i class="fas fa-coins scratch-icon"></i>
            </div>
        `).join('');
        
        gridDisplay.innerHTML += `
            <div class="china-red-area">
                <h3>你的号码</h3>
                <div class="your-numbers-grid">
                    ${yourNumbersHTML}
                </div>
            </div>
        `;

    // ==================================
    // 游戏 3: 暴富钻石 (100元) - (✨ 植入100万大奖 ✨)
    // ==================================
    } else if (gameType === 'diamond') {
        title = "刮开「暴富钻石」！";
        // 规则：9宫格三匹配
        
        // ▼▼▼ 核心修改在这里 ▼▼▼
        if (rand < 0.00001) { 
            winnings = 1000000; // ✨ 100万大奖！ (十万分之一)
        } 
        // ▲▲▲ 修改结束 ▲▲▲

        // (保留其它的高额奖项，让这个彩票更刺激)
        else if (rand < 0.001) { 
            winnings = 100000;  // 10万大奖 (0.1% 概率)
        } 
        else if (rand < 0.02) { 
            winnings = 1000;    // 1000元 (1.9% 概率)
        } 
        else if (rand < 0.12) { 
            winnings = 500;     // 500元 (10% 概率)
        } 
        else if (rand < 0.27) { 
            winnings = 100;     // 100元 (回本) (15% 概率)
        } 
        else { 
            winnings = 0; 
        }
        
        const grid = generateDiamondGrid(winnings);
        
        // 渲染UI (9格)
        const gridDisplay = document.getElementById('scratch-grid-display');
        gridDisplay.innerHTML = '';
        gridDisplay.className = 'your-numbers-grid'; // 复用这个样式
        gridDisplay.style.gridTemplateColumns = '1fr 1fr 1fr'; // 3 列
        
        grid.forEach(symbol => {
            const isWinning = (winnings > 0 && symbol === `¥${winnings}`);
            gridDisplay.innerHTML += `
                <div class="scratch-cell-player covered ${isWinning ? 'match' : ''}" data-symbol="${symbol}">
                    <span class="symbol-content" style="font-size: ${symbol.length > 5 ? '14px' : '18px'};">${symbol}</span>
                    <i class="fas fa-coins scratch-icon"></i>
                </div>
            `;
        });
    }

    // 4. (已修改) 设置中奖信息
    if (winnings > 0) {
        // ✨ 修改：让中大奖的提示更夸张！
        if (winnings >= 200000) {
            message = `🎉🎉🎉 **天呐！！你中了特等奖！！** <br> **${winnings.toLocaleString('en-US')}** 元！`;
        } else if (winnings >= 1000) {
             message = `🎉🎉 恭喜！你中了 **${winnings}** 元！`;
        } else {
            message = `恭喜，你中了 ${winnings} 元！`;
        }
    } else {
        message = "谢谢惠顾，下次好运哦！";
    }

    // 5. 【核心修改】只显示刮奖区域，不显示结果
    const resultArea = document.getElementById('scratch-result-area');
    resultArea.style.display = 'block';
    document.getElementById('scratch-result-title').innerHTML = title;
    
    // 【修改】把结果先存起来，不显示
    resultArea.dataset.winnings = winnings;
    resultArea.dataset.message = message;
    resultArea.dataset.gameType = gameType;
    // 【修改】清空上次的结果
    document.getElementById('scratch-result-message').innerHTML = ''; 
    
    // 6. 刷新余额
    renderMyProfile();
    await kokoMemory.put('myProfile', state.myProfile);
}
// ▼▼▼ 把这段新代码粘贴到 attachEventListeners 函数的【末尾】 ▼▼▼

    // --- 新增：Koko交易所 - 标签页点击事件 ---
    document.getElementById('stock-tabs-container').addEventListener('click', (e) => {
        const tabBtn = e.target.closest('.feed-tab-btn');
        if (tabBtn && tabBtn.dataset.stockId) {
            // 当点击标签页时，只更新UI，不触发事件循环
            updateStockMarketUI(tabBtn.dataset.stockId);
        }
    });
// ▲▲▲ 粘贴结束 ▲▲▲
// ==========================================================
// =========== ▲▲▲ 股票 + 彩票 核心功能函数 END ▲▲▲ =========
// ==========================================================
// =========== ▼▼▼ 粘贴这个全新的函数 ▼▼▼ ============
// ==========================================================
// ▼▼▼ 使用这个【V2 - 支持群聊版】完整替换旧的 openForwardChatModal 函数 ▼▼▼

/**
 * 【全新】打开聊天记录转发模态框
 * (复用了 帖子转发 的弹窗)
 */
async function openForwardChatModal() {
    const { selectedMessageIds } = editModeState;
    if (selectedMessageIds.size === 0) {
        return alert('请先选择要转发的消息。');
    }

    const sourceContact = state.contacts.find(c => c.id === state.activeChatId);
    if (!sourceContact) return;

    // 1. 关键：获取所有被选中的消息，并按【时间戳】排序
    const messagesToForward = Array.from(selectedMessageIds)
        .map(msgId => sourceContact.history.find(m => m.id === msgId))
        .filter(Boolean) // 过滤掉未找到的消息
        .sort((a, b) => a.timestamp - b.timestamp); // 确保按时间顺序

    // 2. 复用你现有的“转发”弹窗
    const modal = document.getElementById('repost-contact-picker-modal');
    const contactListEl = document.getElementById('repost-contact-list');
    const messageInput = document.getElementById('repost-message-input');
    
    messageInput.value = ''; // 清空留言
    contactListEl.innerHTML = ''; // 清空列表

    // 3. 填充联系人列表 (✨ 核心修改点在这里 ✨)
    state.contacts.forEach(contact => {
        // --- 核心修改：我们现在只排除当前所在的聊天，不再排除群聊 ---
        if (contact.id === state.activeChatId) return; 

        // --- 新增：智能判断头像 ---
        let avatarHTML = '';
        let imgSrc = '';
        let isDefaultGroupIcon = false;

        if (contact.isGroup) {
            if (contact.avatar) {
                // A. 群聊有自定义头像
                imgSrc = contact.avatar;
            } else {
                // B. 群聊使用默认图标
                isDefaultGroupIcon = true;
                avatarHTML = `<div style="width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background-color: #f0f2f5; color: var(--theme-primary); font-size: 20px;">
                                <i class="fas fa-users"></i>
                              </div>`;
            }
        } else {
            // C. 私聊
            imgSrc = contact.avatar || `https://via.placeholder.com/40/DDD/666?text=${contact.name.substring(0,1)}`;
        }

        // 如果不是B情况 (即是私聊或有头像的群聊)，就统一使用 <img> 标签
        if (!isDefaultGroupIcon) {
            avatarHTML = `<img src="${imgSrc}" alt="${contact.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">`;
        }
        
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.innerHTML = `
            <input type="checkbox" id="forward-contact-check-${contact.id}" value="${contact.id}">
            <label for="forward-contact-check-${contact.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                ${avatarHTML}
                <span style="${isDefaultGroupIcon ? 'margin-left: 10px;' : ''}">${contact.name}</span>
            </label>
        `;
        contactListEl.appendChild(item);
    });
    
    modal.style.display = 'flex';

    // 4. 为“确认”按钮绑定一次性事件 (这部分逻辑你原来就写对了，它天生支持群聊)
    document.getElementById('close-repost-modal').onclick = () => modal.style.display = 'none';
    
    const confirmBtn = document.getElementById('confirm-repost-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true); 
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

    newConfirmBtn.addEventListener('click', async () => {
        const selectedContactIds = Array.from(contactListEl.querySelectorAll('input:checked')).map(input => input.value);
        if (selectedContactIds.length === 0) {
            return alert('请至少选择一个联系人或群聊'); // (修改了提示文本)
        }
        
        const accompanyingMessage = messageInput.value.trim();

        // 5. 【核心】将多条消息和上下文打包成一个对象
        const forwardData = {
            sourceChatName: sourceContact.isGroup ? `群聊 "${sourceContact.name}"` : `与 ${sourceContact.name} 的聊天`,
            messages: messagesToForward, 
            participants: {}
        };

        // 6. 填充参与者信息 (✨ 升级：确保能找到NPC的名字 ✨)
        forwardData.participants['myProfile'] = { name: state.myProfile.name };
        forwardData.participants['user'] = { name: state.myProfile.name }; // 兼容旧数据
        
        if (sourceContact.isGroup) {
            // 遍历群成员ID
            sourceContact.members.forEach(id => {
                if (!forwardData.participants[id]) {
                    // 优先从联系人列表找
                    let memberProfile = state.contacts.find(c => c.id === id);
                    // 如果没找到 (说明是NPC)，就从群的NPC列表里找
                    if (!memberProfile && sourceContact.npcMembers) {
                        memberProfile = sourceContact.npcMembers.find(npc => npc.id === id);
                    }
                    if(memberProfile) forwardData.participants[id] = { name: memberProfile.name };
                }
            });
        } else {
            forwardData.participants[sourceContact.id] = { name: sourceContact.name };
        }

        // 7. 循环发送给所有选中的会话
        for (const recipientId of selectedContactIds) {
            // 这一步能同时找到联系人和群聊
            const recipientContact = state.contacts.find(c => c.id === recipientId); 
            if (!recipientContact) continue;

            // 发送这条【新类型】的消息
            await createAndAddMessage({
                type: 'chat_history_share',
                content: forwardData
            }, 'user', recipientContact, false, 'chat');

            if (accompanyingMessage) {
                await createAndAddMessage({
                    type: 'text',
                    content: accompanyingMessage
                }, 'user', recipientContact, false, 'chat');
            }
        }
        
        modal.style.display = 'none';
        alert(`已成功转发给 ${selectedContactIds.length} 个会话！`); // (修改了提示文本)
        await exitEditMode();
        
    }, { once: true });
}

// ▲▲▲ 替换到这里结束 ▲▲▲

// ==========================================================
let editingCategoryId = null; // 用于跟踪正在编辑的分类ID

/**
 * (新) 显示论坛板块管理页面
 */
async function showForumCategoryScreen() {
    hideAllScreens();
    document.getElementById('forum-category-management-screen').style.display = 'flex';
    await renderForumCategories();
}

/**
 * (新) 渲染所有自定义板块列表
 */
async function renderForumCategories() {
    const listEl = document.getElementById('category-list');
    const noCategoryMsg = document.getElementById('no-category-message');
    listEl.innerHTML = '';

    if (state.forumCategories.length === 0) {
        noCategoryMsg.style.display = 'block';
    } else {
        noCategoryMsg.style.display = 'none';
        state.forumCategories.forEach(category => {
            const item = document.createElement('div');
            item.className = 'preset-item';
            item.dataset.categoryId = category.id;
            item.innerHTML = `
                <div class="preset-info">
                    <div class="preset-name">${category.name}</div>
                    <div class="preset-desc">${category.description}</div>
                </div>
                <div class="preset-actions">
                    <span class="preset-action-btn edit-category-btn" title="编辑板块"><i class="fas fa-edit"></i></span>
                    <span class="preset-action-btn delete delete-category-btn" title="删除板块"><i class="fas fa-trash-alt"></i></span>
                </div>
            `;
            listEl.appendChild(item);
        });
    }
}

/**
 * (新) 打开添加/编辑板块的弹窗
 */
function openCategoryModal(category = null) {
    const modal = document.getElementById('add-category-modal');
    if (category) {
        // 编辑模式
        editingCategoryId = category.id;
        document.getElementById('category-modal-title').textContent = '编辑板块';
        document.getElementById('category-id-input').value = category.id;
        document.getElementById('category-name-input').value = category.name;
        document.getElementById('category-description-input').value = category.description;
    } else {
        // 添加模式
        editingCategoryId = null;
        document.getElementById('category-modal-title').textContent = '添加新板块';
        document.getElementById('category-id-input').value = '';
        document.getElementById('category-name-input').value = '';
        document.getElementById('category-description-input').value = '';
    }
    modal.style.display = 'flex';
}

/**
 * (新) 保存板块（添加或编辑）
 */
async function saveForumCategory() {
    const name = document.getElementById('category-name-input').value.trim();
    const description = document.getElementById('category-description-input').value.trim();
    if (!name || !description) {
        alert('请填写板块名称和描述！');
        return;
    }

    if (editingCategoryId) {
        // 编辑
        const category = state.forumCategories.find(c => c.id === editingCategoryId);
        if (category) {
            category.name = name;
            category.description = description;
            await kokoMemory.put('forumCategories', category);
        }
    } else {
        // 新增
        const newCategory = {
            id: 'category_' + Date.now(),
            name: name,
            description: description
        };
        state.forumCategories.push(newCategory);
        await kokoMemory.put('forumCategories', newCategory);
    }
    
    await renderForumCategories(); // 刷新列表
    document.getElementById('add-category-modal').style.display = 'none';
}

/**
 * (新) 删除板块
 */
async function deleteForumCategory(categoryId) {
    const category = state.forumCategories.find(c => c.id === categoryId);
    if (!category) return;
    
    const confirmed = await showCustomConfirm('删除板块', `确定要删除“${category.name}”吗？\n（这不会删除该板块下的帖子）`, true);
    if (confirmed) {
        state.forumCategories = state.forumCategories.filter(c => c.id !== categoryId);
        await kokoMemory.delete('forumCategories', categoryId);
        await renderForumCategories(); // 刷新列表
    }
}

// ▲▲▲ 新函数粘贴到这里结束 ▲▲▲
// =========== ▲▲▲ 粘贴到这里结束 ▲▲▲ ===================
// ==========================================================
// ==========================================================
// ▼▼▼ 把下面所有新函数，都粘贴到 initApp 函数的前面 ▼▼▼
async function showSnoopApiSettingsScreen() {
    hideAllScreens();
    document.getElementById('snoop-api-settings-screen').style.display = 'flex';
    // 用保存的数据填充输入框
    document.getElementById('snoop-api-key-input').value = state.snoopApiSettings.apiKey;
    document.getElementById('snoop-api-endpoint-input').value = state.snoopApiSettings.endpoint;
    // 更新模型下拉框
    updateModelDropdown([state.snoopApiSettings.model], document.getElementById('snoop-model-select'), state.snoopApiSettings.model);
}
// =========================================
// 🎵 AI 专用 - 静默搜歌工具 🎵
// =========================================
async function fetchSongForAI(searchKeyword) {
    // 1. 自动使用内置的代理地址
    const apiBase = BUILTIN_MUSIC_API;
    if (!apiBase) {
        console.error("AI 搜歌失败：内置 API 地址丢失！");
        return null; // 静默失败
    }

    try {
        // 2. 第一步：用关键词搜索，拿到歌曲列表
        const searchResponse = await fetch(`${apiBase}?word=${encodeURIComponent(searchKeyword)}`);
        const searchData = await searchResponse.json();

        if (searchData.code !== 200 || !Array.isArray(searchData.data) || searchData.data.length === 0) {
            console.error("AI 搜歌失败：vkeys 未返回有效结果。", searchData);
            return null;
        }

        // 3. 智能选择：我们就选第一个（最匹配的）结果
        const bestMatch = searchData.data[0];
        const songId = bestMatch.id;

        // 4. 第二步：用 ID 去获取详情 (URL 和 歌词)
        const detailUrl = `${apiBase}?id=${songId}`;
        const lyricUrl = `${apiBase}?type=lyric&id=${songId}&lv=1&kv=1&tv=-1`;

        const [detailRes, lyricRes] = await Promise.all([
            fetch(detailUrl),
            fetch(lyricUrl)
        ]);

        const detailData = await detailRes.json();
        const lyricData = await lyricRes.json().catch(e => ({})); // 容错

        if (detailData.code !== 200 || !detailData.data || !detailData.data.url) {
            console.error("AI 搜歌失败：无法获取详情 (可能是VIP)。", detailData);
            return null;
        }

        // 5. 提取歌词
        let lyricText = (lyricData.lrc && lyricData.lrc.lyric) ? lyricData.lrc.lyric : "";

        // 6. 组装成一个完整的 "song" 对象并返回
        const song = detailData.data;
        return {
            title: song.song,
            artist: song.singer,
            url: song.url,
            lrc: lyricText
        };

    } catch (error) {
        console.error("AI 搜歌时发生严重错误:", error);
        return null;
    }
}
// ==========================================================
// =========== ▼▼▼ 自动回复核心功能模块 ▼▼▼ ============
// ==========================================================

// 函数：显示自动回复设置页面
async function showAutomationScreen() {
    hideAllScreens();
    document.getElementById('automation-screen').style.display = 'flex';
    
    // 用当前保存的设置填充UI
    const settings = state.automationSettings;
    document.getElementById('automation-enabled-toggle').checked = settings.isEnabled;
    document.getElementById('automation-interval-input').value = settings.interval;
    document.getElementById('automation-min-replies-input').value = settings.minReplies;
    document.getElementById('automation-max-replies-input').value = settings.maxReplies;

    await renderAutomationContactList();
    updateAutomationStatusIndicator();
}

// 函数：渲染可供选择的联系人列表
async function renderAutomationContactList() {
    const listEl = document.getElementById('automation-contact-list');
    listEl.innerHTML = '';
    const selectedIds = new Set(state.automationSettings.selectedContactIds);

    state.contacts.forEach(contact => {
        if (contact.isGroup) return; // 自动回复不支持群聊

        const isChecked = selectedIds.has(contact.id);
        const item = document.createElement('div');
        item.className = 'world-book-item'; // 复用样式
        item.innerHTML = `
            <input type="checkbox" class="world-book-checkbox" id="auto-contact-${contact.id}" value="${contact.id}" ${isChecked ? 'checked' : ''}>
            <label for="auto-contact-${contact.id}" class="world-book-name">${contact.name}</label>
        `;
        listEl.appendChild(item);
    });
}

// 函数：保存自动回复的设置
async function saveAutomationSettings() {
    const newSettings = {
        isEnabled: document.getElementById('automation-enabled-toggle').checked,
        interval: parseInt(document.getElementById('automation-interval-input').value, 10) || 300,
        minReplies: parseInt(document.getElementById('automation-min-replies-input').value, 10) || 1,
        maxReplies: parseInt(document.getElementById('automation-max-replies-input').value, 10) || 2,
        selectedContactIds: Array.from(document.querySelectorAll('#automation-contact-list input:checked')).map(cb => cb.value)
    };
    
    state.automationSettings = newSettings;

    // 将设置保存到数据库
    const userSettings = await kokoMemory.get('userSettings', 'main') || { id: 'main' };
    userSettings.automationSettings = newSettings;
    await kokoMemory.put('userSettings', userSettings);

    alert('设置已保存！');

    // 根据新设置决定是开启还是关闭定时器
    if (newSettings.isEnabled) {
        startAutomationTimer();
    } else {
        stopAutomationTimer();
    }
    updateAutomationStatusIndicator();
}

// 函数：启动定时器
function startAutomationTimer() {
    stopAutomationTimer(); // 先停止旧的，防止重复
    
    if (!state.automationSettings.isEnabled || state.automationSettings.selectedContactIds.length === 0) {
        return;
    }

    const intervalSeconds = state.automationSettings.interval;
    automationTimer = setInterval(runAutomationCycle, intervalSeconds * 1000);
    
    // ✨ 新增：在这里手动设置下一次执行的时间戳
    nextAutomationTimestamp = Date.now() + intervalSeconds * 1000;
    
    console.log(`自动回复已启动，每 ${intervalSeconds} 秒检查一次。`);
}

// 函数：停止定时器
function stopAutomationTimer() {
    if (automationTimer) {
        clearInterval(automationTimer);
        automationTimer = null;
        nextAutomationTimestamp = 0;
        console.log("自动回复已停止。");
    }
    updateAutomationStatusIndicator();
}

// 函数：更新状态指示器（显示倒计时）
function updateAutomationStatusIndicator() {
    const indicator = document.getElementById('automation-status-indicator');
    if (!indicator) return;

    if (!state.automationSettings.isEnabled) {
        indicator.textContent = '当前已关闭';
        return;
    }
    
    if (nextAutomationTimestamp > 0) {
        const now = Date.now();
        const remainingSeconds = Math.round((nextAutomationTimestamp - now) / 1000);
        if (remainingSeconds > 0) {
            indicator.textContent = `运行中... 下次检查还剩 ${remainingSeconds} 秒`;
        } else {
            indicator.textContent = '正在检查中...';
        }
    } else {
        indicator.textContent = '运行中...';
    }
}

// ... 函数开头 ...
async function runAutomationCycle() {
    const settings = state.automationSettings;
    if (!settings.isEnabled || settings.selectedContactIds.length === 0) {
        stopAutomationTimer();
        return;
    }
    
    nextAutomationTimestamp = Date.now() + settings.interval * 1000;
    console.log("开始执行自动回复周期...");

    // 1. 筛选出所有“有资格”被自动回复的角色
    //    核心修改：过滤掉当前正在聊天的角色！
    const eligibleContacts = settings.selectedContactIds.filter(id => id !== state.activeChatId);

    if (eligibleContacts.length === 0) {
        console.log("没有符合条件的自动回复目标（可能正在与唯一的目标聊天），跳过本次周期。");
        return; // 如果过滤后没人可选了，就直接结束
    }

    // 2. 从“有资格”的角色中随机挑选“幸运儿”
    const shuffled = [...eligibleContacts].sort(() => 0.5 - Math.random());
    const replyCount = Math.floor(Math.random() * (settings.maxReplies - settings.minReplies + 1)) + settings.minReplies;
    const targets = shuffled.slice(0, replyCount);

    if (targets.length === 0) {
        console.log("本次没有选中任何目标，跳过。");
        return;
    }
    // ... 后续代码 ...
    
    // 2. 收集情报，构建“剧本”
    const myProfile = state.myProfile;
    let characterDossiers = '';
    const targetProfiles = [];

    for (const contactId of targets) {
        const contact = state.contacts.find(c => c.id === contactId);
        if (!contact) continue;
        targetProfiles.push(contact);

        let recentChatHistory = '(最近没有私聊记录)';
        if (contact.history && contact.history.length > 0) {
            recentChatHistory = contact.history
                .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction')
                .slice(-40) // 读取最近40条
                .map(msg => `    ${msg.sender === 'user' ? myProfile.name : contact.name}: ${msg.content}`)
                .join('\n');
        }
        
        // 核心新增：先获取当前角色对应的用户人设，如果没设置就给个默认值
const userPersonaForThisChar = contact.userPersona || '(用户未设置特定人设)';

characterDossiers += `
- 角色名: ${contact.name}
  - 核心人设: ${contact.persona.replace(/\n/g, ' ')}
  - 用户“${myProfile.name}”在你眼中的人设: ${userPersonaForThisChar.replace(/\n/g, ' ')}// 把时间指令插入到档案里
  - [与“${myProfile.name}”的近期私聊参考 (重要)]
    \`\`\`
${recentChatHistory}
    \`\`\`
`;
    }

    if (targetProfiles.length === 0) return;

    // ✅ 正确的代码
const prompt = `[SYSTEM] 你是一个顶级的AI虚拟互动总监。
你的任务是：基于下方提供的角色档案和他们与用户的聊天记录，判断哪些角色现在最适合主动给用户发送一条消息，并为他们生成一段符合人设的、自然的回复。

[角色档案与聊天记录]
---
${characterDossiers}
---

[核心规则]
1.  **判断时机**: 仔细分析每个角色的聊天记录。如果对话刚刚结束，或者用户明显不想聊了，就不要生成回复。只有当对话处于暂停状态、或者有明显可以延续的话题时，才生成回复。
2.  **内容自然**: 回复必须像是角色“突然想起来”某件事，或者对之前的话题有了新的想法。避免生硬的问候。
3.  **允许多句话**: 你的回复可以包含多句话，模仿真实的人类聊天习惯。请使用换行符来分隔每一句话。
4.  **严格遵守格式**: 对于你决定要回复的每个角色，都必须严格使用以下格式。如果决定某个角色不回复，就不要为他生成任何内容。

// --- 核心新增部分 ---
[特殊指令格式]
除了纯文本，你还可以在 CONTENT 中使用以下指令来发送特殊消息：
- 语音: [voice:你想用语音说的文字内容]
- 图片: [picture:你想要发送的图片的文字描述]
- 表情包: [sticker:表情名]
// --- 新增结束 ---
// ✨ 新增一个“可用表情包列表”的区域 ✨
[可用表情包列表]
{{emoticon_list}}

[输出格式]
MESSAGE_START
SPEAKER: [角色名]
CONTENT: [该角色说的【可以包含换行的多句话】内容，也可以包含特殊指令]
MESSAGE_END
`;

    // ✨ 新增：把表情包列表填充到Prompt里
    const finalPrompt = prompt.replace('{{emoticon_list}}', state.emoticons.map(e => `'${e.name}'`).join('， ') || '（无）');

    // 3. 调用AI大脑 (注意：这里要用我们新创建的 finalPrompt)
    const rawResponse = await generateAiResponse(null, [], finalPrompt, false, 'chat');

    // 4. 解析剧本，精准投递
    const messageRegex = /MESSAGE_START\s*SPEAKER:\s*(.*?)\s*CONTENT:\s*([\s\S]*?)\s*MESSAGE_END/g;
    const matches = Array.from(rawResponse.matchAll(messageRegex));

    for (const match of matches) {
        const speakerName = match[1].trim();
        const content = match[2].trim();
        
        const speakerProfile = targetProfiles.find(p => p.name === speakerName);
        
// ✅✅✅ 最终的、完美的正确代码 ✅✅✅
if (speakerProfile && content) {
    console.log(`为 ${speakerName} 生成回复: ${content}`);
    
    // 1. 仍然是按换行符分割消息
    const messages = content.split('\n').filter(line => line.trim() !== '');

    // 2. 使用 forEach 循环，这样我们可以拿到句子的索引 (index)
    messages.forEach(async (line, index) => {
        // 3. 判断当前是不是第一句话，这个逻辑保留
        const isFirstLine = (index === 0);

        // 4. 【核心新增】把 processAndDisplayAiResponse 的菜谱搬到这里来！
        let processed = false;
        const commandRegex = /\[(sticker|voice|picture|red_packet|transfer|transfer_to|music|spin_wheel|claim_red_packet|location|create_location)(?::([^\]]*))?\]/;
        const commandMatch = line.match(commandRegex);

        if (commandMatch) {
            processed = true;
            const command = commandMatch[1];
            const value = commandMatch[2] || '';
            switch (command) {
                case 'voice': {
                    const duration = Math.max(1, Math.round(value.length / 4));
                    await createAndAddMessage({ type: 'voice', content: { text: value, duration: duration } }, speakerProfile.id, speakerProfile, isFirstLine, 'chat');
                    break;
                }
// ... 省略了其他case ...
case 'sticker':
    const emoticon = state.emoticons.find(e => e.name === value.trim());
    if (emoticon) {
        // 正确的版本：明确指定发送者是 speakerProfile.id，目标窗口是 speakerProfile
        await createAndAddMessage({ type: 'image', url: emoticon.url, isEmoticon: true, emoticonName: emoticon.name }, speakerProfile.id, speakerProfile, isFirstLine, 'chat');
    } else {
        // 这里也一并修正
        await createAndAddMessage({ type: 'text', content: `[发送表情失败: ${value}]` }, speakerProfile.id, speakerProfile, isFirstLine, 'chat');
    }
    break;
// ... 省略了其他case ...
                case 'picture': {
                    await createAndAddMessage({ type: 'picture_description', content: { description: value } }, speakerProfile.id, speakerProfile, isFirstLine, 'chat');
                    break;
                }
                // 你可以根据需要，把 processAndDisplayAiResponse 里的其他 case (如 sticker, music 等) 也复制到这里
                // 来让自动回复支持更多功能！
            }
        }

        // 5. 如果不是任何特殊指令，就当作普通文本处理
        if (!processed) {
            await createAndAddMessage({ type: 'text', content: line }, speakerProfile.id, speakerProfile, isFirstLine, 'chat');
        }

        // 6. 加入延迟，让对话看起来更自然
        await sleep(800 + Math.random() * 500);
    });
}
    }
}

// ==========================================================

// =========== ▲▲▲ 自动回复核心功能模块 END ▲▲▲ =========
// 全局变量，用于管理语音播放队列
let isPlayingVoice = false;
const voiceQueue = [];

/**
 * 将语音任务添加到队列，并触发处理
 */
async function playNextInQueue(text, contact) { // 将 voiceId 改为 contact
    voiceQueue.push({ text, contact }); // 保存整个 contact 对象
    if (!isPlayingVoice) {
        processVoiceQueue();
    }
}

/**
 * 递归处理语音队列，确保一次只播放一个
 */
async function processVoiceQueue() {
    if (voiceQueue.length === 0) {
        isPlayingVoice = false;
        return;
    }

    isPlayingVoice = true;
    const { text, contact } = voiceQueue.shift(); // 将 voiceId 改为 contact // 取出队列的第一个任务

    try {
        // 等待 playVoiceMessage 函数播放完成
        await playVoiceMessage(text, contact); // 传入整个 contact 对象
    } catch (error) {
        console.error("视频通话语音播放失败:", error);
    } finally {
        // 不管成功或失败，都继续处理队列里的下一个任务
        processVoiceQueue();
    }
}
/**
 * 调用 MiniMax API 将文本转换为语音并返回一个 Promise，该 Promise 在播放结束时解析
 * @param {string} textToSpeak - 要转换的文字
 * @param {string} voiceId - MiniMax 的音色 ID
 * @returns {Promise<void>}
 */
// ▼▼▼ 使用这个【V2 - 支持用户语音版】，完整替换旧的 playVoiceMessage 函数 ▼▼▼
function playVoiceMessage(textToSpeak, contact, senderType = 'contact') { // 1. 新增 senderType 参数
    return new Promise((resolve, reject) => {
        if (!contact) {
            console.warn("playVoiceMessage 收到无效的 contact 对象，跳过播放。");
            return resolve();
        }

        // --- 2. 智能决策：决定使用谁的语音配置 ---
        let voiceProvider, voiceId, roleName;
        
        if (senderType === 'user') {
            // 如果是播放用户（你）的声音
            voiceProvider = contact.userVoiceProvider;
            voiceId = contact.userVoiceId;
            roleName = state.myProfile.name;
        } else {
            // 否则，播放AI的声音（默认）
            voiceProvider = contact.voiceProvider;
            voiceId = contact.voiceId;
            roleName = contact.name;
        }
        // --- 决策结束 ---

        if (!voiceId || !voiceProvider) {
            console.warn(`角色 ${roleName} (类型: ${senderType}) 未配置音色ID或服务商，跳过语音播放。`);
            return resolve();
        }

        const audioPlayer = document.getElementById('voice-message-player');
        
        // --- 3. 调度中心 (使用新变量) ---
        if (voiceProvider === 'minimax') {
            const { minimaxGroupId, minimaxApiKey } = state.apiSettings;
            if (!minimaxGroupId || !minimaxApiKey) {
                console.warn("MiniMax Group ID 或 API Key 未配置，无法播放语音。");
                return resolve();
            }

            fetch(`https://api.minimax.chat/v1/text_to_speech?GroupId=${minimaxGroupId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${minimaxApiKey}` },
                body: JSON.stringify({
                    "voice_id": voiceId, // <-- 使用新变量
                    "text": textToSpeak,
                    "model": "speech-01", "speed": 1.0, "vol": 1.0, "pitch": 0
                })
            })
            .then(response => {
                if (!response.ok) return response.json().then(err => { throw new Error(err.base_resp?.status_msg || 'MiniMax TTS API请求失败') });
                return response.arrayBuffer();
            })
            .then(getAudioAndPlay)
            .catch(handleAudioError);

        } else if (voiceProvider === 'siliconflow') {
            const { siliconflowApiKey } = state.apiSettings;
            if (!siliconflowApiKey) {
                console.warn("SiliconFlow API Key 未配置，无法播放语音。");
                return resolve();
            }

            fetch(`https://api.siliconflow.cn/v1/audio/speech`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${siliconflowApiKey}` },
                body: JSON.stringify({
                    "model": "FunAudioLLM/CosyVoice2-0.5B",
                    "voice": voiceId, // <-- 使用新变量
                    "input": textToSpeak,
                    "response_format": "mp3"
                })
            })
            .then(response => {
                if (!response.ok) return response.json().then(err => { throw new Error(err.error?.message || 'SiliconFlow TTS API请求失败') });
                return response.arrayBuffer();
            })
            .then(getAudioAndPlay)
            .catch(handleAudioError);
        } else {
            console.warn(`未知的语音服务商: ${voiceProvider}`);
            resolve();
        }

        // --- 辅助函数 (保持不变) ---
        function getAudioAndPlay(audioData) {
            const blob = new Blob([audioData], { type: 'audio/mpeg' });
            const audioUrl = URL.createObjectURL(blob);
            audioPlayer.src = audioUrl;
            audioPlayer.play();
            audioPlayer.onended = () => { URL.revokeObjectURL(audioUrl); resolve(); };
            audioPlayer.onerror = (e) => { URL.revokeObjectURL(audioUrl); reject(e); };
        }

        function handleAudioError(error) {
            console.error('播放语音消息失败:', error);
            reject(error);
        }
    });
}
// ==========================================================
// --- 新增：辅助函数，用于更新拉黑按钮的UI ---
function updateBlockButtonText(blockedStatus) {
    const blockButton = document.getElementById('block-contact-btn-menu');
    if (!blockButton) return;

    const icon = blockButton.querySelector('i');
    const span = blockButton.querySelector('span');

    if (blockedStatus === 'user_blocked_ai') {
        span.textContent = '解除拉黑';
        icon.className = 'fas fa-check fa-fw';
        blockButton.style.pointerEvents = 'auto'; // 允许点击
    } else if (blockedStatus === 'ai_blocked_user') {
        span.textContent = '已被对方拉黑';
        icon.className = 'fas fa-exclamation-circle fa-fw';
        blockButton.style.pointerEvents = 'none'; // 不允许用户解除
    } else {
        span.textContent = '拉黑TA';
        icon.className = 'fas fa-ban fa-fw';
        blockButton.style.pointerEvents = 'auto';
    }
}
// ==========================================================
// =========== ▼▼▼ 新增：聊天输入框锁定/解锁辅助函数 ▼▼▼ ====
// ==========================================================
/**
 * 根据拉黑状态，更新聊天输入框的UI
 * @param {'none' | 'user_blocked_ai' | 'ai_blocked_user'} blockedStatus
 */
function updateChatInputLockState(blockedStatus) {
    const inputArea = document.getElementById('chat-input-area');
    const messageInput = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');
    const requestBtn = document.getElementById('request-reply-btn');
    const emojiBtn = document.getElementById('emoji-btn');
    const attachBtn = document.getElementById('attachment-btn');

    if (!inputArea || !messageInput || !sendBtn || !requestBtn || !emojiBtn || !attachBtn) {
        console.warn("无法找到所有聊天输入框元素来进行锁定/解锁。");
        return;
    }

    if (blockedStatus === 'user_blocked_ai') {
        inputArea.style.opacity = '0.7';
        messageInput.disabled = true;
        messageInput.placeholder = "你已拉黑对方，无法发送消息。";
        sendBtn.style.display = 'none';
        requestBtn.style.display = 'none';
        emojiBtn.style.pointerEvents = 'none';
        attachBtn.style.pointerEvents = 'none';
    } else if (blockedStatus === 'ai_blocked_user') {
        inputArea.style.opacity = '0.7';
        messageInput.disabled = true;
        messageInput.placeholder = "你已被对方拉黑，无法发送消息。";
        sendBtn.style.display = 'none';
        requestBtn.style.display = 'none';
        emojiBtn.style.pointerEvents = 'none';
        attachBtn.style.pointerEvents = 'none';
    } else { // 状态为 'none' (正常)
        inputArea.style.opacity = '1';
        messageInput.disabled = false;
        messageInput.placeholder = "输入消息...";
        sendBtn.style.display = 'flex'; // 恢复按钮显示
        requestBtn.style.display = 'flex';
        emojiBtn.style.pointerEvents = 'auto';
        attachBtn.style.pointerEvents = 'auto';
    }
}
// ==========================================================
// =========== ▲▲▲ 新增辅助函数结束 ▲▲▲ ===================
// ==========================================================
// (粘贴到 initApp 函数的前面)

// --- ✨ 收藏夹功能模块 V2 (按“收藏次序”分组) ✨ ---

/**
 * (V2) 显示收藏夹页面
 */
async function showFavoritesScreen() {
    hideAllScreens();
    document.getElementById('favorites-screen').style.display = 'flex';
    await renderFavoritesList(); // 调用新的渲染函数
}

/**
 * (V2 - 核心重写) 渲染收藏夹列表
 */
async function renderFavoritesList() {
    const listEl = document.getElementById('favorites-content-list');
    listEl.innerHTML = ''; // 清空旧内容
    const allFavoriteSessions = await kokoMemory.getAll('favorites');

    if (allFavoriteSessions.length === 0) {
        listEl.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-star" style="font-size: 48px; margin-bottom: 15px;"></i><p>你的收藏夹是空的。</p><p>在聊天时进入“编辑模式”来收藏消息吧！</p></div>`;
        return;
    }

    // 1. ✨ 核心逻辑：直接按收藏时间排序，最新的在最上面
    allFavoriteSessions.sort((a, b) => b.timestamp - a.timestamp);

    // 2. 遍历所有“收藏会话”，一个会话 = 一个卡片
    for (const session of allFavoriteSessions) {
        const contactInfo = session.contactProfile; // 获取快照
        const groupCard = document.createElement('div');
        groupCard.className = 'favorite-group-card';
        
        let itemsHTML = '';
        
        // 3. 遍历这个“会话”里的每一条消息
        for (const fav of session.messages) {
            const senderInfo = fav.senderProfile;
            const message = fav.message;
            let contentHTML = '';

            // --- (这里是我们上次修改的 V3 版消息渲染逻辑) ---
            switch(message.type) {
                case 'text':
                    let formattedContent = message.content.replace(/\n/g, '<br>');
                    formattedContent = formattedContent.replace(/\{(.*?)\}/g, '<span class="narrative-psychology">$1</span>');
                    formattedContent = formattedContent.replace(/(?:&quot;|“|”|＂)(.*?)(?:&quot;|“|”|＂)/g, '<span class="narrative-speech">“$1”</span>');
                    formattedContent = formattedContent.replace(/\*(.*?)\*/g, '<span class="narrative-action">$1</span>');
                    contentHTML = formattedContent;
                    break;
                case 'html':
                    contentHTML = message.content; // 直接渲染HTML
                    break;
                case 'picture_description':
                    contentHTML = `[图片] <i>${message.content.description}</i>`;
                    break;
                case 'voice':
                    contentHTML = `[语音] <i>“${message.content.text}”</i>`;
                    break;
                case 'image':
                case 'uploaded_image':
                    const imgUrl = message.type === 'image' ? message.url : message.content.base64;
                    contentHTML = `<img src="${imgUrl}" style="max-width: 150px; max-height: 150px; border-radius: 8px;">`;
                    break;
                case 'red_packet':
                    contentHTML = `[红包] <i>${message.content.blessing || '恭喜发财'}</i>`;
                    break;
                case 'transfer':
                    const transferData = message.content;
                    let status = '待处理';
                    if (transferData.returned) status = '已退还';
                    else if (transferData.completed) status = '已完成';
                    contentHTML = `[转账] <i>¥${transferData.amount} (${status})</i>`;
                    break;
                case 'music_share':
                    const music = message.content;
                    contentHTML = `[分享音乐] <i>${music.title} - ${music.artist || '未知艺术家'}</i>`;
                    break;
                case 'location_share':
                    const loc = message.content;
                    contentHTML = `[分享位置] <i class="${loc.icon || 'fas fa-map-marker-alt'}"></i> <i>${loc.name}</i>`;
                    break;
                case 'post_share':
                    contentHTML = `[分享的帖子] <i>(一条帖子分享)</i>`;
                    break;
                default:
                    contentHTML = `[${message.type} - 暂不支持预览]`;
            }
            // --- 渲染结束 ---
            
            itemsHTML += `
            <div class="favorite-item"> <div class="favorite-item-avatar">
                    <img src="${senderInfo.avatar}" alt="${senderInfo.name}">
                </div>
                <div class="favorite-item-content">
                    <div class="favorite-item-sender">${senderInfo.name}</div>
                    <div class="message-content">${contentHTML}</div>
                </div>
                </div>
            `;
        }

        // 4. ✨ 核心修改：构建卡片头部，包含删除按钮
        groupCard.innerHTML = `
        <div class="favorite-group-header">
            <img src="${contactInfo.avatar}" alt="${contactInfo.name}">
            <span class="name">来自 ${contactInfo.name} 的收藏</span>
            <span class="timestamp">${new Date(session.timestamp).toLocaleString()}</span>
            
            <span class="unfavorite-btn" data-session-id="${session.id}" title="删除此收藏组">
                <i class="fas fa-trash-alt"></i>
            </span>
        </div>
        <div class="favorite-items-container">
            ${itemsHTML}
        </div>
        `;
        listEl.appendChild(groupCard);
    }
}

/**
 * (V2 - 重命名) 删除一个收藏会话
 */
async function unfavoriteSession(sessionId) {
    const confirmed = await showCustomConfirm('删除收藏', '确定要删除这整组收藏记录吗？', true);
    if (confirmed) {
        await kokoMemory.delete('favorites', sessionId);
        await renderFavoritesList(); // 重新渲染列表
    }
}

/**
 * (V2 - 核心重写) 收藏选中的消息
 */
async function favoriteSelectedMessages() {
    const { selectedMessageIds } = editModeState;
    if (selectedMessageIds.size === 0) {
        return alert('请先选择要收藏的消息。');
    }

    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    let collectedMessages = [];

    // ✨ 核心：先把选中的消息，按它们在聊天中的原始顺序排好
    const messagesToSave = Array.from(selectedMessageIds)
        .map(msgId => contact.history.find(m => m.id === msgId))
        .filter(Boolean) // 过滤掉没找到的消息
        .filter(msg => msg.type !== 'system_notification' && msg.sender !== 'system_instruction') // 过滤掉系统消息
        .sort((a, b) => a.timestamp - b.timestamp); // ✨ 关键：按原始时间戳排序

    if (messagesToSave.length === 0) {
        return alert('所选消息均无法收藏 (例如系统通知)。');
    }

    // 遍历排序后的消息，收集数据
    for (const message of messagesToSave) {
        let senderProfile;
        if (message.sender === 'user') {
            senderProfile = { id: 'myProfile', name: state.myProfile.name, avatar: state.myProfile.avatar };
        } else if (contact.isGroup) {
            const sender = state.contacts.find(c => c.id === message.sender);
            senderProfile = sender ? { id: sender.id, name: sender.name, avatar: sender.avatar } : { id: 'unknown', name: '未知成员', avatar: 'https://via.placeholder.com/40' };
        } else {
            senderProfile = { id: contact.id, name: contact.name, avatar: contact.avatar };
        }
        
        collectedMessages.push({
            message: JSON.parse(JSON.stringify(message)), // 存储消息的完整副本
            senderProfile: senderProfile // 存储发送者的快照
        });
    }

    // ✨ 核心：创建一个“收藏会话”对象，只包含这一个数组
    const newFavoriteSession = {
        id: `fav_session_${Date.now()}`,
        contactId: contact.id, // 仍然记录是谁的
        contactProfile: { name: contact.name, avatar: contact.avatar }, // 存一个快照，方便显示
        timestamp: Date.now(), // 收藏这个“会话”的时间
        messages: collectedMessages // 包含所有消息的数组
    };

    // ✨ 核心：只向数据库添加这一个对象
    await kokoMemory.put('favorites', newFavoriteSession);
    
    alert(`成功收藏了 ${collectedMessages.length} 条消息！`);
    await exitEditMode(); // 收藏后自动退出编辑模式
}
// --- ✨ 收藏夹功能模块 V2 结束 ✨ ---
// (粘贴到 initApp 函数的 *上方*)

// ==========================================================
// =========== ▼▼▼ 新增：外观设置实时预览模块 ▼▼▼ ==========
// ==========================================================

/**
 * (新) 预览框的基础HTML结构
 * 这里包含了预览用的假气泡和按钮，以及用于接收CSS注入的<style>标签
 */
function getBasePreviewHTML() {
    // 关键：我们从主文档中“偷”出默认的叙事样式，作为预览框的基底
    const defaultNarrativeCSS = `
        .narrative-speech {
            background-color: #e6f5c9; padding: 2px 8px; border-radius: 8px; display: inline-block; margin: 1px 0;
        }
        .narrative-psychology {
            text-decoration: none; background-color: #e6f5c9; color: #66bb6a; padding: 2px 6px; border-radius: 6px; font-style: normal;
        }
        .narrative-action {
            font-style: normal; color: #517655;
        }
    `;

    return `
    <head>
        <style id="preview-style-base">
            body { margin: 0; padding: 10px; font-family: 'Nunito', sans-serif; transition: all 0.2s; background-color: #f0f2f5; background-size: cover; background-position: center; }
            .msg-wrapper { display: flex; margin-bottom: 8px; max-width: 80%; }
            .msg-wrapper.sent { margin-left: auto; flex-direction: row-reverse; }
            .avatar { width: 30px; height: 30px; border-radius: 4px; background: #ddd; margin: 0 5px; flex-shrink: 0; }
            .message { padding: 8px 12px; border-radius: 12px; word-break: break-word; }
            .message.received { background: #fff; border-top-left-radius: 4px; }
            .message.sent { background: var(--sent-message-bg, #e6f5c9); color: var(--text-dark, #424242); border-top-right-radius: 4px; }
            .theme-button { padding: 6px 12px; border-radius: 6px; border: none; font-weight: 600; cursor: pointer; background: var(--theme-primary, #81c784); color: var(--text-on-primary, #fff); }
        </style>
        <style id="preview-style-theme"></style>
        <style id="preview-style-bubbles"></style>
        <style id="preview-style-narrative">${defaultNarrativeCSS}</style>
        <style id="preview-style-font"></style>
        <style id="preview-style-fontsize"></style>
    </head>
    <body>
        <div class="msg-wrapper received">
            <div class="avatar"></div>
            <div class="message received">
                这是收到的消息气泡预览。
            </div>
        </div>
        <div class="msg-wrapper sent">
            <div class="avatar"></div>
            <div class="message sent">
                这是发送的消息气泡预览。
            </div>
        </div>
        <div class="msg-wrapper received">
            <div class="avatar"></div>
            <div class="message received">
                <span class="narrative-action">*这是叙事动作*</span> <span class="narrative-speech">“这是叙事对话”</span> <span class="narrative-psychology">{这是叙事心理}</span>
            </div>
        </div>
        <button class="theme-button">
            主题色按钮
        </button>
    </body>
    `;
}

/**
 * (新) 初始化预览框，写入基础HTML
 */
function initializePreviewFrame() {
    const iframe = document.getElementById('appearance-preview-frame');
    if (!iframe) return;
    const doc = iframe.contentDocument || iframe.contentWindow.document;
    doc.open();
    doc.write(getBasePreviewHTML());
    doc.close();
}

/**
 * (新) 从输入框加载当前设置，并更新到预览框
 */
function loadPreviewFromInputs() {
    // 此函数用于页面打开时，加载一次已保存的设置
    updatePreview('background', userSettings.chatBackground);
    updatePreview('theme', userSettings.customThemeCss);
    updatePreview('bubble', userSettings.customBubbleCss);
    updatePreview('narrative', userSettings.customNarrativeCss);
    updatePreview('fontsize', userSettings.customFontSize);
    updatePreview('font', userSettings.customFontName, userSettings.customFontUrl);
}

/**
 * (新) 实时更新预览框的样式
 * type: 'background', 'theme', 'bubble', 'narrative', 'font', 'fontsize'
 */
function updatePreview(type, value, value2 = '') {
    const iframe = document.getElementById('appearance-preview-frame');
    if (!iframe) return;
    const doc = iframe.contentDocument || iframe.contentWindow.document;
    if (!doc.body) return; // 确保iframe已加载

    switch (type) {
        case 'background':
            doc.body.style.backgroundImage = value ? `url(${value})` : 'none';
            break;
        case 'theme':
            doc.getElementById('preview-style-theme').textContent = value;
            break;
        case 'bubble':
            doc.getElementById('preview-style-bubbles').textContent = value;
            break;
        case 'narrative':
            const narrativeStyleTag = doc.getElementById('preview-style-narrative');
            if (value.trim()) {
                narrativeStyleTag.textContent = value; // 应用用户的CSS
            } else {
                narrativeStyleTag.textContent = getBasePreviewHTML().match(/<style id="preview-style-narrative">([\s\S]*?)<\/style>/)[1]; // 恢复默认
            }
            break;
        case 'font':
            const fontStyleTag = doc.getElementById('preview-style-font');
            const fontName = value; // value1 is name
            const fontUrl = value2; // value2 is url
            if (fontUrl && fontName) {
                fontStyleTag.textContent = `
                    @font-face {
                        font-family: '${fontName}';
                        src: url('${fontUrl}');
                    }
                `;
                doc.body.style.fontFamily = `'${fontName}', 'Nunito', sans-serif`;
            } else {
                fontStyleTag.textContent = '';
                doc.body.style.fontFamily = `'Nunito', sans-serif`;
            }
            break;
        case 'fontsize':
            const sizeStyleTag = doc.getElementById('preview-style-fontsize');
            if (value && !isNaN(value) && value >= 12) {
                sizeStyleTag.textContent = `
                    body, .message, .theme-button {
                        font-size: ${value}px !important;
                    }
                `;
            } else {
                sizeStyleTag.textContent = '';
            }
            break;
    }
}

// ==========================================================
// =========== ▲▲▲ 实时预览模块结束 ▲▲▲ ===================
// ==========================================================
// ▲▲▲ 粘贴到这里结束 ▲▲▲
        async function initApp() {
            await kokoMemory.init();
            await loadSnoopDataCache();
            await loadDataFromDB();
            await loadAppearanceSettings();
            await renderMyProfile(); 
            await renderContacts(); 
            await renderWorldBooks(); 
            await updateWorldBookSelectors(); 
            await renderUserPersonaPresets();
            await renderThoughtPresets();
            updateNotificationDots();
            renderAttachmentMenu();
            if (state.posts.length === 0 && isInitialPostLoad) {
                await showFeedScreen();
            }
            await showMainScreen();
            // ▼▼▼ 在函数的最后，添加这两行代码 ▼▼▼
            if (state.automationSettings.isEnabled) {
                startAutomationTimer();
            }
            showLockScreen();
            // ▲▲▲ 新代码添加结束 ▲▲▲
        }

        function renderPet(contact) {
            const container = document.getElementById('pet-container-wrapper');
            if (!contact) {
                container.innerHTML = '';
                return;
            }

            if (!contact.pet) {
                container.innerHTML = `
                    <div id="pet-container">
                        <div class="pet-header" style="justify-content:center;">我们的小窝</div>
                        <button class="form-button" id="adopt-pet-btn">领养一只史莱姆</button>
                    </div>`;
                return;
            }
            
            const now = Date.now();
            const elapsedHours = (now - contact.pet.lastUpdated) / (1000 * 60 * 60);
            const decayAmount = Math.floor(elapsedHours * 5); 
            
            if (decayAmount > 0) {
                contact.pet.hunger = Math.max(0, contact.pet.hunger - decayAmount);
                contact.pet.happiness = Math.max(0, contact.pet.happiness - decayAmount);
                contact.pet.cleanliness = Math.max(0, contact.pet.cleanliness - decayAmount);
                contact.pet.lastUpdated = now;
                kokoMemory.put('contacts', contact);
            }

            let isWorking = false;
            let workCooldownText = '';
            if (contact.pet.workFinishTimestamp && now < contact.pet.workFinishTimestamp) {
                isWorking = true;
                const remainingMinutes = Math.ceil((contact.pet.workFinishTimestamp - now) / (1000 * 60));
                workCooldownText = `工作中... (剩余${remainingMinutes}分钟)`;
            }

            container.innerHTML = `
                <div id="pet-container">
                    <div class="pet-header">
                        <span id="pet-name">${contact.pet.name} (LV.${contact.pet.level})</span>
                        <span id="pet-gold-display">💰 ${contact.gold_coins}</span>
                    </div>
                    <div class="pet-visual-area">
                        <div>
                            <div class="slime">
                                <div class="blush left"></div>
                                <div class="blush right"></div>
                            </div>
                            <div class="slime-shadow"></div>
                        </div>
                    </div>
                    <div class="pet-stats">
                        <div class="stat-bar-container" title="经验值: ${contact.pet.xp} / 100">
                            <span class="stat-bar-label">成长</span>
                            <div class="stat-bar"><div id="xp-bar" class="stat-bar-inner" style="background-color: #ffcc80;"></div></div>
                        </div>
                        <div class="stat-bar-container">
                            <span class="stat-bar-label">饱食度</span>
                            <div class="stat-bar"><div id="hunger-bar" class="stat-bar-inner"></div></div>
                        </div>
                        <div class="stat-bar-container">
                            <span class="stat-bar-label">开心值</span>
                            <div class="stat-bar"><div id="happiness-bar" class="stat-bar-inner"></div></div>
                        </div>
                         <div class="stat-bar-container">
                            <span class="stat-bar-label">清洁度</span>
                            <div class="stat-bar"><div id="cleanliness-bar" class="stat-bar-inner"></div></div>
                        </div>
                    </div>
                    <div class="pet-actions">
                        <button id="feed-pet-btn" class="pet-action-btn" ${isWorking ? 'disabled' : ''}>喂食 (-5💰)</button>
                        <button id="play-pet-btn" class="pet-action-btn" ${isWorking ? 'disabled' : ''}>玩耍</button>
                        <button id="clean-pet-btn" class="pet-action-btn" ${isWorking ? 'disabled' : ''}>清洁</button>
                        <button id="work-pet-btn" class="pet-action-btn" ${isWorking ? 'disabled' : ''}>${isWorking ? workCooldownText : '打工 (1小时)'}</button>
                    </div>
                </div>`;
            
            document.getElementById('xp-bar').style.width = `${contact.pet.xp}%`;
            document.getElementById('hunger-bar').style.width = `${contact.pet.hunger}%`;
            document.getElementById('happiness-bar').style.width = `${contact.pet.happiness}%`;
            document.getElementById('cleanliness-bar').style.width = `${contact.pet.cleanliness}%`;

            const slimeEl = container.querySelector('.slime');
            slimeEl.className = 'slime'; 
            if (contact.pet.form) {
                slimeEl.classList.add(`${contact.pet.form}-form`);
            }
            if (contact.pet.hunger < 40) slimeEl.classList.add('hungry');
            if (contact.pet.cleanliness < 40) slimeEl.classList.add('dirty');
        }

        function updateChatPetVisuals(contact) {
            const chatPetEl = document.querySelector('#chat-pet-container .slime');
            if (!chatPetEl || !contact || !contact.pet) return;
            
            chatPetEl.className = 'slime'; 
            if (contact.pet.form) {
                chatPetEl.classList.add(`${contact.pet.form}-form`);
            }
            if (contact.pet.hunger < 40) chatPetEl.classList.add('hungry');
            if (contact.pet.cleanliness < 40) chatPetEl.classList.add('dirty');
        }


        async function updatePetStats(stat, value, contact, isCharAction = false) {
            if (!contact || !contact.pet) return;
            contact.pet[stat] = Math.min(100, Math.max(0, contact.pet[stat] + value));
            if (!isCharAction) {
                contact.pet.lastUpdated = Date.now();
            }
            await kokoMemory.put('contacts', contact);
        }

        function findMentionsInComment(comment) {
            const mentionedContacts = new Set();
            if (!comment || !comment.content) return [];
            
            const mentionRegex = /@([\w\u4e00-\u9fa5]+)/g;
            let match;

            while ((match = mentionRegex.exec(comment.content)) !== null) {
                const username = match[1];
                const contact = state.contacts.find(c => c.name === username);
                if (contact) {
                    mentionedContacts.add(contact);
                }
            }
            return Array.from(mentionedContacts);
        }
        
        function handleAvatarUpload(callback) {
            const uploader = document.getElementById('avatar-uploader');
            uploader.click();

            uploader.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;

                if (file.size > 2 * 1024 * 1024) {
                    alert('图片太大了！请选择一张小于 2MB 的图片。');
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(event) {
                    const base64String = event.target.result;
                    callback(base64String);
                };
                
                reader.readAsDataURL(file);
                e.target.value = ''; 
            };
        }
        // 用这个新版本 替换掉 旧的 attachGroupSettingsListeners 函数
function attachGroupSettingsListeners() {
    // 用下面这行正确的代码替换它
document.getElementById('back-from-group-settings').addEventListener('click', () => {
    // 首先隐藏当前的设置屏幕
    document.getElementById('group-settings-screen').style.display = 'none';
    // 然后重新打开当前激活的聊天窗口（也就是你刚才所在的群聊）
    openChat(state.activeChatId); 
});
    
    // ▼▼▼ 新增：为“用户面具预设”下拉框添加功能 ▼▼▼
    document.getElementById('group-select-user-persona-preset').addEventListener('change', function() {
        const selectedPresetId = this.value;
        const preset = state.userPersonaPresets.find(p => p.id === selectedPresetId);
        document.getElementById('group-user-mask-textarea').value = preset ? preset.description : '';
    });

    // ▼▼▼ 新增：为全新的“保存”按钮添加功能 ▼▼▼
    document.getElementById('save-group-settings-btn').addEventListener('click', async () => {
        const group = state.contacts.find(c => c.id === state.activeChatId);
        if (!group) return;

        // 读取所有设置项的当前值
        group.userPersona = document.getElementById('group-user-mask-textarea').value.trim();
        group.memoryShared = document.getElementById('group-memory-share-toggle').checked;
        group.isTimeAware = document.getElementById('group-time-awareness-toggle').checked;
        group.worldBooks = Array.from(document.querySelectorAll('#group-world-book-selector-list .world-book-checkbox:checked')).map(cb => cb.value);

        // 保存到数据库
        await kokoMemory.put('contacts', group);
        alert('群聊设置已保存！');
        showCharProfileScreen(); // 保存后返回上一页
    });

    // 解散群聊 (不变)
    document.getElementById('disband-group-btn').addEventListener('click', async () => {
        // ... 这部分代码和之前完全一样，不用动 ...
        const group = state.contacts.find(c => c.id === state.activeChatId);
        if (!group) return;
        const confirmed = await showCustomConfirm('确认操作', `确定要解散群聊“${group.name}”吗？\n此操作会删除群聊及所有聊天记录，无法恢复！`, true);
        if (confirmed) {
            state.contacts = state.contacts.filter(c => c.id !== group.id);
            await kokoMemory.delete('contacts', group.id);
            state.activeChatId = null;
            alert('群聊已解散。');
            await showMainScreen();
        }
    });
}
        // --- NEW: V7.0 开始/停止听歌计时器 ---
        function startListenTimeTracker() {
            if (listenTimeInterval) clearInterval(listenTimeInterval); // 清除旧的计时器
            
            listenTimeInterval = setInterval(async () => {
                const contact = state.contacts.find(c => c.id === state.activeChatId);
                if (contact && !globalAudioPlayer.paused) {
                    contact.totalListenTime += 1; // 每秒加1
                    // 为避免频繁写数据库，可以设计成每10秒或30秒保存一次
                    if (contact.totalListenTime % 30 === 0) {
                        await kokoMemory.put('contacts', contact);
                    }
                }
            }, 1000);
        }

        async function stopListenTimeTracker() {
            clearInterval(listenTimeInterval);
            listenTimeInterval = null;
            // 停止时，确保最后的数据被保存
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if(contact) {
                await kokoMemory.put('contacts', contact);
            }
        }

// 把这段新代码，粘贴到 attachEventListeners 函数的【内部】

// --- 新增：打开“添加群成员”弹窗的逻辑 ---
function openAddGroupMemberModal(group) {
    const modal = document.getElementById('add-group-member-modal');
    const memberListEl = document.getElementById('add-member-picker-list');
    memberListEl.innerHTML = '';

    // 筛选出还不是群成员的联系人
    const availableContacts = state.contacts.filter(c => !c.isGroup && !group.members.includes(c.id));

    if (availableContacts.length === 0) {
        memberListEl.innerHTML = '<p style="color: #888; text-align: center;">没有其他可以添加的联系人了。</p>';
    } else {
        availableContacts.forEach(contact => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.innerHTML = `
                <input type="checkbox" id="add-member-check-${contact.id}" value="${contact.id}">
                <label for="add-member-check-${contact.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                    <img src="${contact.avatar}" alt="${contact.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                    <span>${contact.name}</span>
                </label>
            `;
            memberListEl.appendChild(item);
        });
    }

    modal.style.display = 'flex';
    
    // 为确认按钮绑定一次性事件
    const confirmBtn = document.getElementById('confirm-add-group-members-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    
    newConfirmBtn.addEventListener('click', async () => {
        const selectedIds = Array.from(document.querySelectorAll('#add-member-picker-list input:checked')).map(input => input.value);
        if (selectedIds.length === 0) {
            return;
        }

        const addedMemberNames = selectedIds.map(id => state.contacts.find(c => c.id === id)?.name).filter(Boolean);

        // 更新群成员列表
        group.members.push(...selectedIds);
        await kokoMemory.put('contacts', group);

        // 在群聊中发送系统通知
        const tempActiveChatId = state.activeChatId;
        state.activeChatId = group.id;
        await createAndAddMessage({
            type: 'system_notification',
            sender: 'system',
            content: `你邀请 "${addedMemberNames.join('", "')}" 加入了群聊`
        });
        state.activeChatId = tempActiveChatId;

        modal.style.display = 'none';
        openGroupSettingsScreen(group); // 刷新设置页面
    });
}

// --- 新增：为群聊设置页面的各种按钮绑定事件 ---
document.getElementById('group-settings-screen').addEventListener('click', async (e) => {
    const group = state.contacts.find(c => c.id === state.activeChatId);
    if (!group) return;

    // 处理“添加成员”按钮点击
    if (e.target.closest('#add-group-member-btn')) {
        openAddGroupMemberModal(group);
    }
    
// 处理“踢出成员”按钮点击
    const removeButton = e.target.closest('.remove-member-btn');
    if (removeButton) {
        const memberId = removeButton.dataset.memberId;
        
        // 1. 查找成员 (兼容 NPC 和 真实联系人)
        let member = state.contacts.find(c => c.id === memberId);
        if (!member && group.npcMembers) {
            member = group.npcMembers.find(n => n.id === memberId);
        }

        if (!member) return; // 没找到人，退出

        const confirmed = await showCustomConfirm('移出成员', `确定要将 "${member.name}" 移出群聊吗？`, true);
        
        if (confirmed) {
            // --- ✨ 核心优化 1: 立即在视觉上删除 (极速反馈) ---
            const itemRow = removeButton.closest('.contact-picker-item');
            if (itemRow) {
                itemRow.style.transition = "all 0.3s ease";
                itemRow.style.opacity = "0";
                itemRow.style.transform = "translateX(20px)";
                setTimeout(() => itemRow.remove(), 300); // 动画结束后移除DOM
            }

            // --- ✨ 核心优化 2: 立即更新人数计数 ---
            const countEl = document.getElementById('group-member-count');
            if (countEl) {
                const currentCount = parseInt(countEl.textContent) || 0;
                countEl.textContent = Math.max(0, currentCount - 1);
            }

            // --- 3. 后台数据处理 ---
            // 从成员 ID 列表中移除
            group.members = group.members.filter(id => id !== memberId);
            
            // 从禁言列表中移除
            if (group.mutedMembers) {
                group.mutedMembers = group.mutedMembers.filter(id => id !== memberId);
            }

            // 保存到数据库
            await kokoMemory.put('contacts', group);
            
            // 发送系统通知 (这步是异步的，放在最后)
            const tempActiveChatId = state.activeChatId;
            state.activeChatId = group.id;
            await createAndAddMessage({
                type: 'system_notification',
                sender: 'system',
                content: `你将 "${member.name}" 移出了群聊`
            });
            state.activeChatId = tempActiveChatId;

            // --- 4. 最后做一次完整的重新渲染，确保一切状态同步 ---
            // (稍微延迟一下，让上面的删除动画先播完，体验更好)
            setTimeout(() => {
                openGroupSettingsScreen(group); 
            }, 300);
        }
    }
    // ==========================================================
// ▼▼▼ 请将这段【新代码】粘贴到这里 ▼▼▼
// ==========================================================
const muteButton = e.target.closest('.mute-member-btn');
if (muteButton) {
    const memberId = muteButton.dataset.memberId;

    // 确保禁言列表存在
    group.mutedMembers = group.mutedMembers || [];

    const memberIndex = group.mutedMembers.indexOf(memberId);

    // 核心：切换禁言状态
    if (memberIndex > -1) {
        // 如果已经在列表里，就解除禁言
        group.mutedMembers.splice(memberIndex, 1);
    } else {
        // 如果不在列表里，就加入禁言
        group.mutedMembers.push(memberId);
    }

    // 保存更新后的群聊数据
    await kokoMemory.put('contacts', group);

    // 关键一步：重新渲染整个设置页面来立即更新UI
    openGroupSettingsScreen(group);
}
// ==========================================================
// ▲▲▲ 粘贴到这里结束 ▲▲▲
// ==========================================================
// ▼▼▼ 在这个事件监听器的末尾，添加我们新的逻辑 ▼▼▼
    if (e.target.id === 'clear-group-chat-history-btn' || e.target.closest('#clear-group-chat-history-btn')) {
        const group = state.contacts.find(c => c.id === state.activeChatId);
        if (!group) return;

        // 弹出确认框，防止误操作
        const confirmed = await showCustomConfirm(
            '清空记录', 
            `确定要清空群聊“${group.name}”的所有聊天记录吗？\n此操作不可恢复。`, 
            true // true表示这是一个危险操作，确认按钮会是红色
        );

        if (confirmed) {
            // 核心操作：清空 history 数组
            group.history = [];
            
            // 保存更改到数据库
            await kokoMemory.put('contacts', group);
            
            alert('群聊记录已清空。');
            
            // 操作完成后，关闭设置页面，并重新打开聊天窗口，用户就能看到空空如也的聊天界面了
            document.getElementById('group-settings-screen').style.display = 'none';
            openChat(group.id);
        }
    }
});

// --- 新增：为“添加成员”弹窗的关闭按钮绑定事件 ---
document.getElementById('close-add-group-member-modal').addEventListener('click', () => {
    document.getElementById('add-group-member-modal').style.display = 'none';
});
// ==========================================================
    // =========== ▼▼▼ 购物中心功能逻辑 V3 (预加载版) ▼▼▼ ===
    // ==========================================================
    let activeShoppingTab = 'taobao'; // 默认选中的标签页
    let currentProductData = {}; // 用于暂存当前要操作的商品信息

    // 函数：显示商品详情页面
    function showProductDetailScreen(productData) {
        currentProductData = productData; // 将当前商品信息存入全局，方便分享
        hideAllScreens();
        const detailScreen = document.getElementById('product-detail-screen');
        const mainInfoEl = document.getElementById('product-main-info');
        const commentsListEl = document.getElementById('buyer-comments-list');
        
        // 填充商品核心信息
        mainInfoEl.innerHTML = `
            <h1 style="font-size: 20px; font-weight: 700; margin-bottom: 10px;">${productData.name}</h1>
            <div class="product-price" style="font-size: 24px; margin-bottom: 10px;"><span>¥</span>${productData.price}</div>
            <div class="product-shop" style="margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #eee;">${productData.shop}</div>
            <div class="product-description">${productData.description.replace(/\n/g, '<br>')}</div>
        `;

        // 渲染预先加载好的评论
        commentsListEl.innerHTML = '';
        if (productData.comments && productData.comments.length > 0) {
            // 这是修复后的新代码块
productData.comments.forEach(comment => {
    const commentEl = document.createElement('div');
    commentEl.className = 'post-comment-item'; // 复用论坛评论样式
    commentEl.innerHTML = `
        <div style="display: flex; gap: 10px;">
            <img src="${STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)]}" style="width: 35px; height: 35px; border-radius: 50%;">
            <div style="flex-grow: 1;">
                <span class="comment-author">${comment.username}</span>
                <div class="comment-content">${comment.content}</div>
            </div>
        </div>
    `;
    commentsListEl.appendChild(commentEl);
});
        } else {
            commentsListEl.innerHTML = `<div style="text-align: center; color: #999; padding: 20px;">暂无评价</div>`;
        }
        
        detailScreen.style.display = 'flex';
    }

    // 函数：显示购物中心页面
    async function showShoppingScreen() {
        hideAllScreens();
        document.getElementById('shopping-screen').style.display = 'flex';
        activeShoppingTab = 'taobao';
        renderShoppingTabs();
        
        const savedProducts = await kokoMemory.get('userSettings', 'shopping_products_' + activeShoppingTab);
        if (savedProducts && savedProducts.data.length > 0) {
            renderProducts(savedProducts.data);
        } else {
            const productList = document.getElementById('product-list');
            productList.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: #888;">这里空空如也~<br>请点击右上角的刷新按钮生成商品</div>`;
        }
    }

    // 函数：渲染顶部的标签页
    async function renderShoppingTabs() {
        const tabsContainer = document.getElementById('shopping-tabs-container');
        tabsContainer.innerHTML = `
            <button class="feed-tab-btn ${activeShoppingTab === 'taobao' ? 'active' : ''}" data-tab="taobao">🍑宝</button>
            <button class="feed-tab-btn ${activeShoppingTab === 'meituan' ? 'active' : ''}" data-tab="meituan">丑团</button>
            <button class="feed-tab-btn ${activeShoppingTab === 'pinduoduo' ? 'active' : ''}" data-tab="pinduoduo">拼夕夕</button>
        `;
    }
    
    // 函数：创建单个商品卡片的HTML元素
    function createProductItem(product) {
        const item = document.createElement('div');
        item.className = 'product-item';
        item.dataset.product = JSON.stringify(product); 

        item.innerHTML = `
            <div class="product-details">
                <div class="product-title">${product.name}</div>
                <div class="product-description">${product.description}</div>
                <div class="product-shop">${product.shop}</div>
                <div class="product-footer">
                    <div class="product-price"><span>¥</span>${product.price}</div>
                    <button class="product-share-btn" title="分享给...">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        `;
        return item;
    }

    // 函数：将AI生成的商品渲染到页面上
    function renderProducts(products) {
        const productList = document.getElementById('product-list');
        productList.innerHTML = ''; 
        if (products.length === 0) {
            productList.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: #888;">AI没有生成任何商品，请再试一次。</div>`;
            return;
        }
        products.forEach(p => {
            const productElement = createProductItem(p);
            productList.appendChild(productElement);
        });
    }
    
    // 函数：调用AI刷新或搜索商品 (V3核心改动：一次性生成所有信息)
    async function refreshProductsAI(isSearch = false) {
        const productList = document.getElementById('product-list');
        productList.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-spinner fa-spin" style="font-size: 24px;"></i><p style="margin-top: 10px;">AI正在生成包含详情和评论的商品...</p></div>`;

        const platformStyles = {
            taobao: "高端、昂贵、有品牌调性",
            pinduoduo: "价格非常低廉、极具性价比、充满“百亿补贴”风格",
            meituan: "看起来很美味的菜品、套餐或饮品"
        };
        const platformName = {
            taobao: "淘宝",
            pinduoduo: "拼多多",
            meituan: "美团外卖"
        };

        const keyword = document.getElementById('product-search-input').value.trim();
        const coreTask = (isSearch && keyword) 
            ? `请根据关键词“[${keyword}]”，为[${platformName[activeShoppingTab]}]平台生成5个相关的、风格为[${platformStyles[activeShoppingTab]}]的商品。`
            : `请为[${platformName[activeShoppingTab]}]平台生成5个随机的、风格为[${platformStyles[activeShoppingTab]}]的商品。`;

        const prompt = `${coreTask}对于每个商品，都必须严格遵循以下格式块，并重复5次：
PRODUCT_START
名称：...
价格：...
店铺：...
商品描述：(20-40字的生动描述)
--COMMENTS--
(在这里为该商品生成3条风格各异的买家评论，每条评论都使用 '用户名：... | 评论内容：...' 的格式并换行)
PRODUCT_END`;
        
        try {
            const rawResponse = await generateAiResponse(null, [], prompt, false, 'square');
            const productBlocks = rawResponse.split('PRODUCT_END');
            const products = productBlocks.map(block => {
                if (!block.includes('PRODUCT_START')) return null;

                const nameMatch = block.match(/名称：(.*?)\n/);
                const priceMatch = block.match(/价格：(.*?)\n/);
                const shopMatch = block.match(/店铺：(.*?)\n/);
                const descMatch = block.match(/商品描述：(.*?)\n/);
                
                const commentsBlock = block.split('--COMMENTS--')[1] || '';
                const commentLines = commentsBlock.trim().split('\n');
                // 这是修复后的新代码块
const comments = commentLines.map(line => {
    const parts = line.split('|');
    if (parts.length < 2) return null; // 必须要有'|'分隔符

    // 智能地清理前后缀，无论AI给没给，都能正确提取
    const username = parts[0].replace('用户名：', '').trim();
    const content = parts[1].replace('评论内容：', '').trim();
    
    // 确保提取后内容不为空
    if (!username || !content) return null; 

    return { username: username, content: content };
}).filter(Boolean);

                return {
                    name: nameMatch ? nameMatch[1].trim() : '未知商品',
                    price: priceMatch ? priceMatch[1].trim() : '0.00',
                    shop: shopMatch ? shopMatch[1].trim() : '官方旗舰店',
                    description: descMatch ? descMatch[1].trim() : '一件很棒的商品。',
                    comments: comments,
                    platform: activeShoppingTab
                };
            }).filter(Boolean);

            await kokoMemory.put('userSettings', { id: 'shopping_products_' + activeShoppingTab, data: products });
            renderProducts(products);

        } catch (error) {
            console.error("AI商品生成失败:", error);
            productList.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: var(--soft-red);">商品生成失败，请检查API设置或网络。</div>`;
        }
    }

    // 函数：打开分享弹窗
    function openShareProductModal(product) {
    currentProductData = product;
    const modal = document.getElementById('share-product-modal');
    const infoEl = document.getElementById('share-product-info');
    const recipientListEl = document.getElementById('share-product-recipient-list');
    
    document.getElementById('share-product-message-input').value = '';
    infoEl.innerHTML = `即将分享: <strong>${product.name}</strong><br><span style="color: #888;">价格: ¥${product.price}</span>`;
    
    // ▼▼▼ 核心新增逻辑 ▼▼▼
    recipientListEl.innerHTML = ''; // 先清空旧列表
    state.contacts.forEach(contact => {
        if (contact.isGroup) return; // 不允许分享到群聊
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        // 使用 radio 按钮确保一次只能选一个人
        item.innerHTML = `
            <input type="radio" id="share-recipient-${contact.id}" name="share-recipient" value="${contact.id}">
            <label for="share-recipient-${contact.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                <img src="${contact.avatar}" alt="${contact.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                <span>${contact.name}</span>
            </label>
        `;
        recipientListEl.appendChild(item);
    });
    // ▲▲▲ 新增逻辑结束 ▲▲▲

    modal.style.display = 'flex';
}
    
    // 注意：函数参数发生了变化
async function handleShareProduct(intent, contactId) { 
    // 使用传入的 contactId 查找联系人
    const contact = state.contacts.find(c => c.id === contactId); 
    if (!contact) {
        // 理论上这里不会再报错，但保留以防万一
        alert('错误：选择的联系人无效！'); 
        return;
    }
    const message = document.getElementById('share-product-message-input').value.trim();
    if (intent === 'gift') {
        const price = parseFloat(currentProductData.price.replace(/[^\d.-]/g, ''));
        if (state.myProfile.balance < price) {
            alert('钱包余额不足，无法送出礼物！');
            return;
        }
        state.myProfile.balance -= price;
        await addTransaction('expense', price, `送给 ${contact.name} 的礼物：${currentProductData.name}`, contact.id);
        await kokoMemory.put('myProfile', state.myProfile);
        renderMyProfile();
    }
    
    // ▼▼▼ 核心修改：临时切换上下文来发送消息 ▼▼▼
    const originalActiveChatId = state.activeChatId; // 保存原始状态
    state.activeChatId = contact.id; // 临时设为目标联系人
    
    await createAndAddMessage({
        type: 'product_share',
        content: {
            productDetails: currentProductData,
            intent: intent,
            accompanyingMessage: message
        }
    });

    state.activeChatId = originalActiveChatId; // 恢复原始状态
    // ▲▲▲ 修改结束 ▲▲▲

    document.getElementById('share-product-modal').style.display = 'none';
    // 分享后只给提示，不再跳转页面，让用户可以继续浏览
    alert(`已成功分享给 ${contact.name}！`); 
}
// ✨✨✨ 开始粘贴新函数 ✨✨✨
async function renderForumSettingsUI() {
    // 1. 填充用户面具下拉菜单
    const personaSelect = document.getElementById('forum-persona-select');
    personaSelect.innerHTML = '<option value="">-- 不使用特定身份 --</option>';
    state.userPersonaPresets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        if (state.forumSettings.personaId === preset.id) {
            option.selected = true;
        }
        personaSelect.appendChild(option);
    });

    // 2. 填充世界书多选列表
    const worldBookList = document.getElementById('forum-worldbook-list');
    worldBookList.innerHTML = '';
    if (state.worldBooks.length > 0) {
        state.worldBooks.forEach(book => {
            const isChecked = state.forumSettings.worldBookIds.includes(book.id);
            const bookItem = document.createElement('div');
            bookItem.className = 'world-book-item';
            bookItem.innerHTML = `<input type="checkbox" class="world-book-checkbox" id="forum-book-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="forum-book-${book.id}" class="world-book-name">${book.name}</label>`;
            worldBookList.appendChild(bookItem);
        });
    } else {
        worldBookList.innerHTML = '<p style="color: #888; text-align: center;">还没有创建任何世界书。</p>';
    }

    // 3. 填充风格描述
    document.getElementById('forum-style-description').value = state.forumSettings.styleDescription || '';
// 在 renderForumSettingsUI 函数的末尾，添加下面这段代码

    // ▼▼▼ 开始添加新代码 ▼▼▼
    // 4. 填充允许发帖的角色列表
    const postersList = document.getElementById('forum-allowed-posters-list');
    postersList.innerHTML = ''; // 先清空

    // 筛选出所有非群聊的联系人
    const characters = state.contacts.filter(c => !c.isGroup);

    if (characters.length > 0) {
        characters.forEach(char => {
            // 检查这个角色是否已经在我们的“白名单”里了
            const isChecked = state.forumSettings.allowedPosterIds && state.forumSettings.allowedPosterIds.includes(char.id);
            const charItem = document.createElement('div');
            charItem.className = 'world-book-item'; // 复用现有样式
            charItem.innerHTML = `
                <input type="checkbox" class="world-book-checkbox poster-checkbox" id="poster-char-${char.id}" value="${char.id}" ${isChecked ? 'checked' : ''}>
                <label for="poster-char-${char.id}" class="world-book-name">${char.name}</label>
            `;
            postersList.appendChild(charItem);
        });
    } else {
        postersList.innerHTML = '<p style="color: #888; text-align: center;">你还没有创建任何角色联系人。</p>';
    }
    // ▲▲▲ 新代码添加结束 ▲▲▲
}
// ✨✨✨ 新函数粘贴结束 ✨✨✨
// ==========================================================
// =========== ▼▼▼ 全新：自由外观设置功能逻辑 ▼▼▼ ==========
// ==========================================================

let userSettings = {
    id: 'main',
    chatBackground: null, 
    customBubbleCss: '',  
    customFontUrl: '',    
    customFontName: '',
    customThemeCss: '',    // <-- 新增这一行
    customNarrativeCss: '',
    customFontSize: null
};

// 函数：动态更新自定义字体
function updateCustomFont(fontUrl, fontName) {
    let styleTag = document.getElementById('custom-font-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-font-style';
        document.head.appendChild(styleTag);
    }

    if (fontUrl && fontName) {
        // 创建 @font-face 规则来加载外部字体，并应用它
        const fontFaceRule = `
            @font-face {
                font-family: '${fontName}';
                src: url('${fontUrl}');
            }
        `;
        // 更新 --main-font 变量
        document.documentElement.style.setProperty('--main-font', `'${fontName}', 'Nunito', sans-serif`);
        styleTag.textContent = fontFaceRule;
    } else {
        // 如果URL或名称为空，则恢复默认字体并清空style标签
        document.documentElement.style.setProperty('--main-font', `'Nunito', sans-serif`);
        styleTag.textContent = '';
    }
}

// 函数：动态更新自定义气泡CSS
function updateCustomBubbles(cssString) {
    let styleTag = document.getElementById('custom-bubble-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-bubble-style';
        document.head.appendChild(styleTag);
    }
    styleTag.textContent = cssString || ''; // 如果CSS字符串为空，则清空样式
}
// 函数：动态更新自定义叙事模式CSS
function updateCustomNarrative(cssString) {
    let styleTag = document.getElementById('custom-narrative-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-narrative-style';
        document.head.appendChild(styleTag);
    }
    styleTag.textContent = cssString || ''; 
}
// 函数：动态更新全局字体大小
function updateCustomFontSize(size) {
    let styleTag = document.getElementById('custom-font-size-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-font-size-style';
        document.head.appendChild(styleTag);
    }

    if (size && !isNaN(size) && size >= 12) {
        // 为应用内的主要文字元素生成覆盖样式
        styleTag.textContent = `
            /* 全局基础字号 */
            body, .form-input, .form-textarea, .detail-value {
                font-size: ${size}px !important;
            }
            /* 聊天气泡字号 */
            .message {
                font-size: ${size}px !important;
            }
            /* 输入框字号 */
            #message-input, #comment-input {
                font-size: ${size}px !important;
            }
            /* 论坛和日记正文字号 */
            .post-text, .comment-content, .diary-entry-content {
                font-size: ${size}px !important;
                line-height: 1.6 !important; /* 相应调整行高 */
            }
        `;
    } else {
        // 如果没有设置或值无效，则清空样式，恢复默认
        styleTag.textContent = '';
    }
}
// 函数：动态更新自定义主题CSS
function updateCustomTheme(cssString) {
    let styleTag = document.getElementById('custom-theme-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-theme-style';
        document.head.appendChild(styleTag);
    }
    styleTag.textContent = cssString || ''; 
}

// 函数：应用所有保存的设置
function applyAppearanceSettings() {
    // 1. 应用背景
    const chatScreen = document.getElementById('chat-screen');
    if (userSettings.chatBackground) {
        chatScreen.style.backgroundImage = `url(${userSettings.chatBackground})`;
    } else {
        // 恢复到CSS文件中的默认样式
        chatScreen.style.backgroundImage = ''; 
    }

    // 2. 应用自定义气泡样式
    updateCustomBubbles(userSettings.customBubbleCss);
    // 3. 应用自定义主题样式
updateCustomTheme(userSettings.customThemeCss);
// 4. 应用自定义叙事样式
updateCustomNarrative(userSettings.customNarrativeCss);
// 5. 应用自定义字体大小 (新加)
updateCustomFontSize(userSettings.customFontSize);
    
    // 3. 应用自定义字体
    updateCustomFont(userSettings.customFontUrl, userSettings.customFontName);
}

async function loadAppearanceSettings() {
    const savedSettings = await kokoMemory.get('userSettings', 'main');
    if (savedSettings) {
        userSettings = { ...userSettings, ...savedSettings };
    }
    
    // ▼▼▼ 新增下面这2行 ▼▼▼
    autoLockDelay = userSettings.autoLockDelay || 0; // 加载延迟设置
    document.getElementById('auto-lock-delay-input').value = autoLockDelay > 0 ? autoLockDelay : '';

    applyAppearanceSettings();
}

// 函数：保存当前设置到数据库
async function saveAppearanceSettings() {
    // 从UI控件读取当前用户的输入
    userSettings.customBubbleCss = document.getElementById('bubble-css-input').value.trim();
    userSettings.customThemeCss = document.getElementById('theme-css-input').value.trim();
userSettings.customNarrativeCss = document.getElementById('narrative-css-input').value.trim();
// 新增下面这行：将输入框的值转为数字，如果为空则存为 null
userSettings.customFontSize = parseFloat(document.getElementById('font-size-input').value) || null; // 新增这一行
    userSettings.customFontUrl = document.getElementById('font-url-input').value.trim();
    userSettings.customFontName = document.getElementById('font-name-input').value.trim().replace(/[^a-zA-Z0-9]/g, ''); // 只保留字母和数字作为字体名
    userSettings.autoLockDelay = parseInt(document.getElementById('auto-lock-delay-input').value, 10) || 0;
    autoLockDelay = userSettings.autoLockDelay; // 更新全局变量
    
    // 背景图在上传时已实时保存到 userSettings.chatBackground
    
    if (userSettings.customFontUrl && !userSettings.customFontName) {
        alert("请输入一个CSS字体名称！");
        return;
    }
    
    await kokoMemory.put('userSettings', userSettings);
    alert('外观设置已应用并保存！');
    applyAppearanceSettings(); // 再次应用以确保所有更改都生效
}
// 请将下面这个完整的函数，粘贴到刚才删除代码的位置
function attachEventListeners() {
// ▼▼▼ 使用这个【逻辑反转版】的完整函数，替换掉旧的 openGroupSettingsScreen 函数 ▼▼▼

function openGroupSettingsScreen(group) {
    hideAllScreens();
    const screen = document.getElementById('group-settings-screen');
    screen.style.display = 'flex';

    // 1. 填充基本信息
    document.getElementById('group-user-mask-textarea').value = group.userPersona || '';
    document.getElementById('group-memory-share-toggle').checked = group.memoryShared;
    document.getElementById('group-time-awareness-toggle').checked = group.isTimeAware;
    
    const memberCountEl = document.getElementById('group-member-count');
    if(memberCountEl) memberCountEl.textContent = group.members.length;

    // 2. 填充并选中世界书
    const worldBookList = document.getElementById('group-world-book-selector-list');
    worldBookList.innerHTML = '';
    state.worldBooks.forEach(book => {
        const isChecked = group.worldBooks && group.worldBooks.includes(book.id);
        const bookItem = document.createElement('div');
        bookItem.className = 'world-book-item';
        bookItem.innerHTML = `<input type="checkbox" class="world-book-checkbox" id="group-book-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="group-book-${book.id}" class="world-book-name">${book.name}</label>`;
        worldBookList.appendChild(bookItem);
    });

    // 3. 填充并选中用户面具预设
    const personaSelect = document.getElementById('group-select-user-persona-preset');
    personaSelect.innerHTML = '<option value="">-- 选择或输入自定义面具 --</option>';
    state.userPersonaPresets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        if(group.userPersona === preset.description) {
            option.selected = true;
        }
        personaSelect.appendChild(option);
    });

    // 4. 填充成员列表
// 4. 填充成员列表（智能查找版）
    const membersListEl = document.getElementById('group-members-list');
    membersListEl.innerHTML = '';
    group.members.forEach(memberId => {
        
        // ▼▼▼ 核心修改在这里 ▼▼▼
        let profile = null;
        if (memberId === 'myProfile') {
            profile = state.myProfile;
        } else {
            // 先在主联系人里找
            profile = state.contacts.find(c => c.id === memberId);
            if (!profile && group.npcMembers) {
                // 没找到？去NPC列表里找
                profile = group.npcMembers.find(npc => npc.id === memberId);
            }
        }
        // ▲▲▲ 修改结束 ▲▲▲

        if (profile) {
            const isMuted = (group.mutedMembers || []).includes(memberId);
            
            // ▼▼▼ 新增一个 (NPC) 标签 ▼▼▼
            const isNPC = !state.contacts.some(c => c.id === memberId) && memberId !== 'myProfile';            
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            
            // ▼▼▼ 核心修改：如果是 NPC，加上点击样式和 ID 数据 ▼▼▼
            if (isNPC) {
                item.style.cursor = 'pointer';
                item.dataset.npcId = memberId; // 存下 ID
                item.dataset.isNpcRow = 'true'; // 标记这是一行 NPC
                item.title = "点击修改 NPC 设定";
            }
            // ▲▲▲ 修改结束 ▲▲▲

            item.innerHTML = `
                <img src="${profile.avatar}" alt="${profile.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                <span style="flex-grow: 1;">${profile.name} ${memberId === 'myProfile' ? '(你)' : ''} ${isNPC ? '<span style="font-size: 11px; color: #888; background: #eee; padding: 1px 4px; border-radius: 4px;">NPC</span>' : ''}</span>
                ${memberId !== 'myProfile' ? `
                    <button class="preset-action-btn mute-member-btn ${!isMuted ? 'active' : ''}" data-member-id="${memberId}" title="${isMuted ? '解除禁言' : '禁言'}">
                        <i class="fas ${isMuted ? 'fa-bell-slash' : 'fa-bell'}"></i>
                    </button>
                    <button class="preset-action-btn delete remove-member-btn" data-member-id="${memberId}" title="移出群聊">
                        <i class="fas fa-times"></i>
                    </button>
                ` : ''}
            `;
            membersListEl.appendChild(item);
        }
    });

    // 5. 为页面上的按钮绑定一次性事件监听器
    const oldSaveBtn = document.getElementById('save-group-settings-btn');
    const newSaveBtn = oldSaveBtn.cloneNode(true);
    oldSaveBtn.parentNode.replaceChild(newSaveBtn, oldSaveBtn);
    newSaveBtn.addEventListener('click', async () => {
        group.userPersona = document.getElementById('group-user-mask-textarea').value.trim();
        group.memoryShared = document.getElementById('group-memory-share-toggle').checked;
        group.isTimeAware = document.getElementById('group-time-awareness-toggle').checked;
        group.worldBooks = Array.from(document.querySelectorAll('#group-world-book-selector-list .world-book-checkbox:checked')).map(cb => cb.value);
        await kokoMemory.put('contacts', group);
        alert('群聊设置已保存！');
        showCharProfileScreen();
    }, { once: true });
    
    const oldDisbandBtn = document.getElementById('disband-group-btn');
    const newDisbandBtn = oldDisbandBtn.cloneNode(true);
    oldDisbandBtn.parentNode.replaceChild(newDisbandBtn, oldDisbandBtn);
    newDisbandBtn.addEventListener('click', async () => {
        const confirmed = await showCustomConfirm('确认操作', `确定要解散群聊“${group.name}”吗？\n此操作会删除群聊及所有聊天记录，无法恢复！`, true);
        if (confirmed) {
            state.contacts = state.contacts.filter(c => c.id !== group.id);
            await kokoMemory.delete('contacts', group.id);
            state.activeChatId = null;
            alert('群聊已解散。');
            await showMainScreen();
        }
    }, { once: true });
    
    const oldBackBtn = document.getElementById('back-from-group-settings');
    const newBackBtn = oldBackBtn.cloneNode(true);
    oldBackBtn.parentNode.replaceChild(newBackBtn, oldBackBtn);
    newBackBtn.addEventListener('click', () => {
        screen.style.display = 'none';
        openChat(state.activeChatId);
    }, { once: true });

    const oldPersonaSelect = document.getElementById('group-select-user-persona-preset');
    const newPersonaSelect = oldPersonaSelect.cloneNode(true);
    oldPersonaSelect.parentNode.replaceChild(newPersonaSelect, oldPersonaSelect);
    newPersonaSelect.addEventListener('change', function() {
        const selectedPresetId = this.value;
        const preset = state.userPersonaPresets.find(p => p.id === selectedPresetId);
        document.getElementById('group-user-mask-textarea').value = preset ? preset.description : '';
    });
}

// ==========================================================
    // =========== ▼▼▼ 全新：群聊功能核心逻辑 ▼▼▼ ==========
    // ==========================================================
    const createGroupBtn = document.getElementById('create-group-btn');
    if (createGroupBtn) {
        createGroupBtn.addEventListener('click', () => {
            const modal = document.getElementById('create-group-modal');
            const memberListEl = document.getElementById('group-member-picker-list');
            const groupNameInput = document.getElementById('group-name-input');
            groupNameInput.value = '';
            memberListEl.innerHTML = '';

            // 动态加载可选的群成员
            state.contacts.forEach(contact => {
                if (contact.isGroup) return; // 不能把群聊加到群聊里
                const item = document.createElement('div');
                item.className = 'contact-picker-item';
                item.innerHTML = `
                    <input type="checkbox" id="member-check-${contact.id}" value="${contact.id}">
                    <label for="member-check-${contact.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                        <img src="${contact.avatar}" alt="${contact.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                        <span>${contact.name}</span>
                    </label>
                `;
                memberListEl.appendChild(item);
            });
            
            modal.style.display = 'flex';
        });
    }

    document.getElementById('close-create-group-modal').addEventListener('click', () => {
        document.getElementById('create-group-modal').style.display = 'none';
    });

    document.getElementById('confirm-create-group-btn').addEventListener('click', async () => {
        const groupName = document.getElementById('group-name-input').value.trim();
        if (!groupName) {
            return alert('请给你的群聊起个名字！');
        }

        const selectedMemberIds = Array.from(document.querySelectorAll('#group-member-picker-list input:checked')).map(input => input.value);
        if (selectedMemberIds.length < 2) {
            return alert('群聊至少需要2位AI成员哦！');
        }
        
        // ✨ 核心改动：新增 mutedMembers: [] 属性，为禁言功能做准备
        const newGroup = {
            id: 'group_' + Date.now(),
            name: groupName,
            avatar: '',
            isGroup: true,
            members: ['myProfile', ...selectedMemberIds],
            history: [],
            memoryShared: true,
            mutedMembers: [], // 初始化禁言列表
            npcMembers: []
        };

        state.contacts.push(newGroup);
        await kokoMemory.put('contacts', newGroup);
        
        // 临时切换 activeChatId 来正确添加第一条系统消息
        const tempActiveChatId = state.activeChatId;
        state.activeChatId = newGroup.id;
        await createAndAddMessage({
            type: 'system_notification',
            sender: 'system',
            content: `你创建了群聊`
        });
        state.activeChatId = tempActiveChatId;

        await renderContacts();
        document.getElementById('create-group-modal').style.display = 'none';
        openChat(newGroup.id);
    });
    // ==========================================================
    // V9.0 新增：悬浮播放器拖动逻辑 (支持鼠标和触摸)
    // ==========================================================
    const card = document.getElementById('music-player-card');
    const header = document.getElementById('player-header');
    let isDragging = false,
        cardX = 50,
        cardY = 50,
        dragStartX = 0,
        dragStartY = 0;
    card.style.left = `${cardX}px`;
    card.style.top = `${cardY}px`;

    function dragStart(e) {
        isDragging = true;
        const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
        dragStartX = clientX;
        dragStartY = clientY;
        card.style.transition = 'none';
    }

    function dragMove(e) {
        if (isDragging) {
            if (e.type === 'touchmove') e.preventDefault();
            const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
            const deltaX = clientX - dragStartX;
            const deltaY = clientY - dragStartY;
            card.style.left = `${cardX + deltaX}px`;
            card.style.top = `${cardY + deltaY}px`;
        }
    }

    function dragEnd(e) {
        if (isDragging) {
            isDragging = false;
            const clientX = e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX;
            const clientY = e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY;
            cardX += (clientX - dragStartX);
            cardY += (clientY - dragStartY);
            card.style.transition = 'all 0.4s ease-in-out';
        }
    }
    header.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', dragMove);
    document.addEventListener('mouseup', dragEnd);
    header.addEventListener('touchstart', dragStart);
    document.addEventListener('touchmove', dragMove, {
        passive: false
    });
    document.addEventListener('touchend', dragEnd);

    let currentlyPlayingMsgId = null;
    
 // --- 原有功能：数据导入导出 ---
document.getElementById('export-data-btn').addEventListener('click', exportData);

// ▼▼▼ 在这里添加新的一行代码 ▼▼▼
document.getElementById('export-light-data-btn').addEventListener('click', exportLightData);

// ▲▲▲ 添加结束 ▲▲▲

document.getElementById('import-data-btn').addEventListener('click', () => {
    document.getElementById('import-file-input').click();
});
    document.getElementById('import-file-input').addEventListener('change', importData);

    // --- 原有功能：头像更换 ---
    document.getElementById('change-avatar-btn').addEventListener('click', function() {
        handleAvatarUpload(async (base64String) => {
            state.myProfile.avatar = base64String;
            await kokoMemory.put('myProfile', state.myProfile);
            renderMyProfile();
        });
    });
    document.getElementById('change-char-avatar-btn').addEventListener('click', () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        handleAvatarUpload(async (base64String) => {
            contact.avatar = base64String;
            await kokoMemory.put('contacts', contact);
            showCharProfileScreen();
            renderContacts();
        });
    });

 // ▼▼▼ 使用这个【超级整合版】，替换掉所有旧的底部导航栏监听代码 ▼▼▼

// --- 统一处理所有页面的底部导航栏点击事件 (V2 - 包含短信切换) ---
document.getElementById('screen').addEventListener('click', (e) => {
    const navItem = e.target.closest('.nav-item');
    if (!navItem) return;

    // ✨ 核心改动：重置 state.currentChatMode
    state.currentChatMode = 'chat'; // 默认切回聊天模式

    if (navItem.id.startsWith('nav-chat')) {
        showMainScreen();
    } else if (navItem.id.startsWith('nav-discover')) {
        showDiscoverScreen();
    } else if (navItem.id.startsWith('nav-profile')) {
        showProfileScreen();
    } else if (navItem.id.startsWith('nav-sms')) {
        // ✨ 当点击短信页签时，明确设置模式
        state.currentChatMode = 'sms';
        showSmsScreen(); // 调用显示短信主界面的函数
    }
});

// ▲▲▲ 替换结束 ▲▲▲
const smsMessageInput = document.getElementById('sms-message-input');
if (smsMessageInput) {
    smsMessageInput.addEventListener('input', function() {
        this.style.height = 'auto'; // 先重置高度，让浏览器重新计算
        // 设置新高度，但不超过 max-height
        const maxHeight = 100; // 和 CSS 里的 max-height 保持一致
        const newHeight = Math.min(this.scrollHeight, maxHeight);
        this.style.height = newHeight + 'px';
    });
}
// --- 短信界面的 "请求回复" 按钮 ---
const smsRequestReplyBtn = document.getElementById('sms-request-reply-btn');
if (smsRequestReplyBtn) {
    smsRequestReplyBtn.addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        // 确保我们在短信模式下，并且有有效的联系人
        if (contact && state.currentChatMode === 'sms') {
            await requestAiSmsReply(contact); // 调用请求回复的函数
        }
    });
}
// --- 在 attachEventListeners 函数内部添加 ---

// 短信编辑按钮
const editSmsBtn = document.getElementById('edit-sms-btn');
if (editSmsBtn) {
    editSmsBtn.addEventListener('click', enterSmsEditMode);
}

// 短信编辑栏按钮
const deleteSelectedSmsBtn = document.getElementById('delete-selected-sms-btn');
if (deleteSelectedSmsBtn) {
    deleteSelectedSmsBtn.addEventListener('click', deleteSelectedSmsMessages);
}
const cancelSmsEditBtn = document.getElementById('cancel-sms-edit-btn');
if (cancelSmsEditBtn) {
    cancelSmsEditBtn.addEventListener('click', exitSmsEditMode);
}

// ▼▼▼ ✨ 使用这个【V2 完整版】替换旧的 'sms-chat-messages' 监听器 ▼▼▼
const smsMessagesContainer = document.getElementById('sms-chat-messages');
if (smsMessagesContainer) {
    smsMessagesContainer.addEventListener('click', (e) => {
        const wrapper = e.target.closest('.sms-row');
        if (!wrapper) return;

        // 逻辑 1: 处理编辑模式下的点击
        if (smsEditModeState.active) {
            handleSmsMessageSelection(wrapper);
            return; // 在编辑模式下，不执行后续的点击展开逻辑
        }

        // 逻辑 2: 处理“点击查看描述”
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;

        const msgId = wrapper.dataset.messageId;
        const msg = contact.smsHistory.find(m => m.id === msgId);

        // ✨ 核心功能：检查点击的是否是 picture_description
        if (msg && msg.type === 'picture_description') {
            const transcribedTextEl = wrapper.querySelector('.transcribed-text');
            if (!transcribedTextEl) return;

            const isCurrentlyVisible = transcribedTextEl.classList.contains('visible');

            // a. 先关闭所有其他已打开的文字气泡
            document.querySelectorAll('#sms-chat-messages .transcribed-text.visible').forEach(el => {
                if (el !== transcribedTextEl) {
                    el.classList.remove('visible');
                    el.textContent = '';
                }
            });

            // b. 切换当前点击的气泡的文字显示状态
            if (isCurrentlyVisible) {
                transcribedTextEl.classList.remove('visible');
                transcribedTextEl.textContent = '';
            } else {
                transcribedTextEl.textContent = msg.content.description;
                transcribedTextEl.classList.add('visible');
            }
        }
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// (可选) 修改短信界面的返回按钮逻辑，确保在编辑模式下先退出编辑
const backFromSmsChatBtn = document.getElementById('back-from-sms-chat');
if (backFromSmsChatBtn) {
    // 先移除可能存在的旧监听器
    const newBackBtn = backFromSmsChatBtn.cloneNode(true);
    backFromSmsChatBtn.parentNode.replaceChild(newBackBtn, backFromSmsChatBtn);
    // 添加新监听器
    newBackBtn.addEventListener('click', () => {
        if (smsEditModeState.active) {
            exitSmsEditMode(); // 如果在编辑，先退出编辑
        } else {
            state.currentChatMode = 'sms';
            showSmsScreen(); // 否则正常返回列表
        }
    });
}
// ▼▼▼ 把这行新代码，粘贴到 attachEventListeners 函数里面 ▼▼▼
// 短信/窥探模式的页签切换
document.getElementById('sms-tabs').addEventListener('click', handleSmsTabClick);
// ▲▲▲ 粘贴到这里结束 ▲▲▲
// --- 新增：处理窥探模式照片图标点击事件 ---
const snoopContentBody = document.getElementById('snooped-app-content-body');
snoopContentBody.addEventListener('click', (e) => {
    const photoIcon = e.target.closest('.snoop-photo-item');
    if (photoIcon) {
        const detailsId = photoIcon.dataset.detailsId;
        const detailsElement = document.getElementById(detailsId);

        if (detailsElement) {
            // 先关闭所有其他已打开的详情
            document.querySelectorAll('.snoop-photo-details.visible').forEach(openDetail => {
                if (openDetail !== detailsElement) {
                    openDetail.classList.remove('visible');
                    // Add a small delay to allow the closing animation to finish before potentially opening another
                    setTimeout(() => { openDetail.style.display = 'none'; }, 300);
                }
            });

            // 切换当前点击的详情的可见性
            const isVisible = detailsElement.classList.toggle('visible');
            if (isVisible) {
                detailsElement.style.display = 'block'; // Make it visible before animation
            } else {
                // Add delay before setting display none to allow fade out animation
                setTimeout(() => { detailsElement.style.display = 'none'; }, 300);
            }
        }
    } else if (!e.target.closest('.snoop-photo-details')) {
         // 如果点击的不是图标也不是详情框本身，关闭所有打开的详情
         document.querySelectorAll('.snoop-photo-details.visible').forEach(openDetail => {
             openDetail.classList.remove('visible');
             setTimeout(() => { openDetail.style.display = 'none'; }, 300);
         });
    }
});
// --- 照片图标点击事件结束 ---

    // --- 原有功能：发现页跳转 ---
    document.getElementById('user-persona-presets-btn').addEventListener('click', showUserPersonaManagementScreen);
    document.getElementById('emoticon-library-btn').addEventListener('click', showEmoticonLibraryScreen);
    document.getElementById('music-library-btn').addEventListener('click', showMusicLibraryScreen);
    document.getElementById('thought-presets-btn').addEventListener('click', showThoughtPresetManagementScreen);
    document.getElementById('world-book-btn').addEventListener('click', () => {
        hideAllScreens();
        document.getElementById('world-book-screen').style.display = 'flex';
        renderWorldBooks();
    });
document.getElementById('api-settings-btn').addEventListener('click', async () => {
    hideAllScreens();
    document.getElementById('api-settings-screen').style.display = 'flex';
    document.getElementById('api-key-input').value = state.apiSettings.apiKey;
    document.getElementById('api-endpoint-input').value = state.apiSettings.endpoint;
    document.getElementById('context-length-input').value = state.apiSettings.contextLength;
    document.getElementById('long-term-memory-length-input').value = state.apiSettings.longTermMemoryLength;

    // ▼▼▼ 新增这两行 ▼▼▼
    document.getElementById('minimax-group-id-input').value = state.apiSettings.minimaxGroupId || '';
    document.getElementById('minimax-api-key-input').value = state.apiSettings.minimaxApiKey || '';
    // ▲▲▲ 新增结束 ▲▲▲
    // ▼▼▼ 新增：填充温度和Token ▼▼▼
    document.getElementById('api-temperature-input').value = state.apiSettings.temperature || '';
    document.getElementById('api-max-tokens-input').value = state.apiSettings.maxTokens || '';
    // ▲▲▲ 新增结束 ▲▲▲
    // ▼▼▼ 新增这一行 ▼▼▼
document.getElementById('siliconflow-api-key-input').value = state.apiSettings.siliconflowApiKey || '';

    updateModelDropdown([state.apiSettings.model], document.getElementById('model-select'), state.apiSettings.model);

    await renderApiPresetDropdown(); 
});
    document.getElementById('square-api-settings-btn').addEventListener('click', async () => {
        hideAllScreens();
        document.getElementById('square-api-settings-screen').style.display = 'flex';
        document.getElementById('square-api-key-input').value = state.squareApiSettings.apiKey;
        document.getElementById('square-api-endpoint-input').value = state.squareApiSettings.endpoint;
        updateModelDropdown([state.squareApiSettings.model], document.getElementById('square-model-select'), state.squareApiSettings.model);
        await renderForumSettingsUI();
    });
    document.getElementById('moments-btn').addEventListener('click', showFeedScreen);

    // --- 原有功能：各页面返回按钮 ---
    document.getElementById('back-from-user-persona-management').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-emoticon-library').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-music-library').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-thought-presets').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-world-book').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-api').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-square-api').addEventListener('click', showDiscoverScreen);
// ✅✅✅ 最终的正确代码 ✅✅✅
document.getElementById('back-from-chat').addEventListener('click', async () => {
    if (editModeState.active) await exitEditMode();
    document.getElementById('chat-pet-container').style.display = 'none';
    currentlyPlayingMsgId = null;
    
    // ✨ 核心V2：退出聊天时，移除专属CSS标签
    let oldTag = document.getElementById('contact-specific-bubble-style');
    if (oldTag) {
        oldTag.remove();
    }

    // 1. 先调用 showMainScreen()，它内部的 hideAllScreens() 会立刻隐藏聊天窗口
    await showMainScreen(); 
    
    // 2. 关键修复：在UI完全切换到主屏幕后，再把 activeChatId 设为 null
    state.activeChatId = null; 
});
    document.getElementById('back-from-contact-settings').addEventListener('click', () => {
        document.getElementById('contact-settings-screen').style.display = 'none';
        showCharProfileScreen();
    });
    document.getElementById('back-from-moments').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-char-profile').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (contact && contact.isChatPetVisible && batchedPetActions.length > 0) {
            const summary = batchedPetActions.join('，');
            const systemPrompt = `[角色后台指令：用户刚刚在宠物界面进行了一系列操作：“${summary}”。你的任务是，不要逐条复述这些操作日志，而是对此事发表一句连贯、自然的口语化评论来衔接对话。例如，你可以问：“刚刚去照顾咱们的史莱姆啦？”或者说：“看你把它喂得饱饱的，真好。”]`;
            await requestAiReply(systemPrompt);
        }
        batchedPetActions = [];
        
        // ▼▼▼ 核心修复点在这里 ▼▼▼
        // 我们不再只是“显示”旧的聊天屏幕
        // document.getElementById('char-profile-screen').style.display = 'none';
        // document.getElementById('chat-screen').style.display = 'flex';

        // 而是调用 openChat() 函数，它会用最新的数据“重新绘制”整个聊天界面
        openChat(state.activeChatId);
        // ▲▲▲ 修复结束 ▲▲▲
    });
    document.getElementById('back-from-diary').addEventListener('click', showCharProfileScreen);
    document.getElementById('back-from-post-detail').addEventListener('click', showFeedScreen);
    document.getElementById('back-from-trending-topic').addEventListener('click', showFeedScreen);
    // ▼▼▼ 这整段代码在新版本中都缺失了 ▼▼▼
document.getElementById('refresh-post-comments-btn').addEventListener('click', async () => {
    const post = state.posts.find(p => p.id === state.activePostId);
    if (!post) return;

    showFeedStatus('正在加载新评论...');
    try {
        await generateMoreCommentsForPost(post);
        await kokoMemory.put('posts', post);
        await renderPostDetail();

    } catch(e) {
        console.error("刷新评论失败:", e);
        alert("刷新评论失败: " + e.message);
    } finally {
        hideFeedStatus();
    }
});
    const backFromMemoryAlbumBtn = document.getElementById('back-from-memory-album');
    if (backFromMemoryAlbumBtn) {
        backFromMemoryAlbumBtn.addEventListener('click', showCharProfileScreen);
    }

    document.getElementById('send-btn').addEventListener('click', sendMessage);
// (V5 - 最终版：支持私聊+群聊的自由聊天)
// 粘贴到 attachEventListeners() 函数内部
document.getElementById('request-reply-btn').addEventListener('click', () => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return; 

    // 1. 找到最后一条“真实”消息
    const lastRealMessage = contact.history.slice().reverse().find(m => 
        m.sender !== 'system' && 
        m.sender !== 'system_instruction' &&
        m.type !== 'system_notification'
    );

    // 2. 检查是不是用户最后发言
    const userSpokeLast = lastRealMessage && (lastRealMessage.sender === 'user' || lastRealMessage.sender === 'myProfile');

    if (userSpokeLast) {
        // --- Case 1: 用户刚说完 (无论私聊还是群聊) ---
        // 100% 执行“回复你”的逻辑
        console.log("用户刚发言，触发AI回复用户...");
        requestAiReply(null, contact.id);
    } else {
        // --- Case 2: 用户没说话 (AI说的，或没记录) ---
        if (contact.isGroup) {
            // 2a. 如果是群聊，调用【群聊】自由聊天
            console.log("群聊：用户未发言，触发AI自由聊天...");
            triggerGroupFreeChat(contact); 
        } else {
            // 2b. 如果是私聊，调用【私聊】自由聊天 (新功能!)
            console.log("私聊：用户未发言，触发AI自由聊天...");
            triggerPrivateFreeChat(contact); 
        }
    }
});
    document.getElementById('message-input').addEventListener('keypress', e => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    // ▼▼▼ ✨【KOKO 核心修复】✨ 让主聊天输入框自动变高 ▼▼▼
document.getElementById('message-input').addEventListener('input', function() {
    // 1. 先重置高度，让浏览器告诉我们内容到底需要多高
    this.style.height = 'auto'; 

    // 2. 你的 CSS 里设置了 max-height: 100px，我们遵守这个限制
    const maxHeight = 100; 

    // 3. 计算新高度 (scrollHeight 是内容真实高度)，但不超过最大值
    const newHeight = Math.min(this.scrollHeight, maxHeight);

    // 4. 应用新高度 (如果内容高度小于最小高度，浏览器会自动处理)
    this.style.height = newHeight + 'px';
});
// ▲▲▲ ✨✨✨ 修复结束 ✨✨✨ ▲▲▲
    document.getElementById('cancel-edit-btn').addEventListener('click', exitEditMode);
// (替换) “删除已选”按钮 - 智能无刷新删除版
document.getElementById('delete-selected-btn').addEventListener('click', async () => {
    if (editModeState.selectedMessageIds.size === 0) {
        return alert('请先选择要删除的消息。');
    }
    const confirmed = await showCustomConfirm('删除消息', `确定要删除选中的 ${editModeState.selectedMessageIds.size} 条消息吗？`, true);
    if (confirmed) {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (contact) {
            // 1. (保持不变) 处理音乐播放停止逻辑
            const createKey = (song) => `${(song.title || '').trim()}|${(song.artist || '').trim()}`;
            const librarySongKeys = new Set(state.musicLibrary.map(createKey));
            const deletedTempMusicMessages = contact.history.filter(msg =>
                editModeState.selectedMessageIds.has(msg.id) &&
                msg.type === 'music_share' &&
                !librarySongKeys.has(createKey(msg.content))
            );
            if (deletedTempMusicMessages.length > 0) {
                const deletedTempSongKeys = new Set(deletedTempMusicMessages.map(msg => createKey(msg.content)));
                const currentTrack = contact.sharedPlaylist.tracks[contact.sharedPlaylist.currentIndex];
                if (currentTrack && deletedTempSongKeys.has(createKey(currentTrack))) {
                    globalAudioPlayer.pause();
                    globalAudioPlayer.src = '';
                    contact.sharedPlaylist.currentIndex = 0;
                    closeMusicPlayer();
                }
            }
            
            // 2. ✨【核心新增】✨：在更新数据前，先把屏幕上的气泡直接删掉！
            // 这样既能立刻看到效果，又不会触发页面滚动。
            editModeState.selectedMessageIds.forEach(msgId => {
                const messageEl = document.getElementById('chat-messages').querySelector(`.message-wrapper[data-message-id="${msgId}"]`);
                if (messageEl) {
                    messageEl.remove(); // 直接从 DOM 中移除元素
                }
            });

            // 3. (保持不变) 更新内存数据并保存到数据库
            contact.history = contact.history.filter(msg => !editModeState.selectedMessageIds.has(msg.id));
            await kokoMemory.put('contacts', contact);
            
            // 4. (保持不变) 刷新一下底层的播放列表（不可见，不影响界面）
            const musicPlayerCard = document.getElementById('music-player-card');
            if (musicPlayerCard.style.display === 'flex' && state.musicSessionContactId === contact.id) {
                renderPlaylist();
            }
        }
        // 5. 退出编辑模式 (这时它只会清理剩下的高亮，不会再乱跳了)
        await exitEditMode();
    }
});

// --- 用这个新版本，替换掉旧的 'char-more-info-btn' 事件监听代码 ---

document.getElementById('char-more-info-btn').addEventListener('click', async () => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    if (contact.isGroup) {
        openGroupSettingsScreen(contact);
    } else {
    await updateUserPersonaPresetSelect();
        const avatarPreview = document.getElementById('custom-user-avatar-preview');
        if (contact.customUserAvatar) {
            avatarPreview.src = contact.customUserAvatar;
            avatarPreview.style.display = 'block';
        } else {
            avatarPreview.style.display = 'none';
        }

        document.getElementById('char-mask-textarea').value = contact.persona;
        document.getElementById('contact-bubble-css-input').value = contact.customBubbleCss || '';
        document.getElementById('user-mask-textarea').value = contact.userPersona || '';
        document.getElementById('custom-user-name-input').value = contact.customUserName || '';
        const currentPersonaPreset = state.userPersonaPresets.find(p => p.description === contact.userPersona);
        document.getElementById('select-user-persona-preset').value = currentPersonaPreset ? currentPersonaPreset.id : '';
        
        // ▼▼▼ 核心修复从这里开始 ▼▼▼
        // ✨✨✨ 在这里加上下面这行新代码！ ✨✨✨
await populateThoughtPresetSelect();

        const thoughtPresetSelect = document.getElementById('thought-preset-select');
        const savedThoughtPresetId = contact.thoughtPreset;

        // 检查联系人保存的预设ID是否仍然存在于预设列表中
        const thoughtPresetExists = state.thoughtPresets.some(p => p.id === savedThoughtPresetId);

        if (savedThoughtPresetId && thoughtPresetExists) {
            // 如果预设确实还存在，就正常选中它
            thoughtPresetSelect.value = savedThoughtPresetId;
        } else {
            // 如果预设不存在（说明已被删除），就重置为空，并顺便清理掉角色身上的无效ID
            thoughtPresetSelect.value = ""; // 在界面上选中“无预设”
            contact.thoughtPreset = ""; // 清理掉角色数据里的无效ID
        }
        // ▲▲▲ 核心修复到这里结束 ▲▲▲

        document.querySelectorAll('.world-book-checkbox').forEach(cb => {
            cb.checked = (contact.worldBooks || []).includes(cb.value);
        });
        // 【新增】填充新的世界书选择器 (用于窥探)
const snoopWorldBookList = document.getElementById('snoop-world-book-selector-list');
snoopWorldBookList.innerHTML = ''; // 先清空旧的内容
state.worldBooks.forEach(book => { // 遍历所有可用的世界书
    // 检查这本书是否在联系人专门为窥探功能保存的列表里
    const isChecked = (contact.snoopRelevantWorldBookIds || []).includes(book.id);
    const bookItem = document.createElement('div');
    bookItem.className = 'world-book-item'; // 复用样式
    // 创建复选框和标签，根据 isChecked 决定是否默认勾选
    bookItem.innerHTML = `<input type="checkbox" class="world-book-checkbox" id="snoop-book-setting-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="snoop-book-setting-${book.id}" class="world-book-name">${book.name}</label>`;
    snoopWorldBookList.appendChild(bookItem); // 将创建好的条目添加到新的列表容器中
});
        document.getElementById('narrative-mode-toggle').checked = contact.isNarrativeMode;
        document.getElementById('time-awareness-toggle').checked = contact.isTimeAware ?? false;
        document.getElementById('hide-avatar-toggle').checked = contact.isAvatarHidden;
        // ▼▼▼ 使用这两行替换上面那一行 ▼▼▼
document.getElementById('char-voice-provider-select').value = contact.voiceProvider || '';
document.getElementById('char-voice-id-input').value = contact.voiceId || '';
        // ▼▼▼ 在这里粘贴下面2行新代码 ▼▼▼
        document.getElementById('user-voice-provider-select').value = contact.userVoiceProvider || '';
        document.getElementById('user-voice-id-input').value = contact.userVoiceId || '';
        // ▲▲▲ 粘贴结束 ▲▲▲
        document.getElementById('char-profile-screen').style.display = 'none';
        // ... (上面是原有的 snoopWorldBookList 填充逻辑) ...

        // ▼▼▼ 【新增】填充表情分组选择器 ▼
        const snoopSelector = document.querySelector('#snoop-world-book-selector-list').closest('.world-book-selector');
        
        // 检查是否已经添加过（防止重复添加）
        let emoSelectorContainer = document.getElementById('emo-group-selector-container');
        
        if (!emoSelectorContainer) {
            emoSelectorContainer = document.createElement('div');
            emoSelectorContainer.id = 'emo-group-selector-container';
            emoSelectorContainer.className = 'world-book-selector';
            emoSelectorContainer.style.marginTop = '15px';
            // 插入到 DOM 中
            snoopSelector.parentNode.insertBefore(emoSelectorContainer, snoopSelector.nextSibling);
        }

        // 渲染内容
        emoSelectorContainer.innerHTML = `
            <div class="world-book-selector-title">允许使用的表情分组</div>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
                勾选该角色在聊天中可以使用的表情包分组。
            </p>
            <div class="world-book-list" id="contact-emo-group-list"></div>
        `;

        const emoGroupList = document.getElementById('contact-emo-group-list');
        // 获取当前联系人已允许的分组 (如果未设置，默认允许 'default')
        const allowedGroups = contact.allowedEmoticonGroups || ['default'];
        
        state.emoticonGroups.forEach(group => {
            const isChecked = allowedGroups.includes(group.id);
            const item = document.createElement('div');
            item.className = 'world-book-item';
            item.innerHTML = `
                <input type="checkbox" class="world-book-checkbox emo-group-check" id="emo-group-${group.id}" value="${group.id}" ${isChecked ? 'checked' : ''}>
                <label for="emo-group-${group.id}" class="world-book-name">${group.name}</label>
            `;
            emoGroupList.appendChild(item);
        });
        // ▲▲▲ 新增结束 ▲▲▲
        document.getElementById('contact-settings-screen').style.display = 'flex';
        await updateContactMapSelector();
    }
});
        // ▲▲▲ 替换结束 ▲▲▲
// (粘贴到 attachEventListeners 函数的末尾)
    document.getElementById('refresh-snoop-app-btn').addEventListener('click', handlePartialSnoopRefresh);
        // ▼▼▼ 把这段全新的代码，完整地粘贴到 attachEventListeners 函数的【末尾】 ▼▼▼
        // --- 新增：为联系人设置页面的新按钮绑定事件 ---
        document.getElementById('upload-contact-background-btn').addEventListener('click', () => {
            const uploader = document.getElementById('contact-background-uploader');
            uploader.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (event) => {
                    const contact = state.contacts.find(c => c.id === state.activeChatId);
                    if (!contact) return;
                    contact.customChatBackground = event.target.result;
                    await kokoMemory.put('contacts', contact);
                    alert('专属聊天背景已更新！');
                };
                reader.readAsDataURL(file);
                e.target.value = '';
            };
            uploader.click();
        });

        document.getElementById('reset-contact-background-btn').addEventListener('click', async () => {
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if (!contact) return;
            contact.customChatBackground = null;
            await kokoMemory.put('contacts', contact);
            alert('背景已恢复默认。');
        });

        document.getElementById('upload-contact-user-avatar-btn').addEventListener('click', () => {
            const uploader = document.getElementById('contact-user-avatar-uploader');
            uploader.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (event) => {
                    const contact = state.contacts.find(c => c.id === state.activeChatId);
                    if (!contact) return;
                    const base64 = event.target.result;
                    contact.customUserAvatar = base64;
                    await kokoMemory.put('contacts', contact);
                    document.getElementById('custom-user-avatar-preview').src = base64;
                    document.getElementById('custom-user-avatar-preview').style.display = 'block';
                    alert('专属头像已更新！');
                };
                reader.readAsDataURL(file);
                e.target.value = '';
            };
            uploader.click();
        });
        
        document.getElementById('reset-contact-user-avatar-btn').addEventListener('click', async () => {
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if (!contact) return;
            contact.customUserAvatar = null;
            await kokoMemory.put('contacts', contact);
            document.getElementById('custom-user-avatar-preview').style.display = 'none';
            alert('头像已恢复为你的全局默认头像。');
        });
        // ▲▲▲ 新增代码粘贴到这里结束 ▲▲▲
    document.getElementById('view-char-diary-btn').addEventListener('click', showDiaryScreen);
    // ▼▼▼ 将这段完整的代码粘贴到 attachEventListeners 函数中 ▼▼▼
document.getElementById('diary-content-list').addEventListener('click', async (e) => {
    // 检查点击的是不是删除按钮
    if (e.target.closest('.diary-delete-btn')) {
        const diaryId = e.target.closest('.diary-delete-btn').dataset.diaryId;
        const confirmed = await showCustomConfirm('删除日记', '确定要删除这条日记吗？', true);
        if (confirmed) {
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if(contact && contact.diary) {
                // 从联系人的日记数组中过滤掉要删除的条目
                contact.diary = contact.diary.filter(entry => entry.id !== diaryId);
                // 保存更改到数据库
                await kokoMemory.put('contacts', contact);
                // 重新渲染日记列表，让界面刷新
                renderDiary();
            }
        }
    }
});
    document.getElementById('delete-contact-btn').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        const confirmed = await showCustomConfirm('删除联系人', `⚠️ 警告：确定要永久删除联系人 "${contact.name}" 吗？\n\n此操作将删除其所有聊天记录和日记，且无法恢复！`, true);
        if (confirmed) {
            state.contacts = state.contacts.filter(c => c.id !== state.activeChatId);
            await kokoMemory.delete('contacts', state.activeChatId);
            state.activeChatId = null;
            alert(`联系人 "${contact.name}" 已被删除。`);
            await showMainScreen();
        }
    });
document.getElementById('clear-chat-history-btn').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        
        // (确认弹窗逻辑不变)
        const confirmed = await showCustomConfirm('清空所有记录', `确定要清空与 "${contact.name}" 的所有记录吗？\n\n这将同时删除：\n1. App内的聊天记录\n2. 短信对话记录\n\n此操作不可恢复！`, true);
        
        if (confirmed) {
            contact.history = [];
            contact.smsHistory = []; 
            
            await kokoMemory.put('contacts', contact);
            alert('聊天和短信记录已全部清空。');
            
            // ▼▼▼ 核心修复就在这两行 ▼▼▼
            // 1. 关闭当前的“设置”页面
            document.getElementById('contact-settings-screen').style.display = 'none';
            // 2. 强制重新打开（刷新）聊天页面，而不是返回角色资料页！
            openChat(contact.id); 
            // ▲▲▲ 修复结束 ▲▲▲
        }
    });
    document.getElementById('char-profile-screen').addEventListener('click', async (e) => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        if (e.target.id === 'adopt-pet-btn') {
            contact.pet = {
                name: '史莱姆',
                stage: 1,
                happiness: 80,
                hunger: 80,
                cleanliness: 100,
                lastUpdated: Date.now(),
                workFinishTimestamp: null,
                xp: 0,
                level: 1,
                form: 'baby'
            };
            await kokoMemory.put('contacts', contact);
            renderPet(contact);
            await requestAiReply(`[SYSTEM: 我们刚刚领养了一只宠物史莱姆！请开心地和我说这件事。]`);
        } else if (e.target.id === 'feed-pet-btn') {
            if (contact.gold_coins >= 5) {
                contact.gold_coins -= 5;
                await updatePetStats('hunger', 20, contact);
                renderPet(contact);
                batchedPetActions.push(`你喂食了它`);
                triggerPetAnimation('blush');
            } else {
                alert('金币不足！快去打工吧！');
            }
        } else if (e.target.id === 'play-pet-btn') {
            await updatePetStats('happiness', 20, contact);
            renderPet(contact);
            batchedPetActions.push(`你陪它玩耍了`);
            triggerPetAnimation('jiggle');
        } else if (e.target.id === 'clean-pet-btn') {
            await updatePetStats('cleanliness', 40, contact);
            renderPet(contact);
            batchedPetActions.push(`你帮它打扫干净了`);
        } else if (e.target.id === 'work-pet-btn') {
            contact.pet.workFinishTimestamp = Date.now() + (1000 * 60 * 60); // 1 hour
            await kokoMemory.put('contacts', contact);
            renderPet(contact);
            setTimeout(async () => {
                const currentContact = await kokoMemory.get('contacts', contact.id);
                if (currentContact && currentContact.pet) {
                    currentContact.gold_coins += 50;
                    currentContact.pet.workFinishTimestamp = null;
                    await kokoMemory.put('contacts', currentContact);
                    state.contacts = await kokoMemory.getAll('contacts');
                    await createAndAddMessage({
                        type: 'system_notification',
                        sender: 'system',
                        content: `你们的史莱姆'${currentContact.pet.name}'打工回来啦！赚了50金币！`
                    });
                    if (state.activeChatId === currentContact.id && document.getElementById('char-profile-screen').style.display === 'flex') {
                        renderPet(currentContact);
                    }
                }
            }, 1000 * 60 * 60);
        } else if (e.target.id === 'view-memory-album-btn' || e.target.closest('#view-memory-album-btn')) {
            showMemoryAlbum(contact);
        } else if (e.target.id === 'pet-name') {
            const newName = await showCustomPrompt('给你的史莱姆起一个新名字吧：', contact.pet.name);
            if (newName && newName.trim()) {
                contact.pet.name = newName.trim();
                await kokoMemory.put('contacts', contact);
                renderPet(contact);
            }
        }
    });
    document.getElementById('edit-char-name-btn').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        const newName = await showCustomPrompt('设置备注名', contact.name);
        if (newName !== null && newName.trim() !== '') {
            contact.name = newName.trim();
            await kokoMemory.put('contacts', contact);
            showCharProfileScreen();
            document.getElementById('chat-contact-name').textContent = contact.name;
            await renderContacts();
        }
    });
    document.getElementById('edit-char-signature-btn').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        const newSignature = await showCustomPrompt('设置签名', contact.signature || '');
        if (newSignature !== null) {
            contact.signature = newSignature.trim();
            await kokoMemory.put('contacts', contact);
            showCharProfileScreen();
        }
    });

    // --- 原有功能：我的资料页编辑按钮 ---
    document.querySelectorAll('.profile-details .edit-btn[data-field]').forEach(button => {
        button.addEventListener('click', async function() {
            const field = this.dataset.field;
            const currentValue = state.myProfile[field];
            const title = `修改 ${fieldNameToChinese(field)}`;
            const newValue = await showCustomPrompt(title, currentValue);
            if (newValue !== null) {
                state.myProfile[field] = newValue.trim();
                renderMyProfile();
                await kokoMemory.put('myProfile', state.myProfile);
            }
        });
    });
    document.getElementById('edit-status-btn').addEventListener('click', async () => {
        const currentStatus = state.myProfile.status;
        const newStatus = await showCustomPrompt('修改我的状态', currentStatus);
        if (newStatus !== null) {
            state.myProfile.status = newStatus.trim();
            await kokoMemory.put('myProfile', state.myProfile);
            renderMyProfile();
        }
    });
    document.getElementById('initialize-app-btn').addEventListener('click', async function() {
        const confirmed = await showCustomConfirm('初始化应用', '警告：这会清空所有保存的数据（联系人、世界书、论坛帖子、API设置等）并恢复到初始状态。确定要继续吗？', true);
        if (confirmed) {
            await kokoMemory.deleteDatabase();
            window.location.reload();
        }
    });
  // ==========================================================
    // =========== ▼▼▼ 购物中心事件连接 V3 ▼▼▼ ===================
    // ==========================================================
    document.getElementById('shopping-center-btn').addEventListener('click', showShoppingScreen);
    // 新增：为购物中心主页的返回按钮添加事件
document.getElementById('back-from-shopping').addEventListener('click', showDiscoverScreen);
    // V3新增：详情页返回按钮的事件连接
document.getElementById('back-from-product-detail').addEventListener('click', () => {
    hideAllScreens();
    document.getElementById('shopping-screen').style.display = 'flex';
});


    document.getElementById('shopping-tabs-container').addEventListener('click', async (e) => {
        if (e.target.classList.contains('feed-tab-btn')) {
            activeShoppingTab = e.target.dataset.tab;
            renderShoppingTabs();
            // V3改动：切换标签页时，优先从数据库加载
            const savedProducts = await kokoMemory.get('userSettings', 'shopping_products_' + activeShoppingTab);
            if (savedProducts && savedProducts.data.length > 0) {
                renderProducts(savedProducts.data);
            } else {
                 const productList = document.getElementById('product-list');
                productList.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: #888;">这里空空如也~<br>请点击右上角的刷新按钮生成商品</div>`;
            }
        }
    });

    document.getElementById('refresh-products-btn').addEventListener('click', () => refreshProductsAI(false));
    document.getElementById('product-search-btn').addEventListener('click', () => refreshProductsAI(true));
    document.getElementById('product-search-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            refreshProductsAI(true);
        }
    });

    // V3改动：事件委托现在需要处理两种点击：分享和进入详情
    document.getElementById('product-list').addEventListener('click', (e) => {
        const productItem = e.target.closest('.product-item');
        if (!productItem) return;

        const productData = JSON.parse(productItem.dataset.product);

        // 如果点击的是分享按钮
        if (e.target.closest('.product-share-btn')) {
            e.stopPropagation(); // 阻止事件冒泡触发详情页
            openShareProductModal(productData);
        } else { // 否则就是点击卡片本身，进入详情
            showProductDetailScreen(productData);
        }
    });
    
    // V3新增：详情页底部分享按钮的事件
    document.getElementById('share-from-detail-btn').addEventListener('click', () => {
        // currentProductData 已在 showProductDetailScreen 中被赋值
        if (currentProductData) {
            openShareProductModal(currentProductData);
        }
    });

    // 分享弹窗的按钮事件 (不变)
    document.getElementById('close-share-product-modal').addEventListener('click', () => {
        document.getElementById('share-product-modal').style.display = 'none';
    });
    document.getElementById('gift-product-btn').addEventListener('click', () => {
    const selectedRadio = document.querySelector('input[name="share-recipient"]:checked');
    if (!selectedRadio) {
        return alert('请先选择一位要分享的联系人！');
    }
    handleShareProduct('gift', selectedRadio.value);
});

document.getElementById('request-payment-btn').addEventListener('click', () => {
    const selectedRadio = document.querySelector('input[name="share-recipient"]:checked');
    if (!selectedRadio) {
        return alert('请先选择一位要分享的联系人！');
    }
    handleShareProduct('request_payment', selectedRadio.value);
});


    // ==========================================================
    // =========== ▲▲▲ 购物中心事件连接 END ▲▲▲ =================
    // ==========================================================

    // --- 原有功能：各类弹窗的逻辑 ---
    document.getElementById('add-contact-btn').addEventListener('click', () => {
        document.getElementById('add-contact-modal').style.display = 'flex';
    });
    document.getElementById('close-contact-modal').addEventListener('click', () => {
        document.getElementById('add-contact-modal').style.display = 'none';
    });
    document.getElementById('save-contact-btn').addEventListener('click', async () => {
        const name = document.getElementById('contact-name-input').value.trim();
        const persona = document.getElementById('contact-persona-input').value.trim();
        if (!name || !persona) return alert('请填写姓名和人设');
        const avatar = document.getElementById('contact-avatar-input').value.trim();
        const selectedBooks = Array.from(document.getElementById('world-book-select').selectedOptions).map(opt => opt.value);
        // ...
const newContact = {
    id: 'contact_' + Date.now(),
    name: name,
    persona: persona,
    avatar: avatar || `https://s21.ax1x.com/2025/11/09/pZ9FrMd.png`,
    voiceId: '',
    worldBooks: JSON.parse(JSON.stringify(selectedBooks)),
    isPinned: false,
    groupId: null,
    history: [],
    diary: [],
    userPersona: '',
    thoughtPreset: 'deep_roleplay_regex',
    signature: '',
    isNarrativeMode: false,
    apiCallCounter: 0,
    pet: null,
    gold_coins: 50,
    memories: [],
    isChatPetVisible: false,
    sharedPlaylist: {
        tracks: [],
        currentIndex: 0,
        playbackMode: 'list',
        isPlaying: false
    },
    totalListenTime: 0,
    firstChatDate: Date.now(),
    
    // ▼▼▼ 在这里添加下面这两行新代码 ▼▼▼
    schedule: [], // 存放你的日程表
    events: [],    // 存放重要的日子（纪念日、生理期等）
    // ▲▲▲ 添加结束 ▲▲▲
    blockedStatus: 'none'
};
// ...
        state.contacts.push(newContact);
        await kokoMemory.put('contacts', newContact);
        await renderContacts();
        document.getElementById('add-contact-modal').style.display = 'none';
    });
// (替换) 'save-contact-settings-btn' 监听器 (在 attachEventListeners 中)
document.getElementById('save-contact-settings-btn').addEventListener('click', async () => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;
    const oldNarrativeModeState = contact.isNarrativeMode;
    
    contact.persona = document.getElementById('char-mask-textarea').value;
    contact.userPersona = document.getElementById('user-mask-textarea').value;
    contact.thoughtPreset = document.getElementById('thought-preset-select').value;
    contact.customUserName = document.getElementById('custom-user-name-input').value.trim() || null;

    // ▼▼▼ 核心修复点在这里 ▼▼▼
    // 1. (聊天) 只查找 #world-book-selector-list 内部的勾选
    contact.worldBooks = Array.from(document.querySelectorAll('#world-book-selector-list .world-book-checkbox:checked')).map(cb => cb.value);
    
    // 2. (窥探) 只查找 #snoop-world-book-selector-list 内部的勾选
    contact.snoopRelevantWorldBookIds = Array.from(document.querySelectorAll('#snoop-world-book-selector-list .world-book-checkbox:checked')).map(cb => cb.value);
    // ▲▲▲ 修复结束 ▲▲▲

    const newNarrativeModeState = document.getElementById('narrative-mode-toggle').checked;
    contact.isNarrativeMode = newNarrativeModeState;
    contact.isTimeAware = document.getElementById('time-awareness-toggle').checked;
    contact.isAvatarHidden = document.getElementById('hide-avatar-toggle').checked;
    contact.mapId = document.getElementById('contact-map-select').value;
    contact.customBubbleCss = document.getElementById('contact-bubble-css-input').value.trim() || null;
    contact.voiceProvider = document.getElementById('char-voice-provider-select').value;
    contact.voiceId = document.getElementById('char-voice-id-input').value.trim();
    // ▼▼▼ 在这里粘贴下面2行新代码 ▼▼▼
    contact.userVoiceProvider = document.getElementById('user-voice-provider-select').value;
    contact.userVoiceId = document.getElementById('user-voice-id-input').value.trim();
    // ▲▲▲ 粘贴结束 ▲▲▲

    if (oldNarrativeModeState === true && newNarrativeModeState === false) {
        contact.needsNarrativeModeExitPrompt = true;
    }
    // ▼▼▼ 【新增】保存表情分组配置 ▼▼▼
    const selectedEmoGroups = Array.from(
        document.querySelectorAll('#contact-emo-group-list .emo-group-check:checked')
    ).map(cb => cb.value);
    
    // 如果用户啥都没选，为了防止AI报错，强制给一个 'default'
    if (selectedEmoGroups.length === 0) {
        contact.allowedEmoticonGroups = ['default'];
    } else {
        contact.allowedEmoticonGroups = selectedEmoGroups;
    }
    // ▲▲▲ 新增结束 ▲▲▲
    await kokoMemory.put('contacts', contact);
    document.getElementById('contact-settings-screen').style.display = 'none';
    showCharProfileScreen();
    alert('联系人设置已保存！');
});
    document.getElementById('select-user-persona-preset').addEventListener('change', function() {
        const selectedPresetId = this.value;
        const preset = state.userPersonaPresets.find(p => p.id === selectedPresetId);
        document.getElementById('user-mask-textarea').value = preset ? preset.description : '';
    });
    document.getElementById('fetch-models-btn').addEventListener('click', (e) => {
        const apiKey = document.getElementById('api-key-input').value;
        const endpoint = document.getElementById('api-endpoint-input').value.trim();
        fetchModels(endpoint, apiKey, document.getElementById('model-select'), e.currentTarget);
    });
    document.getElementById('fetch-square-models-btn').addEventListener('click', (e) => {
        const apiKey = document.getElementById('square-api-key-input').value;
        const endpoint = document.getElementById('square-api-endpoint-input').value.trim();
        fetchModels(endpoint, apiKey, document.getElementById('square-model-select'), e.currentTarget);
    });
document.getElementById('save-api-settings-btn').addEventListener('click', async () => {
    state.apiSettings.apiKey = document.getElementById('api-key-input').value;
    state.apiSettings.model = document.getElementById('model-select').value;
    state.apiSettings.endpoint = document.getElementById('api-endpoint-input').value.trim();
    state.apiSettings.contextLength = parseInt(document.getElementById('context-length-input').value, 10) || 20;
    state.apiSettings.longTermMemoryLength = parseInt(document.getElementById('long-term-memory-length-input').value, 10) || 30;

    // ▼▼▼ 新增这两行 ▼▼▼
    state.apiSettings.minimaxGroupId = document.getElementById('minimax-group-id-input').value.trim();
    state.apiSettings.minimaxApiKey = document.getElementById('minimax-api-key-input').value.trim();
    // ▲▲▲ 新增结束 ▲▲▲
    // ▼▼▼ 新增这一行 ▼▼▼
state.apiSettings.siliconflowApiKey = document.getElementById('siliconflow-api-key-input').value.trim();
// ▼▼▼ 新增：保存温度和Token ▼▼▼
    // 温度是小数，用 parseFloat；Token是整数，用 parseInt
    const tempInput = document.getElementById('api-temperature-input').value;
    state.apiSettings.temperature = tempInput === '' ? null : parseFloat(tempInput);

    const tokenInput = document.getElementById('api-max-tokens-input').value;
    state.apiSettings.maxTokens = tokenInput === '' ? null : parseInt(tokenInput, 10);
    // ▲▲▲ 新增结束 ▲▲▲

    await kokoMemory.put('apiSettings', {
        id: 'main',
        ...state.apiSettings
    });
    alert('聊天API设置已保存！');
    showDiscoverScreen();
});
// ✨✨✨ 这是修复后的新代码，请复制并替换上面那段旧代码 ✨✨✨
document.getElementById('save-square-api-settings-btn').addEventListener('click', async () => {
    // --- 1. 【新增】保存论坛专用的API设置 ---
    state.squareApiSettings.apiKey = document.getElementById('square-api-key-input').value;
    state.squareApiSettings.endpoint = document.getElementById('square-api-endpoint-input').value.trim();
    state.squareApiSettings.model = document.getElementById('square-model-select').value;
    await kokoMemory.put('squareApiSettings', { id: 'main', ...state.squareApiSettings });

    // --- 2. 读取用户输入的风格、世界观等设置 ---
    const newSettings = {
        personaId: document.getElementById('forum-persona-select').value,
        worldBookIds: Array.from(document.querySelectorAll('#forum-worldbook-list .world-book-checkbox:checked')).map(cb => cb.value),
        styleDescription: document.getElementById('forum-style-description').value.trim(),
        allowedPosterIds: Array.from(document.querySelectorAll('#forum-allowed-posters-list .poster-checkbox:checked')).map(cb => cb.value)
    };

    // --- 3. 检查与当前设置是否有变化 (这部分逻辑不变) ---
    const currentSettings = state.forumSettings;
    const isChanged = JSON.stringify(newSettings.worldBookIds.sort()) !== JSON.stringify((currentSettings.worldBookIds || []).sort()) ||
                    newSettings.styleDescription !== (currentSettings.styleDescription || '');

    // --- 4. 根据是否变化，执行存档逻辑 (这部分逻辑不变) ---
    if (isChanged && state.activeForumArchiveId === 'default' && state.posts.some(p => p.archiveId === 'default')) {
        const userChoice = await showCustomConfirm(
            '世界观已变更',
            '检测到核心世界观已修改。是否要将当前论坛存档，并开启一条新的世界线？\n\n- 选择【确定】将存档并开启新世界。\n- 选择【取消】将仅覆盖当前设定。',
            false
        );

        if (userChoice) { 
            const archiveName = await showCustomPrompt('为当前世界线命名', `存档 ${new Date().toLocaleDateString()}`);
            if (archiveName) {
                const newArchive = {
                    id: 'archive_' + Date.now(),
                    name: archiveName,
                    timestamp: Date.now(),
                    settings: JSON.parse(JSON.stringify(currentSettings))
                };
                state.forumArchives.push(newArchive);
                await kokoMemory.put('forumArchives', newArchive);
                const defaultPosts = state.posts.filter(p => p.archiveId === 'default');
                defaultPosts.forEach(p => p.archiveId = newArchive.id);
                await kokoMemory.bulkPut('posts', defaultPosts);
                state.trendingTopics = [];
                await kokoMemory.clear('trendingTopics');
                alert(`存档“${archiveName}”创建成功！即将开启新世界线...`);
            }
        }
    }

    // --- 5. 无论如何，都应用并保存新的风格设置 (这部分逻辑不变) ---
    state.forumSettings = { ...currentSettings, ...newSettings };
    await kokoMemory.put('forumSettings', { id: 'main', ...state.forumSettings });

    alert('论坛API及风格设置已保存！');
    showDiscoverScreen();
});
        
    document.getElementById('add-world-book-btn').addEventListener('click', () => {
        editingBookId = null;
        document.getElementById('world-book-modal-title').textContent = '添加世界书';
        document.getElementById('book-name-input').value = '';
        document.getElementById('book-content-input').value = '';
        document.getElementById('add-world-book-modal').style.display = 'flex';
    });
    document.getElementById('close-world-book-modal').addEventListener('click', () => {
        document.getElementById('add-world-book-modal').style.display = 'none';
    });
    // ✨✨✨ 用这个新版本，完整替换旧的 save-world-book-btn 事件监听函数 ✨✨✨

    document.getElementById('save-world-book-btn').addEventListener('click', async () => {
        const name = document.getElementById('book-name-input').value.trim();
        const content = document.getElementById('book-content-input').value.trim();
        // --- 新增代码：获取分类 ---
        const category = document.getElementById('book-category-input').value.trim() || '未分类';

        if (!name || !content) return alert('请填写书名和内容');

        if (editingBookId) {
            const book = state.worldBooks.find(b => b.id === editingBookId);
            if (book) {
                book.name = name;
                book.content = content;
                book.category = category; // --- 新增代码：更新分类 ---
                await kokoMemory.put('worldBooks', book);
            }
        } else {
            const newBook = {
                id: 'book_' + Date.now(),
                name,
                content,
                category // --- 新增代码：保存分类 ---
            };
            state.worldBooks.push(newBook);
            await kokoMemory.put('worldBooks', newBook);
        }

        // 后续逻辑保持不变
        await renderWorldBooks();
        await updateWorldBookSelectors();
        document.getElementById('add-world-book-modal').style.display = 'none';

        // 重新为删除按钮绑定事件（这一行很重要，确保新渲染的元素也能被删除）
        document.querySelectorAll('.delete-world-book-btn').forEach(btn => {
            btn.addEventListener('click', deleteWorldBook);
        });
    });
// 2. (替换) “添加面具”按钮：重置表单和头像 (在 attachEventListeners 中)
document.getElementById('add-user-persona-preset-btn').addEventListener('click', () => {
    editingUserPersonaId = null;
    currentEditingPersonaAvatar = null; 
    document.getElementById('user-persona-modal-title').textContent = '添加用户面具预设';
    document.getElementById('user-persona-name-input').value = '';
    document.getElementById('user-persona-signature-input').value = ''; // <-- 新增
    document.getElementById('user-persona-description-input').value = '';
    
    const preview = document.getElementById('user-persona-avatar-preview');
    preview.src = '';
    preview.style.display = 'none';
    
    document.getElementById('user-persona-preset-modal').style.display = 'flex';
});
    document.getElementById('close-user-persona-preset-modal').addEventListener('click', () => {
        document.getElementById('user-persona-preset-modal').style.display = 'none';
    });
// 4. (替换) “保存面具”按钮：保存新头像和签名 (在 attachEventListeners 中)
document.getElementById('save-user-persona-preset-btn').addEventListener('click', async () => {
    const name = document.getElementById('user-persona-name-input').value.trim();
    const signature = document.getElementById('user-persona-signature-input').value.trim(); // <-- 新增
    const description = document.getElementById('user-persona-description-input').value.trim();
    const avatar = currentEditingPersonaAvatar; 

    if (!name || !description) return alert('请填写面具名称和描述！');
    
    if (editingUserPersonaId) {
        const preset = state.userPersonaPresets.find(p => p.id === editingUserPersonaId);
        if (preset) {
            preset.name = name;
            preset.signature = signature; // <-- 新增
            preset.description = description;
            preset.avatar = avatar; 
            await kokoMemory.put('userPersonaPresets', preset);
        }
    } else {
        const newPreset = {
            id: 'user_persona_' + Date.now(),
            name,
            signature, // <-- 新增
            description,
            avatar 
        };
        state.userPersonaPresets.push(newPreset);
        await kokoMemory.put('userPersonaPresets', newPreset);
    }
    await renderUserPersonaPresets();
    document.getElementById('user-persona-preset-modal').style.display = 'none';
});
// 4. (新增) 为新加的“上传头像”按钮添加事件
document.getElementById('upload-persona-avatar-btn').addEventListener('click', () => {
    document.getElementById('persona-avatar-uploader').click();
});

// 5. (新增) 处理头像文件选择
document.getElementById('persona-avatar-uploader').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        // 复用我们强大的 handleImageUpload 函数来压缩和转换图片
        const base64String = await handleImageUpload(file);

        // 显示预览
        const preview = document.getElementById('user-persona-avatar-preview');
        preview.src = base64String;
        preview.style.display = 'block';

        // 暂存 base64
        currentEditingPersonaAvatar = base64String;

    } catch (error) {
        console.error('面具头像处理失败:', error);
        alert('图片处理失败，请重试。');
    } finally {
        e.target.value = ''; // 清空 input，以便下次能选择同一张图
    }
});
    document.getElementById('add-thought-preset-btn').addEventListener('click', () => {
        editingThoughtPresetId = null;
        document.getElementById('thought-preset-modal-title').textContent = '添加思维预设';
        document.getElementById('thought-preset-name-input').value = '';
        document.getElementById('thought-preset-prompt-input').value = '';
        document.getElementById('thought-preset-modal').style.display = 'flex';
    });
    document.getElementById('close-thought-preset-modal').addEventListener('click', () => {
        document.getElementById('thought-preset-modal').style.display = 'none';
    });
    document.getElementById('save-thought-preset-btn').addEventListener('click', async () => {
        const name = document.getElementById('thought-preset-name-input').value.trim();
        const prompt = document.getElementById('thought-preset-prompt-input').value.trim();
        if (!name || !prompt) return alert('请填写预设名称和指令！');
        if (editingThoughtPresetId) {
            const preset = state.thoughtPresets.find(p => p.id === editingThoughtPresetId);
            if (preset) {
                preset.name = name;
                preset.prompt = prompt;
                await kokoMemory.put('thoughtPresets', preset);
            }
        } else {
            const newPreset = {
                id: `tp_${Date.now()}`,
                name,
                prompt
            };
            state.thoughtPresets.push(newPreset);
            await kokoMemory.put('thoughtPresets', newPreset);
        }
        await renderThoughtPresets();
        document.getElementById('thought-preset-modal').style.display = 'none';
    });
    document.getElementById('add-emoticon-btn').addEventListener('click', () => {
        const modal = document.getElementById('add-emoticon-modal');
        const modalBody = modal.querySelector('.modal-body');
        modal.querySelector('#close-emoticon-modal').addEventListener('click', () => modal.style.display = 'none');
        modal.querySelector('.modal-title').textContent = '批量添加表情包';
        modalBody.innerHTML = `<div class="form-group"><label class="form-label">表情包列表 (每行一个)</label><textarea class="form-textarea" id="emoticon-batch-input" placeholder="支持格式:\n1. URL\n2. 名字 URL\n3. URL 名字" style="height: 180px;"></textarea></div><button class="form-button" id="save-emoticon-batch-btn">导入表情</button>`;
        modal.style.display = 'flex';
        const saveBtn = document.getElementById('save-emoticon-batch-btn');
        const newSaveBtn = saveBtn.cloneNode(true);
        saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
        newSaveBtn.addEventListener('click', async () => {
            const text = document.getElementById('emoticon-batch-input').value.trim();
            if (!text) return;
            const lines = text.split('\n');
            const newEmoticons = [];
            let importedCount = 0;
            lines.forEach((line, index) => {
                line = line.trim();
                if (!line) return;
                const parts = line.split(/\s+/);
                let url = '',
                    name = '';
                const urlIndex = parts.findIndex(p => p.startsWith('http'));
                if (urlIndex !== -1) {
                    url = parts[urlIndex];
                    parts.splice(urlIndex, 1);
                    name = parts.join(' ').trim();
                } else {
                    return;
                }
                if (!name) {
                    name = `表情${state.emoticons.length + newEmoticons.length + 1}`;
                }
                newEmoticons.push({
                    id: `emo_${Date.now()}_${index}`,
                    name,
                    url,
                    // ▼▼▼ 新增这一行：归入当前选中的分组 ▼▼▼
                    groupId: activeEmoticonGroupId 
                    // ▲▲▲ 新增结束 ▲▲▲
                });
                importedCount++;
            });
            if (newEmoticons.length > 0) {
                state.emoticons = [...state.emoticons, ...newEmoticons];
                await kokoMemory.bulkPut('emoticons', newEmoticons);
                await renderEmoticonLibrary();
            }
            modal.style.display = 'none';
            alert(`成功导入 ${importedCount} 个表情包！`);
        });
    });
    // ▼▼▼ 这是全新的“添加/编辑歌曲”逻辑 (修正版) ▼▼▼
            document.getElementById('add-music-btn').addEventListener('click', () => {
                const modal = document.getElementById('add-music-modal');
                // 重置表单
                document.getElementById('add-music-modal-title').textContent = '添加歌曲';
                document.getElementById('add-music-title-input').value = '';
                document.getElementById('add-music-artist-input').value = '';
                document.getElementById('add-music-url-input').value = '';
                document.getElementById('add-music-lrc-input').value = '';
                modal.style.display = 'flex';

                // 移除旧的事件监听器，防止重复绑定
                const oldSaveBtn = document.getElementById('save-music-btn');
                const newSaveBtn = oldSaveBtn.cloneNode(true); // <-- 已修正
                oldSaveBtn.parentNode.replaceChild(newSaveBtn, oldSaveBtn); // <-- 已修正

                // 为新的保存按钮添加事件
            newSaveBtn.addEventListener('click', async () => {
                const title = document.getElementById('add-music-title-input').value.trim();
                const artist = document.getElementById('add-music-artist-input').value.trim();
                const url = document.getElementById('add-music-url-input').value.trim();
                let lrcInput = document.getElementById('add-music-lrc-input').value.trim();
                
                let finalLrc = lrcInput;
                // 智能解析逻辑
                if (lrcInput.startsWith('{') && lrcInput.endsWith('}')) {
                    try {
                        const parsedData = JSON.parse(lrcInput);
                        if (parsedData && parsedData.lrc && parsedData.lrc.lyric) {
                            finalLrc = parsedData.lrc.lyric;
                            console.log("成功从JSON中提取LRC歌词！");
                        }
                    } catch (e) {
                        console.log("尝试解析歌词JSON失败，将按原文处理。");
                    }
                }

                // ▼▼▼ 在这里添加关键的修复代码 ▼▼▼
                // 将文本 "\\n" 替换为真正的换行符 "\n"
                finalLrc = finalLrc.replace(/\\n/g, '\n');
                // ▲▲▲ 修复代码结束 ▲▲▲

                if (!title || !artist || !url) {
                    alert('歌曲名、歌手和URL是必填项！');
                    return;
                }

                const newSong = {
                    id: `music_${Date.now()}`,
                    title,
                    artist,
                    url,
                    lrc: finalLrc // 使用处理后的歌词
                };

                state.musicLibrary.push(newSong);
                await kokoMemory.put('musicLibrary', newSong);
                await renderMusicLibrary();
                
                modal.style.display = 'none';
                alert(`歌曲“${title}”已成功添加到音乐库！`);
            });
            });

            document.getElementById('close-add-music-modal').addEventListener('click', () => {
                document.getElementById('add-music-modal').style.display = 'none';
            });
    document.getElementById('emoji-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        const emoticonPicker = document.getElementById('emoticon-picker');
        document.getElementById('attachment-menu').classList.remove('active');
        emoticonPicker.classList.toggle('active');
        if (emoticonPicker.classList.contains('active')) {
            renderEmoticonPicker();
        }
    });
// 在 attachEventListeners 函数中...

// 新的、智能的附件按钮逻辑
document.getElementById('attachment-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return; // 安全检查

    const menu = document.getElementById('attachment-menu');

    // 基础项目：这些是所有聊天都具备的功能
    let menuHTML = `
        <div class="attachment-menu-item" data-action="send-picture">
            <div class="icon-wrapper"><i class="fas fa-image"></i></div>
            <div class="label">图片</div>
        </div>
        <div class="attachment-menu-item" data-action="upload-image">
            <div class="icon-wrapper"><i class="fas fa-upload"></i></div>
            <div class="label">上传图片</div>
        </div>
        <div class="attachment-menu-item" data-action="send-voice">
            <div class="icon-wrapper"><i class="fas fa-microphone"></i></div>
            <div class="label">语音</div>
        </div>
        <div class="attachment-menu-item" data-action="send-red-packet">
            <div class="icon-wrapper"><i class="fas fa-wallet"></i></div>
            <div class="label">红包</div>
        </div>
    `;

    // 核心判断：如果当前不是群聊（即私聊），才添加那些特殊的一对一功能
    if (!contact.isGroup) {
        menuHTML += `
            <div class="attachment-menu-item" data-action="send-transfer">
                <div class="icon-wrapper"><i class="fas fa-exchange-alt"></i></div>
                <div class="label">转账</div>
            </div>
            <div class="attachment-menu-item" data-action="share-music">
                <div class="icon-wrapper"><i class="fas fa-music"></i></div>
                <div class="label">音乐</div>
            </div>
            <div class="attachment-menu-item" data-action="game-wheel"> <div class="icon-wrapper"><i class="fas fa-bullseye"></i></div> <div class="label">转盘游戏</div>
            </div>
            <div class="attachment-menu-item" data-action="start-video-call">
                <div class="icon-wrapper"><i class="fas fa-video"></i></div>
                <div class="label">视频通话</div>
            </div>
            <div class="attachment-menu-item" data-action="send-location"> <div class="icon-wrapper"><i class="fas fa-map-marker-alt"></i></div> <div class="label">位置</div> </div>
        `;
    } else {
        // 如果是群聊，单独添加群聊转账功能
        menuHTML += `
            <div class="attachment-menu-item" data-action="send-group-transfer">
                <div class="icon-wrapper"><i class="fas fa-exchange-alt"></i></div>
                <div class="label">转账</div>
            </div>
        `;
    }


    menu.innerHTML = menuHTML; // 将构建好的HTML设置到菜单中

    document.getElementById('emoticon-picker').classList.remove('active');
    menu.classList.toggle('active');
});
    document.getElementById('attachment-menu').addEventListener('click', (e) => {
        const menuItem = e.target.closest('.attachment-menu-item');
        if (menuItem) {
            const action = menuItem.dataset.action;
            if (action) {
                handleAttachmentAction(action);
            }
        }
    });
    document.body.addEventListener('click', () => {
        document.getElementById('emoticon-picker').classList.remove('active');
        document.getElementById('attachment-menu').classList.remove('active');
    });
    document.getElementById('chat-screen').addEventListener('click', (e) => {
        if (!e.target.closest('#emoji-btn') && !e.target.closest('#emoticon-picker')) {
            document.getElementById('emoticon-picker').classList.remove('active');
        }
        if (!e.target.closest('#attachment-btn') && !e.target.closest('#attachment-menu')) {
            document.getElementById('attachment-menu').classList.remove('active');
        }
    });

    // --- 核心修改：聊天消息区的总事件代理 ---
    // --- 请将下面这个【完整代码块】粘贴到 attachEventListeners 函数中 ---

// 在 attachEventListeners 函数中...

// ▼▼▼ 用下面这个【最终完整无省略版】的代码块，替换掉您现有的 'chat-messages' 事件监听器 ▼▼▼
// ▼▼▼ 使用这个【最终完整版】，替换掉你现有的 'chat-messages' 事件监听器 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', async (e) => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    // 逻辑1：处理回复按钮和引用跳转 (保持不变)
    const replyBtn = e.target.closest('.reply-btn');
    const quoteBox = e.target.closest('.message-quote');
    const clickedWrapper = e.target.closest('.message-wrapper');

    if (replyBtn) {
        e.stopPropagation();
        const msgId = replyBtn.closest('.message-wrapper').dataset.messageId;
        const msgToReply = contact.history.find(m => m.id === msgId);
        if (msgToReply) {
            let contentToQuote = msgToReply.content;
            if (msgToReply.type === 'voice') contentToQuote = '[语音] ' + msgToReply.content.text;
            else if (msgToReply.type === 'picture_description') contentToQuote = '[图片]';
            else if (msgToReply.type === 'red_packet') contentToQuote = '[红包] ' + msgToReply.content.blessing;
            else if (msgToReply.type !== 'text') contentToQuote = `[${msgToReply.type}]`;
            activeReplyTarget = { ...msgToReply, content: contentToQuote.substring(0, 100) };
            showReplyPreview(activeReplyTarget);
            document.getElementById('message-input').focus();
        }
        return;
    }

    if (quoteBox) {
        e.stopPropagation();
        const quotedId = quoteBox.dataset.quotedId;
        const targetMessage = document.querySelector(`.message-wrapper[data-message-id="${quotedId}"]`);
        if (targetMessage) {
            targetMessage.scrollIntoView({ behavior: 'smooth', block: 'center' });
            targetMessage.classList.add('highlighted');
            setTimeout(() => targetMessage.classList.remove('highlighted'), 1500);
        } else {
            alert('原始消息已不在当前加载的聊天记录中。');
        }
        return;
    }
// ... (if (quoteBox) { ... return; })

// ▼▼▼ 用这段【新版】代码替换旧的 'aiRecallBubble' 逻辑 ▼▼▼
// 侦听AI撤回消息（包括“占位符”和“已揭示”两种状态）
const aiRecallPlaceholder = e.target.closest('.recall-ai-placeholder'); // 1. 灰色占位符
const aiRecallRevealed = e.target.closest('.system-notification.recall-ai-revealed'); // 2. 已点开的气泡(V4版)

if (aiRecallPlaceholder || aiRecallRevealed) {
    // 如果在编辑模式，就执行多选，不切换
    if (editModeState.active) return; 
    
    e.stopPropagation(); 
    const wrapper = e.target.closest('.message-wrapper[data-message-id]');
    if (!wrapper) return; 
    
    const msgId = wrapper.dataset.messageId;
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    
    if (contact) {
        const msg = contact.history.find(m => m.id === msgId);
        if (msg) {
            // 切换状态
            msg.isRevealed = !msg.isRevealed; 
            await kokoMemory.put('contacts', contact); 
            
            // 刷新UI（这里是关键，我们不能用openChat，会跳）
            // 我们需要一种“原地刷新”的方法
            
            // 1. 记住当前的滚动位置
            const messagesContainer = document.getElementById('chat-messages');
            const currentScrollTop = messagesContainer.scrollTop;
            
            // 2. 重新渲染整个聊天
            await openChat(contact.id); 
            
            // 3. 尝试恢复滚动位置
            messagesContainer.scrollTop = currentScrollTop;
            
            // 4. 再次滚动到被点击的元素，确保它在视野内
            setTimeout(() => {
               const toggledEl = document.querySelector(`.message-wrapper[data-message-id="${msgId}"]`);
               if (toggledEl) {
                   // 优化：只有在“点开”时才滚动，"关闭"时不滚动
                   if (msg.isRevealed) {
                       toggledEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                   }
               }
            }, 50); // 稍作延迟
        }
    }
    return; // 处理完毕
}
// ▲▲▲ 替换结束 ▲▲▲

// ... (你原来的 if (recallBtn) { ... } 逻辑)
// ▼▼▼ 在这里粘贴新的 else if 代码块 ▼▼▼
const recallBtn = e.target.closest('.recall-btn');
if (recallBtn) {
    e.stopPropagation(); // 阻止事件冒泡

    const wrapper = recallBtn.closest('.message-wrapper');
    const msgId = wrapper.dataset.messageId;

    // 1. 弹窗确认
    const confirmed = await showCustomConfirm('撤回消息', '确定要撤回这条消息吗？<br><small>(AI会知道你撤回了什么哦)</small>', true);

    if (confirmed) {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        const msg = contact.history.find(m => m.id === msgId);

        if (msg) {
            // 2. "变身"：将消息标记为已撤回
            msg.isRecalled = true;
            await kokoMemory.put('contacts', contact);

            // 3. 刷新UI
            await openChat(contact.id); 
        }
    }
    return; // 处理完毕
}
// ▲▲▲ 粘贴结束 ▲▲▲

// ... (你原来的 if (clickedWrapper) { ... } 逻辑)

    // 逻辑2：处理消息气泡本身的点击，以显示/隐藏回复按钮 (保持不变)
    if (clickedWrapper) {
        document.querySelectorAll('.message-wrapper.show-reply-btn').forEach(wrapper => {
            if (wrapper !== clickedWrapper) {
                wrapper.classList.remove('show-reply-btn');
            }
        });
        clickedWrapper.classList.toggle('show-reply-btn');
    }

    // 如果是编辑模式，则不执行后续的点击交互
    if (editModeState.active) return;

    // 逻辑3：处理其他交互（帖子分享、转盘、红包、音乐等，保持不变）
    const postShareCard = e.target.closest('.post-share-card');
    if (postShareCard) {
        const postId = postShareCard.dataset.postId;
        showPostDetailScreen(postId);
        return;
    }

    const wrapper = e.target.closest('.message-wrapper');
    if (!wrapper) return;
    const msgId = wrapper.dataset.messageId;
    const msg = contact.history.find(m => m.id === msgId);
    if (!msg) return;

    const spinButton = e.target.closest('.spin-btn');
    if (spinButton) {
        e.stopPropagation();
        if (msg && msg.type === 'game_wheel') {
            const player = spinButton.dataset.player;
            if (player === 'user' && !msg.content.results.user) {
                const wheel = msg.content;
                const weightedOptions = wheel.options.flatMap(opt => Array(opt.weight).fill(opt.text));
                const result = weightedOptions[Math.floor(Math.random() * weightedOptions.length)];
                msg.content.results.user = result;
                await kokoMemory.put('contacts', contact);
                await openChat(contact.id);
                const systemInstruction = `[SYSTEM: 在“${wheel.name}”游戏中，我转出的结果是“${result}”。现在轮到你了，请使用 [spin_wheel:1] 指令来转动你的转盘。]`;
                await createAndAddMessage({ type: 'text', content: systemInstruction }, 'system_instruction');
            }
        }
        return;
    }

    if (msg.type === 'music_share') {
        const card = wrapper.querySelector('.music-share-card');
        if (!card) return;
        state.musicSessionContactId = state.activeChatId;
        if (e.target.closest('.music-card-play-btn')) {
            e.stopPropagation();
            if (currentlyPlayingMsgId !== msg.id || globalAudioPlayer.paused) {
                if (currentlyPlayingMsgId !== msg.id) {
                    globalAudioPlayer.src = msg.content.url;
                    currentlyPlayingMsgId = msg.id;
                    const songIndex = contact.sharedPlaylist.tracks.findIndex(t => t.url === msg.content.url && t.title === msg.content.title);
                    if (songIndex !== -1) {
                       contact.sharedPlaylist.currentIndex = songIndex;
                       switchSong(songIndex, false);
                    }
                }
                globalAudioPlayer.play().catch(err => {
                    console.error("音频播放失败:", err);
                    alert("无法播放此音频链接。");
                });
            } else {
                globalAudioPlayer.pause();
            }
        } else {
            openMusicPlayer();
            const songIndex = contact.sharedPlaylist.tracks.findIndex(t => t.url === msg.content.url && t.title === msg.content.title);
            if (songIndex !== -1) {
                switchSong(songIndex);
            } else {
                contact.sharedPlaylist.tracks.unshift(msg.content);
                kokoMemory.put('contacts', contact);
                switchSong(0);
            }
        }
        return;
    }
const locationCard = e.target.closest('.location-share-card');
    if (locationCard) {
        const wrapper = locationCard.closest('.message-wrapper');
        const msgId = wrapper.dataset.messageId;
        const msg = contact.history.find(m => m.id === msgId);
    
        if (msg && msg.type === 'location_share') {
            const loc = msg.content;
            // ✅ 使用新的智能跳转函数
            // 注意：loc.locationId 是我们在创建消息时存进去的
            openMapAndFocusLocation(loc.mapId, loc.locationId);
        }
        return;
    }

    if (msg.type === 'red_packet') {
        let senderProfile;
        if (msg.sender === 'user') {
            senderProfile = state.myProfile;
        } else {
            senderProfile = state.contacts.find(c => c.id === msg.sender);
        }
        if (!senderProfile) senderProfile = { name: '未知用户', avatar: '' };
        showRedPacketModal(msg, senderProfile);
        return; // 处理完红包后结束
    }
    
    if (msg.type === 'transfer') {
        let senderProfile;
        if (msg.sender === 'user') {
            senderProfile = state.myProfile;
        } else {
            senderProfile = state.contacts.find(c => c.id === msg.sender);
        }
        if (!senderProfile) senderProfile = { name: '未知用户', avatar: '' };
        showTransferModal(msg, senderProfile);
        return; // 处理完转账后结束
    }

// ▼▼▼ [V-MOD 2.0] 拆分语音和图片的点击逻辑 ▼▼▼

// --- 逻辑 A: 处理 "翻转" 图片点击 ---
if (msg.type === 'picture_description') {
    e.stopPropagation(); // 阻止冒泡

    // 找到我们新创建的、带 .picture-description 类的气泡
    const bubble = wrapper.querySelector('.message.picture-description');
    if (bubble) {
        // == 你的要求：切换淡入/淡出 ==
        // 简单地切换CSS类，剩下的交给CSS去完成
        bubble.classList.toggle('description-visible');
    }
    return; // 处理完毕，结束
}

// --- 逻辑 B: 处理 "语音" 点击 (这段是你的旧逻辑，保持不变) ---
if (msg.type === 'voice') {
    const transcribedTextEl = wrapper.querySelector('.transcribed-text');
    if (!transcribedTextEl) return; // 安全检查

    const isCurrentlyVisible = transcribedTextEl.classList.contains('visible');

    // 1. 声音播放逻辑
    if (!isCurrentlyVisible) { // 只有在准备显示文字时才播放
        if (msg.sender === 'user') {
            playVoiceMessage(msg.content.text, contact, 'user').catch(err => {
                console.error("点击播放【用户】语音失败:", err.message);
            });
        } else {
            const senderProfile = state.contacts.find(c => c.id === msg.sender);
            if (senderProfile) {
                playVoiceMessage(msg.content.text, senderProfile, 'contact').catch(err => {
                    console.error("点击播放【AI】语音失败:", err.message);
                });
            }
        }
    }

    // 2. 外部文字显示/隐藏逻辑
    document.querySelectorAll('.transcribed-text.visible').forEach(el => {
        if (el !== transcribedTextEl) {
            el.classList.remove('visible');
            el.textContent = '';
        }
    });
    if (isCurrentlyVisible) {
        transcribedTextEl.classList.remove('visible');
        transcribedTextEl.textContent = '';
    } else {
        transcribedTextEl.textContent = msg.content.text;
        transcribedTextEl.classList.add('visible');
    }
}
// ▲▲▲ [V-MOD 2.0] 逻辑拆分结束 ▲▲▲
});

// ▲▲▲ 替换到这里结束 ▲▲▲

    // 新增：点击聊天屏幕的其他地方，隐藏所有回复按钮
    document.getElementById('chat-screen').addEventListener('click', (e) => {
        if (!e.target.closest('.message-wrapper')) {
            document.querySelectorAll('.message-wrapper.show-reply-btn').forEach(wrapper => {
                wrapper.classList.remove('show-reply-btn');
            });
        }
    });

    // --- V9.0 新增: 播放器内部按钮事件 ---
    document.getElementById('player-play-btn').addEventListener('click', () => {
        if (globalAudioPlayer.paused) globalAudioPlayer.play();
        else globalAudioPlayer.pause();
    });
    document.getElementById('player-collapse-btn').addEventListener('click', () => {
        card.classList.toggle('collapsed');
        document.getElementById('player-collapse-btn').classList.toggle('fa-chevron-down');
        document.getElementById('player-collapse-btn').classList.toggle('fa-chevron-up');
    });
    // ▼▼▼ 在这里添加新的事件监听 ▼▼▼
    document.getElementById('player-close-btn').addEventListener('click', closeMusicPlayer);
    document.getElementById('player-playlist-btn').addEventListener('click', () => {
        document.getElementById('player-playlist-view').classList.toggle('active');
    });
    document.getElementById('player-mode-btn').addEventListener('click', () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        const modes = ['repeat-all', 'repeat-one', 'off'];
        const icons = ['fa-repeat', 'fa-1', 'fa-power-off'];
        const titles = ['列表循环', '单曲循环', '播放完暂停'];
        let currentIndex = modes.indexOf(contact.sharedPlaylist.playbackMode || 'repeat-all');
        currentIndex = (currentIndex + 1) % modes.length;
        contact.sharedPlaylist.playbackMode = modes[currentIndex];
        const modeBtn = document.getElementById('player-mode-btn');
        modeBtn.className = `fas ${icons[currentIndex]} player-control-btn`;
        modeBtn.title = titles[currentIndex];
        kokoMemory.put('contacts', contact);
    });
    document.getElementById('player-next-btn').addEventListener('click', () => switchSong(currentSongIndex + 1, true, true));
document.getElementById('player-prev-btn').addEventListener('click', () => switchSong(currentSongIndex - 1, true, true));
    document.getElementById('player-progress-bar').addEventListener('click', function(e) {
        if (globalAudioPlayer.duration) {
            const rect = this.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            globalAudioPlayer.currentTime = (clickX / rect.width) * globalAudioPlayer.duration;
        }
    });

    document.getElementById('close-send-picture-modal').addEventListener('click', () => {
        document.getElementById('send-picture-modal').style.display = 'none';
    });
    document.getElementById('close-send-voice-modal').addEventListener('click', () => {
        document.getElementById('send-voice-modal').style.display = 'none';
    });
    document.getElementById('close-send-red-packet-modal').addEventListener('click', () => {
        document.getElementById('send-red-packet-modal').style.display = 'none';
    });
    document.getElementById('close-send-transfer-modal').addEventListener('click', () => {
        document.getElementById('send-transfer-modal').style.display = 'none';
    });
    document.getElementById('close-send-music-modal').addEventListener('click', () => {
        document.getElementById('send-music-modal').style.display = 'none';
    });

   // --- 新增：为红包详情弹窗的关闭按钮绑定事件 --- 
   document.getElementById('close-red-packet-details-modal').addEventListener('click', () => { document.getElementById('red-packet-details-modal').style.display = 'none'; });
    
      // --- 原有功能：论坛事件 ---
    document.getElementById('feed-tabs-container').addEventListener('click', (e) => {
        if (e.target.classList.contains('feed-tab-btn')) {
            state.activeFeedTab = e.target.dataset.tab;
            renderFeed();
        }
    });
    document.getElementById('feed-sub-tabs-container').addEventListener('click', (e) => {
        if (e.target.classList.contains('feed-sub-tab-btn')) {
            state.activeFeedSubTab = e.target.dataset.subtab;
            renderFeed();
        }
    });
    document.getElementById('moments-content').addEventListener('click', async (e) => {
        const repostBtn = e.target.closest('.repost-btn');
        if (repostBtn) {
            e.stopPropagation();
            openRepostModal(repostBtn.dataset.postId);
            return;
        }
        const redPacketCard = e.target.closest('.forum-red-packet-card');
        if (redPacketCard) {
            e.stopPropagation();
            openForumRedPacketModal(redPacketCard.dataset.postId);
            return;
        }
        const postItem = e.target.closest('.post-item');
        const trendingItem = e.target.closest('.trending-item');
        const deleteBtn = e.target.closest('.post-delete-btn');
        if (deleteBtn) {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除帖子', '确定要删除这条帖子吗？', true);
            if (confirmed) {
                const postId = deleteBtn.dataset.postId;
                state.posts = state.posts.filter(p => p.id !== postId);
                await kokoMemory.delete('posts', postId);
                await renderFeed();
            }
            return;
        }
        if (postItem) {
            showPostDetailScreen(postItem.dataset.postId);
        } else if (trendingItem) {
    const title = trendingItem.dataset.topicTitle;
    const description = trendingItem.dataset.description;

    // 直接调用新函数，并把标题和描述都传进去
    showTrendingTopicScreen(title, description); 
}
    });
    document.getElementById('trending-topic-screen').addEventListener('click', (e) => {
        const postItem = e.target.closest('.post-item');
        if (postItem) {
            showPostDetailScreen(postItem.dataset.postId);
        }
    });
    document.getElementById('refresh-feed-btn').addEventListener('click', async () => {
        const apiConfig = getApiFor('square');
        if (!apiConfig.apiKey || !apiConfig.endpoint) {
            alert('请先在“发现 -> 论坛API设置”中配置API。');
            return;
        }
        try {
            if (state.activeFeedTab === 'trending') {
                showFeedStatus('正在刷新热搜榜...');
                await generateRandomTrendingTopicsAI();
            } else if (state.activeFeedTab === 'recommended') {
                showFeedStatus('正在刷新推荐内容...');
                await generatePostsForRecommendedTab(5);
            } else {
                showFeedStatus('正在刷新关注内容...');
                await generatePostsForRecommendedTab(2);
            }
            await renderFeed();
        } catch (e) {
            console.error("刷新失败:", e);
            alert("刷新失败: " + e.message);
        } finally {
            hideFeedStatus();
        }
    });
    const commentInput = document.getElementById('comment-input');
    commentInput.addEventListener('blur', () => {
        if (commentInput.value.trim() === '' && activeReplyTarget) {
            activeReplyTarget = null;
            commentInput.placeholder = '留下你的精彩评论吧...';
        }
    });
// (新增) 为评论区图片按钮绑定事件
        document.getElementById('add-comment-image-btn').addEventListener('click', () => {
            document.getElementById('comment-image-uploader').click();
        });

        // (新增) 处理评论图片选择
        document.getElementById('comment-image-uploader').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            try {
                const base64String = await handleImageUpload(file);
                pendingCommentImage = base64String;
                document.getElementById('comment-image-preview').src = base64String;
                document.getElementById('comment-image-preview-container').style.display = 'block';
            } catch (error) {
                alert('图片处理失败: ' + error.message);
            }
            e.target.value = ''; // 清空
        });

        // (新增) 移除评论预览图片
        document.getElementById('remove-comment-image-btn').addEventListener('click', () => {
            pendingCommentImage = null;
            document.getElementById('comment-image-preview').src = '';
            document.getElementById('comment-image-preview-container').style.display = 'none';
        });

        // (替换) “发送评论”按钮 (V2 - 支持图片)
        document.getElementById('submit-comment-btn').addEventListener('click', async () => {
            const input = document.getElementById('comment-input');
            const content = input.value.trim();
            
            // 核心修改：有文字 或 有图，才允许发送
            if (!content && !pendingCommentImage) return;
            
            const post = state.posts.find(p => p.id === state.activePostId);
            if (post) {
                // (你原来的 authorProfile 逻辑保持不变)
                let authorProfile;
                const personaId = state.forumSettings.personaId;
                const persona = personaId ? state.userPersonaPresets.find(p => p.id === personaId) : null;

                if (persona) {
                    authorProfile = {
                        id: 'myProfile',
                        name: persona.name,
                        avatar: persona.avatar || state.myProfile.avatar
                    };
                } else {
                    authorProfile = {
                        id: 'myProfile',
                        name: state.myProfile.name,
                        avatar: state.myProfile.avatar
                    };
                }
                // (authorProfile 逻辑结束)

                const newComment = {
                    id: `comment_${Date.now()}`,
                    author: authorProfile,
                    content,
                    image: pendingCommentImage, // ★★★ 核心新增 ★★★
                    timestamp: Date.now(),
                    replyTo: activeReplyTarget ? activeReplyTarget.name : null
                };
                
                post.comments.push(newComment);
                
                // 清空输入框、清空引用、清空图片
                input.value = '';
                activeReplyTarget = null;
                input.placeholder = '留下你的精彩评论吧...';
                pendingCommentImage = null;
                document.getElementById('comment-image-preview-container').style.display = 'none';
                
                await kokoMemory.put('posts', post);
                await renderPostDetail(); // 刷新评论区
                
                // (AI 触发逻辑保持不变)
                await triggerAiCommentDiscussion(post, newComment);
            }
        });
    document.getElementById('comments-list').addEventListener('click', async (e) => {
        const commentItem = e.target.closest('.post-comment-item');
        if (!commentItem) return;
        const deleteBtn = e.target.closest('.comment-delete-btn');
        if (deleteBtn) {
            e.stopPropagation();
            const commentId = deleteBtn.dataset.commentId;
            const confirmed = await showCustomConfirm('删除评论', '确定要删除这条评论吗？', true);
            if (confirmed) {
                const post = state.posts.find(p => p.id === state.activePostId);
                if (post) {
                    post.comments = post.comments.filter(c => c.id !== commentId);
                    await kokoMemory.put('posts', post);
                    await renderPostDetail();
                }
            }
            return;
        }
        if (!e.target.closest('a, .mention, .comment-delete-btn')) {
            const authorName = commentItem.dataset.authorName;
            const authorId = commentItem.dataset.authorId;
            if (authorId === 'myProfile') return;
            activeReplyTarget = {
                name: authorName,
                id: authorId
            };
            const commentInput = document.getElementById('comment-input');
            commentInput.placeholder = `回复 @${authorName}`;
            commentInput.focus();
        }
    });
// ▼▼▼ 步骤八：用这个【完整】的新函数替换旧的 'post-moment-btn' 监听器 ▼▼▼

    // (替换) 论坛发帖弹窗的逻辑 (V3 - 动态板块版)
    document.getElementById('post-moment-btn').addEventListener('click', () => {
        pendingPostImage = null;
        pendingForumRedPacket = null;
        const modal = document.getElementById('post-moment-modal');
        modal.style.display = 'flex';
        document.getElementById('moment-content-input').value = '';
        
        // 隐藏图片预览
        document.getElementById('post-image-preview-container').style.display = 'none';
        document.getElementById('post-image-preview').src = '';
        
        // 重置红包按钮
        const redPacketBtn = document.getElementById('add-post-red-packet-btn');
        redPacketBtn.classList.remove('active');
        
        // --- ✨ 核心改造：动态生成板块下拉菜单 ---
        const categorySelect = document.getElementById('post-category-select');
        categorySelect.innerHTML = `
            <option value="daily">日常</option>
            <option value="food">美食</option>
            <option value="gossip">八卦</option>
            <option value="horror">恐怖</option>
        `;
        // 从 state 加载自定义板块
        state.forumCategories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id; // 使用ID作为value
            option.textContent = category.name;
            categorySelect.appendChild(option);
        });
        // --- 改造结束 ---
        
        // (你原来的红包按钮克隆逻辑保持不变)
        const newRedPacketBtn = redPacketBtn.cloneNode(true);
        redPacketBtn.parentNode.replaceChild(newRedPacketBtn, redPacketBtn);
        newRedPacketBtn.addEventListener('click', () => {
            const rpModal = document.getElementById('create-forum-red-packet-modal');
            rpModal.style.display = 'flex';
            document.getElementById('close-forum-red-packet-modal').onclick = () => rpModal.style.display = 'none';
            const confirmRpBtn = document.getElementById('confirm-forum-red-packet-btn');
            const newConfirmRpBtn = confirmRpBtn.cloneNode(true);
            confirmRpBtn.parentNode.replaceChild(newConfirmRpBtn, confirmRpBtn);
            newConfirmRpBtn.addEventListener('click', () => {
                const amount = parseFloat(document.getElementById('forum-red-packet-amount-input').value);
                const count = parseInt(document.getElementById('forum-red-packet-count-input').value, 10);
                if (isNaN(amount) || amount <= 0 || isNaN(count) || count <= 0) {
                    return alert('请输入有效的金额和个数');
                }
                if (amount > state.myProfile.balance) {
                    return alert('钱包余额不足！');
                }
                pendingForumRedPacket = {
                    amount,
                    count,
                    blessing: document.getElementById('forum-red-packet-blessing-input').value.trim() || '恭喜发财，大吉大利！',
                };
                newRedPacketBtn.classList.add('active');
                rpModal.style.display = 'none';
            });
        });

        // (你原来的图片按钮逻辑保持不变)
        const addImgBtn = document.getElementById('add-post-image-btn');
        const newAddImgBtn = addImgBtn.cloneNode(true);
        addImgBtn.parentNode.replaceChild(newAddImgBtn, addImgBtn);
        newAddImgBtn.addEventListener('click', () => {
            document.getElementById('post-image-uploader').click();
        });
    });
// ▲▲▲ 替换结束 ▲▲▲

        // (新增) 处理帖子图片选择
        document.getElementById('post-image-uploader').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            try {
                // 复用你已有的神级函数！
                const base64String = await handleImageUpload(file);
                pendingPostImage = base64String;
                // 显示预览
                document.getElementById('post-image-preview').src = base64String;
                document.getElementById('post-image-preview-container').style.display = 'block';
            } catch (error) {
                alert('图片处理失败: ' + error.message);
            }
            e.target.value = ''; // 清空
        });

        // (新增) 移除帖子预览图片
        document.getElementById('remove-post-image-btn').addEventListener('click', () => {
            pendingPostImage = null;
            document.getElementById('post-image-preview').src = '';
            document.getElementById('post-image-preview-container').style.display = 'none';
        });

        document.getElementById('close-post-moment-modal').addEventListener('click', () => {
            document.getElementById('post-moment-modal').style.display = 'none';
        });

        // (替换) 发布帖子的逻辑 (V2 - 支持图片)
        document.getElementById('publish-moment-btn').addEventListener('click', async () => {
            const content = document.getElementById('moment-content-input').value.trim();
            // 核心修改：只要有文字、有图、或有红包，就允许发送
            if (!content && !pendingForumRedPacket && !pendingPostImage) {
                return alert('请输入帖子内容、添加图片或红包！');
            }
            const category = document.getElementById('post-category-select').value;
            
            // (你原来的 authorProfile 逻辑保持不变)
            let authorProfile;
            const personaId = state.forumSettings.personaId;
            const persona = personaId ? state.userPersonaPresets.find(p => p.id === personaId) : null;

            if (persona) {
                authorProfile = {
                    id: 'myProfile', 
                    name: persona.name, 
                    avatar: persona.avatar || state.myProfile.avatar, 
                    signature: persona.signature || ''
                };
            } else {
                authorProfile = {
                    id: 'myProfile',
                    name: state.myProfile.name,
                    avatar: state.myProfile.avatar,
                    signature: state.myProfile.signature
                };
            }
            // (authorProfile 逻辑结束)

            const newPost = {
                id: 'post_' + Date.now(),
                author: authorProfile, 
                content: content || (pendingForumRedPacket ? pendingForumRedPacket.blessing : ''), // 如果没文字，用红包祝福语
                
                image: pendingPostImage, // ★★★ 核心新增 ★★★
                
                timestamp: Date.now(),
                likes: [],
                comments: [],
                reposts: 0,
                category: category,
                archiveId: state.activeForumArchiveId
            };
            
            // (你原来的红包处理逻辑保持不变)
            if (pendingForumRedPacket) {
                newPost.redPacket = { ...pendingForumRedPacket,
                    claimers: []
                };
                state.myProfile.balance -= pendingForumRedPacket.amount;
                await addTransaction('expense', pendingForumRedPacket.amount, `在论坛中发红包`, null);
                await kokoMemory.put('myProfile', state.myProfile);
                await renderMyProfile();
            }
            
            state.posts.unshift(newPost);
            await kokoMemory.put('posts', newPost);
            state.activeFeedTab = 'recommended';
            state.activeFeedSubTab = category;
            await showFeedScreen();
            document.getElementById('post-moment-modal').style.display = 'none';
        });

    document.getElementById('screen').addEventListener('click', e => {
        const mentionSpan = e.target.closest('.mention');
        if (mentionSpan) {
            e.stopPropagation();
            const userName = mentionSpan.textContent.substring(1);
            alert(`Tapped on user: @${userName}`);
        }
    });
    document.getElementById('my-wallet-btn').addEventListener('click', () => {
        hideAllScreens();
        document.getElementById('wallet-screen').style.display = 'flex';
        renderWalletScreen();
    });
    document.getElementById('back-from-wallet').addEventListener('click', showProfileScreen);

    // --- ↓↓↓ 用这个新的代码块，替换掉你原来的所有 globalAudioPlayer.addEventListener(...) 代码 ↓↓↓ ---
globalAudioPlayer.addEventListener('play', () => {
    startListenTimeTracker();
    updateUI(); 
    document.getElementById('player-avatar-stack').classList.add('is-playing');

    document.querySelectorAll('.music-share-card').forEach(card => {
        const msgId = card.closest('.message-wrapper').dataset.messageId;
        if (msgId === currentlyPlayingMsgId) {
            card.querySelector('.music-card-cover').classList.add('playing');
            card.querySelector('.music-card-play-btn i').className = 'fas fa-pause';
        } else {
            card.querySelector('.music-card-cover').classList.remove('playing');
            card.querySelector('.music-card-play-btn i').className = 'fas fa-play';
        }
    });
});

globalAudioPlayer.addEventListener('pause', () => {
    stopListenTimeTracker();
    updateUI(); 
    document.getElementById('player-avatar-stack').classList.remove('is-playing');

    document.querySelectorAll('.music-share-card').forEach(card => {
        card.querySelector('.music-card-cover').classList.remove('playing');
        card.querySelector('.music-card-play-btn i').className = 'fas fa-play';
    });
});

globalAudioPlayer.addEventListener('timeupdate', () => {
    updateUI(); 
    if (currentlyPlayingMsgId) {
        const cardWrapper = document.querySelector(`.message-wrapper[data-message-id='${currentlyPlayingMsgId}']`);
        if (cardWrapper) {
            const card = cardWrapper.querySelector('.music-share-card');
            if (card && globalAudioPlayer.duration) {
                const progress = (globalAudioPlayer.currentTime / globalAudioPlayer.duration) * 100;
                card.querySelector('.music-card-progress').style.width = `${progress}%`;
                const formatTime = (s) => new Date(s * 1000).toISOString().substr(14, 5);
                card.querySelector('.music-card-time').textContent = formatTime(globalAudioPlayer.currentTime);
            }
        }
    }
});

globalAudioPlayer.addEventListener('loadedmetadata', updateUI);

globalAudioPlayer.addEventListener('ended', async () => {
    document.getElementById('player-avatar-stack').classList.remove('is-playing');
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;
    const playlist = contact.sharedPlaylist;
    const mode = playlist.playbackMode || 'repeat-all';
    switch (mode) {
        case 'repeat-one':
            globalAudioPlayer.currentTime = 0;
            globalAudioPlayer.play();
            break;
        case 'repeat-all':
            switchSong(currentSongIndex + 1, true, true);
            break;
        case 'off':
            break;
    }
    await kokoMemory.put('contacts', contact);
});
// --- 新增：双击编辑逻辑 (替换长按) ---
const chatMessagesContainer = document.getElementById('chat-messages');
    chatMessagesContainer.addEventListener('dblclick', (e) => {
        // 如果正在进行多选编辑，则禁用双击
        if (editModeState.active) return;

        const wrapper = e.target.closest('.message-wrapper');
        if (!wrapper) return;

        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;



        const msgId = wrapper.dataset.messageId;
        const msg = contact.history.find(m => m.id === msgId);

        // 检查消息类型是否支持编辑（文本、HTML、语音）
        if (msg && (msg.type === 'text' || msg.type === 'html' || msg.type === 'voice')) {
            handleEditMessage(msgId); // 调用你已有的编辑函数
        }
    });
// ↓↓↓ 把这段新代码粘贴到 attachEventListeners 函数的末尾 ↓↓↓

// --- 游戏转盘弹窗逻辑 ---
document.getElementById('close-create-wheel-modal').addEventListener('click', () => {
    document.getElementById('create-wheel-modal').style.display = 'none';
});

document.getElementById('add-wheel-option-btn').addEventListener('click', () => addWheelOptionInput());

document.getElementById('confirm-send-wheel-btn').addEventListener('click', async () => {
    const wheelName = document.getElementById('wheel-name-input').value.trim();
    if (!wheelName) {
        return alert('请给你的转盘起个名字！');
    }

    const options = [];
    const optionElements = document.querySelectorAll('.wheel-option-item');
    for (const el of optionElements) {
        const text = el.querySelector('.wheel-option-text').value.trim();
        const weight = parseInt(el.querySelector('.wheel-option-weight').value, 10) || 1;
        if (text) {
            options.push({ text, weight });
        }
    }

    if (options.length < 2) {
        return alert('转盘至少需要2个有效的选项！');
    }

    await createAndAddMessage({
        type: 'game_wheel',
        content: {
            id: `wheel_${Date.now()}`,
            name: wheelName,
            options: options,
            results: { // 存储用户和AI的结果
                user: null, // 'user' 代表玩家自己
                contact: null // 'contact' 代表对方
            }
        }
    });

});
// ↑↑↑ 新增代码结束 ↑↑↑
// ▼▼▼ (V3 - 记住折叠状态版) 替换旧的 .collapsible-title 监听器 ▼▼▼
// (粘贴到 attachEventListeners 函数中)
document.body.addEventListener('click', function(e) {
    if (e.target.matches('.collapsible-title, .collapsible-title *')) {
        const title = e.target.closest('.collapsible-title');
        if (!title) return;

        // 1. (不变) 切换UI
        title.classList.toggle('collapsed');
        const isCollapsed = title.classList.contains('collapsed');

        // 2. (新!) 获取组ID，并保存状态到数据库
        const groupId = title.dataset.groupId;
        if (groupId) {
            // 我们使用一个立即执行的异步函数 (IIFE) 
            // 这样它就可以在后台保存数据，而不会阻塞UI的折叠动画
            (async () => {
                if (groupId === 'ungrouped') {
                    // 如果是“未分组”，就保存到 userSettings
                    userSettings.isUngroupedCollapsed = isCollapsed;
                    await kokoMemory.put('userSettings', userSettings);
                } else {
                    // 如果是普通分组，就更新那个分组的条目
                    const group = await kokoMemory.get('contactGroups', groupId);
                    if (group) {
                        group.isCollapsed = isCollapsed;
                        await kokoMemory.put('contactGroups', group);
                    }
                }
                console.log(`已保存分组 ${groupId} 的折叠状态: ${isCollapsed}`);
            })();
        }

        // 3. (不变) 遍历并隐藏/显示下面的联系人
        let nextElement = title.nextElementSibling;
        while (nextElement) {
            if (nextElement.matches('.section-title')) {
                break;
            }
            // (我们给子元素也加上 'contact-item' 类，确保只折叠联系人)
            if (nextElement.matches('.contact-item, .world-book-item')) {
                 nextElement.style.display = isCollapsed ? 'none' : '';
            }
            nextElement = nextElement.nextElementSibling;
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// --- ▲▲▲ 粘贴到这里结束 ---
// 在 attachEventListeners 函数中找到并添加这些事件
document.getElementById('lock-screen-photos-btn').addEventListener('click', showLockScreenPhotosScreen);
document.getElementById('back-from-lock-screen-photos').addEventListener('click', showDiscoverScreen);

document.getElementById('add-lock-screen-photo-btn').addEventListener('click', () => {
    document.getElementById('lock-screen-photo-uploader').click();
});

document.getElementById('lock-screen-photo-uploader').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        const base64String = await handleImageUpload(file); // 复用我们已有的图片压缩函数
        const newPhoto = {
            id: 'ls_photo_' + Date.now(),
            base64: base64String
        };
        await kokoMemory.put('lockScreenPhotos', newPhoto);
        await renderLockScreenPhotos(); // 上传后立刻刷新列表
    } catch (error) {
        console.error('上传锁屏照片失败:', error);
        alert('图片处理失败，请重试。');
    } finally {
        e.target.value = ''; // 清空选择，方便下次上传
    }
});

document.getElementById('lock-screen-photos-grid').addEventListener('click', async (e) => {
    if (e.target.classList.contains('emoticon-delete-btn')) {
        const photoId = e.target.dataset.photoId;
        const confirmed = await showCustomConfirm('删除照片', '确定要从锁屏相册中删除这张照片吗？', true);
        if (confirmed) {
            await kokoMemory.delete('lockScreenPhotos', photoId);
            await renderLockScreenPhotos(); // 删除后刷新
        }
    }
});
// 在 attachEventListeners 函数的末尾追加
// --- V-新功能：日程与事件的事件监听 ---

// 资料页的入口按钮
document.getElementById('view-schedule-btn').addEventListener('click', showScheduleScreen);
document.getElementById('view-events-btn').addEventListener('click', showEventsScreen);

// 各自页面的返回按钮
document.getElementById('back-from-schedule').addEventListener('click', showCharProfileScreen);
document.getElementById('back-from-events').addEventListener('click', showCharProfileScreen);

// 添加按钮 -> 打开弹窗
document.getElementById('add-schedule-item-btn').addEventListener('click', () => openScheduleModal());
document.getElementById('add-event-item-btn').addEventListener('click', () => openEventModal());

// 弹窗的关闭按钮
document.getElementById('close-schedule-modal').addEventListener('click', () => { document.getElementById('schedule-modal').style.display = 'none'; });
document.getElementById('close-event-modal').addEventListener('click', () => { document.getElementById('event-modal').style.display = 'none'; });

// 弹窗的保存按钮
document.getElementById('save-schedule-item-btn').addEventListener('click', async () => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;
    const newItem = {
        id: editingScheduleId || 'sched_' + Date.now(),
        courseName: document.getElementById('schedule-name-input').value.trim(),
        dayOfWeek: document.getElementById('schedule-day-select').value,
        startTime: document.getElementById('schedule-start-input').value,
        endTime: document.getElementById('schedule-end-input').value,
        location: document.getElementById('schedule-location-input').value.trim()
    };
    if (!newItem.courseName || !newItem.startTime || !newItem.endTime) return alert('请填写完整信息');
        // --- ▼▼▼ 在这里添加修复代码 ▼▼▼ ---
    if (!contact.schedule) {
        contact.schedule = []; // 如果篮子不存在，就先创建一个
    }
    // --- ▲▲▲ 修复代码结束 ▲▲▲
    
    if (editingScheduleId) {
        const index = contact.schedule.findIndex(i => i.id === editingScheduleId);
        contact.schedule[index] = newItem;
    } else {
        contact.schedule.push(newItem);
    }
    await kokoMemory.put('contacts', contact);
    renderSchedule();
    document.getElementById('schedule-modal').style.display = 'none';
});

document.getElementById('save-event-item-btn').addEventListener('click', async () => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;
    const newItem = {
        id: editingEventId || 'event_' + Date.now(),
        eventName: document.getElementById('event-name-input').value.trim(),
        date: document.getElementById('event-date-input').value,
        type: document.getElementById('event-type-select').value,
        notes: document.getElementById('event-notes-input').value.trim()
    };
    if (!newItem.eventName || !newItem.date) return alert('请填写事件名称和日期');
       // --- ▼▼▼ 在这里添加修复代码 ▼▼▼ ---
    if (!contact.events) {
        contact.events = []; // 如果篮子不存在，就先创建一个
    }
    // --- ▲▲▲ 修复代码结束 ▲▲▲

    if (editingEventId) {
        const index = contact.events.findIndex(i => i.id === editingEventId);
        contact.events[index] = newItem;
    } else {
        contact.events.push(newItem);
    }
    await kokoMemory.put('contacts', contact);
    renderEvents();
    document.getElementById('event-modal').style.display = 'none';
});
// (粘贴到 'save-event-item-btn' 监听器的下方)

// ✨ 新增：日程表弹窗的“删除”按钮
document.getElementById('delete-schedule-item-btn').addEventListener('click', async () => {
    if (!editingScheduleId) return; // 确保我们是在编辑模式

    const confirmed = await showCustomConfirm('删除日程', '确定要删除这个日程安排吗？', true);
    if (confirmed) {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (contact && contact.schedule) {
            // 1. 从数组中过滤掉这个日程
            contact.schedule = contact.schedule.filter(item => item.id !== editingScheduleId);
            // 2. 保存回数据库
            await kokoMemory.put('contacts', contact);
            // 3. 重新渲染列表
            renderSchedule();
            // 4. 关闭弹窗
            document.getElementById('schedule-modal').style.display = 'none';
            editingScheduleId = null; // 清空ID
        }
    }
});
// 使用事件委托处理列表项的点击（编辑/删除）
document.getElementById('schedule-content-list').addEventListener('click', (e) => {
    const itemEl = e.target.closest('.discover-item');
    if (itemEl) {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        const itemId = itemEl.dataset.scheduleId;
        const item = contact.schedule.find(i => i.id === itemId);
        openScheduleModal(item);
    }
});

// 使用事件委托处理列表项的点击（编辑/删除/置顶） (V2版)
document.getElementById('events-content-list').addEventListener('click', async (e) => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    // --- 核心修改：目标从 .discover-item 改为 .event-card ---
    const itemEl = e.target.closest('.event-card');
    if (!itemEl) return;

    const eventId = itemEl.dataset.eventId;
    const targetEvent = contact.events.find(i => i.id === eventId);
    if (!targetEvent) return;
    
    // ▼▼▼ 新增的置顶按钮逻辑 ▼▼▼
    const pinBtn = e.target.closest('.pin-event-btn');
    if (pinBtn) {
        e.stopPropagation();
        
        const isCurrentlyPinned = targetEvent.isPinned;

        // 核心逻辑：先取消所有事件的置顶
        contact.events.forEach(event => event.isPinned = false);

        // 如果刚才点击的不是一个已置顶的事件，那么就把它设为新的置顶
        if (!isCurrentlyPinned) {
            targetEvent.isPinned = true;
        }
        
        await kokoMemory.put('contacts', contact);
        renderEvents(); // 重新渲染列表，更新图钉颜色
        
        // ✨ 新增：立即更新锁屏 ✨
        await updateLockScreenWidgets(); 
        return;
    }
    // ▲▲▲ 新增逻辑结束 ▲▲▲

    const deleteBtn = e.target.closest('.delete-event-btn');
    if (deleteBtn) {
        e.stopPropagation();
        const confirmed = await showCustomConfirm('删除事件', '确定要删除这个重要的日子吗？', true);
        if (confirmed) {
            contact.events = contact.events.filter(i => i.id !== eventId);
            await kokoMemory.put('contacts', contact);
            renderEvents();
            // ✨ 新增：立即更新锁屏 ✨
            await updateLockScreenWidgets(); 
        }
    // --- 核心修改：目标从 .discover-info 改为 .event-card-info ---
    } else if (e.target.closest('.event-card-info')) { 
        openEventModal(targetEvent);
    }
});
// ==========================================================
// --- 地图目录折叠/展开事件 ---
    const mapDirHeader = document.getElementById('map-directory-header');
    if (mapDirHeader) {
        mapDirHeader.addEventListener('click', () => {
            const list = document.getElementById('map-directory-list');
            const icon = document.getElementById('map-directory-toggle-icon');
            const panel = document.getElementById('map-directory-panel');

            if (list.style.display === 'none') {
                // 展开
                list.style.display = 'block';
                icon.style.transform = 'rotate(0deg)'; // 箭头指下
                panel.style.width = '160px'; // 恢复宽度
            } else {
                // 收起
                list.style.display = 'none';
                icon.style.transform = 'rotate(-90deg)'; // 箭头指左
                panel.style.width = 'auto'; // 宽度收缩，只显示标题
            }
        });
    }
// =========== ▼▼▼ 游戏中心 事件监听器 ▼▼▼ ============
// ==========================================================
// ==========================================================
// =========== 海龟汤 游戏事件绑定 (V2-全局版) ============
// ==========================================================
    
    // 1. 游戏中心 -> 点击“海龟汤”
    document.getElementById('start-sea-turtle-btn').addEventListener('click', () => {
        // ✨ 核心修改：不再检查是否在私聊，直接打开弹窗
        openSeaTurtleModal();
    });
    
    // 2. 游戏弹窗 -> "关闭"
    document.getElementById('close-start-game-modal').addEventListener('click', () => {
        document.getElementById('start-game-modal').style.display = 'none';
    });
    
    // 3. 游戏弹窗 -> "开始游戏"
    // (使用克隆节点防止重复绑定)
    const oldConfirmStartBtn = document.getElementById('confirm-start-game-btn');
    const newConfirmStartBtn = oldConfirmStartBtn.cloneNode(true);
    oldConfirmStartBtn.parentNode.replaceChild(newConfirmStartBtn, oldConfirmStartBtn);
    newConfirmStartBtn.addEventListener('click', () => {
        // 在启动游戏前，集中获取一次所有游戏DOM元素
        cacheGameDOMElements();
        // 调用游戏的核心启动函数
        handleStartGame();
    });
// "发现" -> "游戏中心"
document.getElementById('investment-center-btn').addEventListener('click', () => {
    hideAllScreens();
    document.getElementById('investment-center-screen').style.display = 'flex';
});

// "游戏中心" -> "发现" (返回)
document.getElementById('back-from-investment-center').addEventListener('click', showDiscoverScreen);

// "游戏中心" -> 点击 "彩票站" 卡片 -> 打开彩票弹窗
document.getElementById('open-scratch-card-modal-btn').addEventListener('click', () => {
    document.getElementById('scratch-card-modal').style.display = 'flex';
    document.getElementById('scratch-result-area').style.display = 'none'; // 隐藏上次的结果
});

// "游戏中心" -> 点击 "交易所" 卡片 -> 打开交易所页面
document.getElementById('open-stock-market-btn').addEventListener('click', () => {
    hideAllScreens();
    document.getElementById('stock-market-screen').style.display = 'flex';
    startStockMarket(); // 启动模拟器
});

// "股票交易所" -> "游戏中心" (返回)
document.getElementById('back-from-stock-market').addEventListener('click', () => {
    stopStockMarket(); // 关闭模拟器
    // 返回游戏中心
    hideAllScreens();
    document.getElementById('investment-center-screen').style.display = 'flex';
});

// "股票交易所" -> 买入/卖出
document.getElementById('stock-buy-btn').addEventListener('click', () => handleStockTrade('buy'));
document.getElementById('stock-sell-btn').addEventListener('click', () => handleStockTrade('sell'));

// "刮刮乐" -> 关闭弹窗
document.getElementById('close-scratch-card-modal').addEventListener('click', () => {
    document.getElementById('scratch-card-modal').style.display = 'none';
});

// ▼▼▼ 使用这个【修正后】的事件监听器替换旧的 ▼▼▼
// "刮刮乐" -> 点击购买 (使用事件委托)
document.getElementById('scratch-card-modal').addEventListener('click', (e) => {
    const btn = e.target.closest('.buy-scratch-card-btn');
    const scratchCell = e.target.closest('.scratch-cell-player.covered');

    if (btn) {
        // --- 逻辑 1：点击了“购买”按钮 ---
        e.stopPropagation();
        purchaseScratchCard(btn.dataset.price, btn.dataset.gameType);
    
    } else if (scratchCell) {
        // --- 逻辑 2：点击了“未刮开”的格子 ---
        e.stopPropagation();
        
        // 1. 刮开这个格子
        scratchCell.classList.remove('covered');
        scratchCell.classList.add('scratched');
        
        // 2. 检查是否还有未刮开的
        const gridDisplay = scratchCell.closest('#scratch-grid-display');
        const remainingCovers = gridDisplay.querySelectorAll('.covered').length;

        // 3. 如果全部刮完了
        if (remainingCovers === 0) {
            const resultArea = document.getElementById('scratch-result-area');
            const winnings = parseFloat(resultArea.dataset.winnings || 0);
            const message = resultArea.dataset.message || "谢谢惠顾！";

            // 4. 显示最终结果信息
            document.getElementById('scratch-result-message').innerHTML = message;
            
            // 5. 如果中奖了，异步加钱并更新UI
            if (winnings > 0) {
                (async () => {
                    state.myProfile.balance += winnings;
                    await addTransaction('income', winnings, '刮刮乐中奖');
                    renderMyProfile(); // 刷新“我”页面的余额
                    await kokoMemory.put('myProfile', state.myProfile);
                })();
            }
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲
// --- 面包屑导航点击事件 (修复点击无反应 BUG) ---
    document.getElementById('map-breadcrumbs').addEventListener('click', (e) => {
        // 找到被点击的面包屑项
        const targetItem = e.target.closest('.breadcrumb-item');
        
        // 如果点到了，并且它有目标ID，且不是当前激活项
        if (targetItem && targetItem.dataset.targetId && !targetItem.classList.contains('active')) {
            navigateToMapLayer(targetItem.dataset.targetId);
        }
    });
// ==========================================================
// --- 监听“群聊设置”页面的点击事件 ---
document.getElementById('group-settings-screen').addEventListener('click', async (e) => {
    
// ... (在 attachEventListeners 函数中) ...
    
// ... 在 group-settings-screen 的监听器内部 ...

    // --- 处理“添加NPC”按钮 (修改版：重置为新增模式) ---
    if (e.target.closest('#add-npc-member-btn')) {
        editingGroupNpcId = null; // 🔴 核心：清空编辑ID，表示是新增
        document.getElementById('group-npc-name-input').value = '';
        document.getElementById('group-npc-persona-input').value = '';
        pendingNpcAvatarBase64 = null; 
        document.getElementById('group-npc-avatar-preview').style.display = 'none';
        
        // 修改标题
        document.querySelector('#create-npc-for-group-modal .modal-title').textContent = '为群聊添加NPC';
        document.getElementById('confirm-create-npc-btn').textContent = '确认添加';
        
        document.getElementById('create-npc-for-group-modal').style.display = 'flex';
    }

    // ▼▼▼ 新增：处理 NPC 列表项的点击 (进入编辑模式) ▼▼▼
    const npcRow = e.target.closest('.contact-picker-item');
    // 确保点击的是 NPC 行，且不是点击了里面的按钮（如禁言/删除）
    if (npcRow && npcRow.dataset.isNpcRow === 'true' && !e.target.closest('button')) {
        const group = state.contacts.find(c => c.id === state.activeChatId);
        const npcId = npcRow.dataset.npcId;
        const npcData = group.npcMembers.find(n => n.id === npcId);

        if (npcData) {
            editingGroupNpcId = npcId; // 🔴 核心：设置编辑ID
            
            // 填充旧数据
            document.getElementById('group-npc-name-input').value = npcData.name;
            document.getElementById('group-npc-persona-input').value = npcData.persona;
            
            // 填充头像预览
            pendingNpcAvatarBase64 = npcData.avatar;
            const preview = document.getElementById('group-npc-avatar-preview');
            preview.src = npcData.avatar;
            preview.style.display = 'block';

            // 修改弹窗标题
            document.querySelector('#create-npc-for-group-modal .modal-title').textContent = '修改 NPC 设定';
            document.getElementById('confirm-create-npc-btn').textContent = '保存修改';

            // 打开弹窗
            document.getElementById('create-npc-for-group-modal').style.display = 'flex';
        }
    }
    // ▲▲▲ 新增结束 ▲▲▲
});
// --- 为新弹窗的“关闭”按钮添加事件 ---
document.getElementById('close-create-npc-modal').addEventListener('click', () => {
    document.getElementById('create-npc-for-group-modal').style.display = 'none';
});

// --- 为新弹窗的“确认添加”按钮添加事件（使用克隆节点防重复） ---
const confirmNpcBtn = document.getElementById('confirm-create-npc-btn');
const newConfirmNpcBtn = confirmNpcBtn.cloneNode(true);
confirmNpcBtn.parentNode.replaceChild(newConfirmNpcBtn, confirmNpcBtn);

newConfirmNpcBtn.addEventListener('click', async () => {
    const group = state.contacts.find(c => c.id === state.activeChatId);
    if (!group) return;

    const name = document.getElementById('group-npc-name-input').value.trim();
    const persona = document.getElementById('group-npc-persona-input').value.trim();
    let avatar = pendingNpcAvatarBase64; 

    if (!name || !persona) {
        return alert('NPC的姓名和人设是必须的！');
    }

    if (!avatar) {
        avatar = `https://s21.ax1x.com/2025/11/09/pZ9FrMd.png`;
    }

    if (editingGroupNpcId) {
        // --- 🅰️ 编辑模式：更新现有 NPC ---
        const npcIndex = group.npcMembers.findIndex(n => n.id === editingGroupNpcId);
        if (npcIndex > -1) {
            // 更新数据
            group.npcMembers[npcIndex].name = name;
            group.npcMembers[npcIndex].persona = persona;
            group.npcMembers[npcIndex].avatar = avatar;
            
            // 提示
            alert('NPC 设定已更新！');
        }
    } else {
        // --- 🅱️ 新增模式：创建新 NPC ---
        const newNpc = {
            id: 'npc_' + Date.now(),
            name: name,
            persona: persona,
            avatar: avatar 
        };
        group.npcMembers.push(newNpc);
        group.members.push(newNpc.id);
        
        // 发通知
        const tempActiveChatId = state.activeChatId;
        state.activeChatId = group.id;
        await createAndAddMessage({
            type: 'system_notification',
            sender: 'system',
            content: `NPC角色 "${name}" 已加入群聊`
        });
        state.activeChatId = tempActiveChatId;
    }

    // 统一保存并刷新
    await kokoMemory.put('contacts', group);
    openGroupSettingsScreen(group); // 刷新列表UI
    document.getElementById('create-npc-for-group-modal').style.display = 'none';
});
// (粘贴到 attachEventListeners 函数的【内部】)

// --- 新增：处理群聊NPC头像上传 ---
document.getElementById('upload-group-npc-avatar-btn').addEventListener('click', () => {
    // 1. 触发我们刚才添加的隐藏 <input>
    document.getElementById('group-npc-avatar-uploader').click();
});

// 2. 监听文件选择
document.getElementById('group-npc-avatar-uploader').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        // 3. 复用你已有的、超好用的图片压缩函数！
        const base64String = await handleImageUpload(file);

        // 4. 显示预览图
        const preview = document.getElementById('group-npc-avatar-preview');
        preview.src = base64String;
        preview.style.display = 'block';

        // 5. 把图片数据暂存到全局变量
        pendingNpcAvatarBase64 = base64String;

    } catch (error) {
        console.error('NPC头像处理失败:', error);
        alert('图片处理失败，请重试。');
    } finally {
        e.target.value = ''; // 清空input，以便下次能选同一张图
    }
});
// =========== ▲▲▲ 游戏中心 事件监听器 END ▲▲▲ ============
// ==========================================================

// --- 新增：处理真实图片上传的事件 ---
document.getElementById('image-upload-input').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    try {
        // 调用我们刚才写的处理函数
        const base64String = await handleImageUpload(file);
        
        // 用新的消息类型发送
        await createAndAddMessage({
            type: 'uploaded_image',
            content: {
                base64: base64String
            }
        });

    } catch (error) {
        console.error('图片处理失败:', error);
        alert('图片处理失败，请稍后再试。');
    } finally {
        // 清空input的值，这样用户可以连续上传同一张图片
        e.target.value = '';
    }
});
// ==========================================================
// 1. 角色资料页的入口按钮
document.getElementById('view-relationship-network-btn').addEventListener('click', () => {
    showRelationshipScreen(state.activeChatId);
});

// 2. 关系网页面的返回按钮
document.getElementById('back-from-relationship-network').addEventListener('click', showCharProfileScreen);

// 在 attachEventListeners 函数的末尾添加：

// --- 【新增】关系网 V2.0 事件绑定 ---

// 在 attachEventListeners 函数中...

// 【修改】把原来 add-character-btn 的监听，改成 add-to-roster-btn
document.getElementById('add-to-roster-btn').addEventListener('click', () => {
    openAddToRosterModal(); // 点击后打开我们的“选择”模态框
});

// 【新增】为“选择”模态框的按钮绑定事件
document.getElementById('close-add-to-roster-modal').addEventListener('click', () => {
    document.getElementById('add-to-roster-modal').style.display = 'none';
});

// “导入选中联系人”按钮的逻辑
document.getElementById('confirm-import-contact-btn').addEventListener('click', async () => {
    const contactIdToImport = document.getElementById('import-contact-select').value;
    if (!contactIdToImport) return;

    const contactId = document.getElementById('relationship-network-screen').dataset.currentContactId;
    const networkData = await kokoMemory.get('relationshipNetworks', contactId);
    const contactToImport = state.contacts.find(c => c.id === contactIdToImport);

    if (contactToImport && !networkData.nodes.some(n => n.id === contactToImport.id)) {
        // 将选中的联系人添加到nodes数组中
        networkData.nodes.push({
            id: contactToImport.id,
            name: contactToImport.name,
            avatar: contactToImport.avatar,
            isContact: true // 标记为这是一个真实联系人
        });
        await kokoMemory.put('relationshipNetworks', networkData);

        // 刷新UI并关闭模态框
        await renderRelationshipNetwork(contactId);
        await renderRelationshipGraph(contactId);
        document.getElementById('add-to-roster-modal').style.display = 'none';
    }
});

// “创建一个全新的NPC”按钮的逻辑
document.getElementById('switch-to-create-npc-btn').addEventListener('click', () => {
    document.getElementById('add-to-roster-modal').style.display = 'none'; // 先关掉选择框
    openCharacterModal(); // 再打开我们之前写的NPC创建框
});

// 角色编辑/删除（事件委托）
document.getElementById('character-list').addEventListener('click', async (e) => {
    const contactId = document.getElementById('relationship-network-screen').dataset.currentContactId;
    const networkData = await kokoMemory.get('relationshipNetworks', contactId);
    
    const editBtn = e.target.closest('.edit-character-btn');
    if (editBtn) {
        const char = networkData.nodes.find(n => n.id === editBtn.dataset.charId);
        if(char) openCharacterModal(char);
    }
    const deleteBtn = e.target.closest('.delete-character-btn');
    if (deleteBtn) {
        deleteCharacter(deleteBtn.dataset.charId);
    }
});


// 角色模态框的按钮
document.getElementById('close-character-modal').addEventListener('click', () => {
    document.getElementById('character-modal').style.display = 'none';
});
document.getElementById('save-character-btn').addEventListener('click', saveCharacter);

// (新 V3) 关系列表点击（删除 或 编辑）
document.getElementById('relationship-list').addEventListener('click', (e) => {
    const deleteBtn = e.target.closest('.delete-relationship-btn');
    if (deleteBtn) {
        // 逻辑 1: 点击了删除按钮
        e.stopPropagation(); // 阻止冒泡
        deleteRelationship(deleteBtn.dataset.sourceId, deleteBtn.dataset.targetId);
    } else {
        // 逻辑 2: 点击了条目本身 (preset-info)
        const infoBox = e.target.closest('.preset-info');
        if (infoBox) {
            e.stopPropagation(); // 阻止冒泡
            // ✨ 调用我们新加的函数来填充数据
            populateRelationshipEditor(infoBox.dataset);
        }
    }
});
// 在 attachEventListeners 函数的任意位置添加：

// --- 【新增】NPC头像本地上传事件绑定 ---
document.getElementById('upload-character-avatar-btn').addEventListener('click', () => {
    // 点击“上传”按钮时，去触发那个看不见的 <input type="file">
    document.getElementById('character-avatar-uploader').click();
});

document.getElementById('character-avatar-uploader').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        // 调用我们之前就写好的、带压缩功能的图片处理函数！完美复用！
        const base64String = await handleImageUpload(file);

        // 把处理好的图片显示在预览区
        const preview = document.getElementById('character-avatar-preview');
        preview.src = base64String;
        preview.style.display = 'block';

    } catch (error) {
        console.error('NPC头像处理失败:', error);
        alert('图片处理失败，请重试。');
    } finally {
        // 清空input的值，这样用户可以连续上传同一张图片
        e.target.value = '';
    }
});
// 在 attachEventListeners 函数中...

// 【新增】自定义关系类型选择的事件监听
document.getElementById('relation-type-select').addEventListener('change', async function() {
    if (this.value === '自定义') {
        const customType = await showCustomPrompt('自定义关系类型', '请输入关系名称（如：师徒）');

        if (customType && customType.trim()) {
            const newType = customType.trim();

            // 检查这个新类型是否已经存在
            let optionExists = false;
            for (let i = 0; i < this.options.length; i++) {
                if (this.options[i].value === newType) {
                    optionExists = true;
                    this.value = newType; // 如果已存在，直接选中它
                    break;
                }
            }

            // 如果不存在，就创建一个新的选项并选中它
            if (!optionExists) {
                const newOption = new Option(newType, newType, true, true);
                // 插入到“自定义”选项的前面
                this.insertBefore(newOption, this.options[this.options.length - 1]);
            }
        } else {
            // 如果用户取消了输入，就恢复到第一个选项（“朋友”）
            this.value = this.options[0].value;
        }
    }
});
document.getElementById('save-relationship-btn').addEventListener('click', saveRelationship);
// =========== ▼▼▼ 论坛档案馆 - 最终修正版事件监听 ▼▼▼ =======
// ▼▼▼ 步骤六：把这段代码粘贴到 attachEventListeners() 函数【内部】 ▼▼▼

    // --- 论坛板块管理 ---
    document.getElementById('forum-category-btn').addEventListener('click', showForumCategoryScreen);
    document.getElementById('back-from-category-management').addEventListener('click', showDiscoverScreen);
    document.getElementById('add-category-btn').addEventListener('click', () => openCategoryModal());
    document.getElementById('close-category-modal').addEventListener('click', () => {
        document.getElementById('add-category-modal').style.display = 'none';
    });
    document.getElementById('save-category-btn').addEventListener('click', saveForumCategory);

    // (事件委托) 处理板块列表中的编辑和删除
    document.getElementById('category-list').addEventListener('click', (e) => {
        const editBtn = e.target.closest('.edit-category-btn');
        if (editBtn) {
            const categoryId = editBtn.closest('.preset-item').dataset.categoryId;
            const category = state.forumCategories.find(c => c.id === categoryId);
            if (category) openCategoryModal(category);
            return;
        }

        const deleteBtn = e.target.closest('.delete-category-btn');
        if (deleteBtn) {
            const categoryId = deleteBtn.closest('.preset-item').dataset.categoryId;
            deleteForumCategory(categoryId);
            return;
        }
    });

// ▲▲▲ 粘贴到这里结束 ▲▲▲
// --- 新增：聊天搜索相关事件绑定 ---
    
    // 1. 点击顶栏的搜索图标 -> 打开搜索界面
    const searchChatBtn = document.getElementById('search-chat-btn');
    if (searchChatBtn) {
        searchChatBtn.addEventListener('click', showChatSearch);
    }

    // 2. 点击搜索界面里的“取消”按钮 -> 关闭搜索界面
    document.getElementById('close-search-btn').addEventListener('click', hideChatSearch);

    // 3. 监听搜索输入框的输入事件 -> 实时搜索
    const searchInput = document.getElementById('chat-search-input');
    const clearSearchBtn = document.getElementById('clear-search-btn');
    
    searchInput.addEventListener('input', (e) => {
        const keyword = e.target.value;
        // 控制清除按钮的显示/隐藏
        clearSearchBtn.style.display = keyword ? 'block' : 'none';
        // 执行搜索
        performChatSearch(keyword);
    });

    // 4. 点击清除按钮 -> 清空输入框和结果
    clearSearchBtn.addEventListener('click', () => {
        searchInput.value = '';
        clearSearchBtn.style.display = 'none';
        performChatSearch(''); // 清空结果列表
        searchInput.focus();   // 重新聚焦输入框
    });

// ==========================================================

// 1. 为“发现”页面的“档案馆”入口按钮绑定事件
document.getElementById('forum-archives-btn').addEventListener('click', async (e) => {
    e.preventDefault();
    await showForumArchivesScreen(); // 点击后打开档案馆页面
});

// 2. 为档案馆页面的“返回”按钮绑定独立的事件
document.getElementById('back-from-forum-archives').addEventListener('click', async (e) => {
    e.preventDefault();
    await showDiscoverScreen(); // 点击后返回“发现”页面
});

// 3. 使用事件委托，统一处理档案馆列表内部的所有点击操作
document.getElementById('forum-archives-list').addEventListener('click', async (e) => {
    e.preventDefault(); // 阻止默认行为

    // 检查点击的是否是“切换”按钮
    const switchBtn = e.target.closest('.switch-archive-btn');
    if (switchBtn) {
        const archiveItem = switchBtn.closest('.preset-item');
        if (archiveItem) {
            const archiveId = archiveItem.dataset.archiveId;
            // 调用我们重写过的、具备“设置恢复”功能的核心函数
            await switchForumArchive(archiveId); 
        }
        return; // 处理完后结束，避免冲突
    }

    // 检查点击的是否是“删除”按钮
    const deleteBtn = e.target.closest('.delete-archive-btn');
    if (deleteBtn) {
        const archiveItem = deleteBtn.closest('.preset-item');
        if (archiveItem) {
            const archiveId = archiveItem.dataset.archiveId;
            // 调用删除函数
            await deleteForumArchive(archiveId);
        }
    }
});
// ==========================================================
// =========== ▲▲▲ 论坛档案馆 - 最终修正版事件监听 END ▲▲▲ ======
// --- 把这段新代码，粘贴到 attachEventListeners 函数里 ---

// 使用事件委托，统一处理“思维预设”列表中的所有点击
document.getElementById('thought-presets-list').addEventListener('click', (event) => {
    // 检查被点击的元素是不是“编辑按钮”
    const editButton = event.target.closest('.edit-thought-preset-btn');
    if (editButton) {
        editThoughtPreset(event);
        return; 
    }

    // 检查被点击的元素是不是“删除按钮”
    const deleteButton = event.target.closest('.delete-thought-preset-btn');
    if (deleteButton) {
        deleteThoughtPreset(event);
    }
});
// ▼▼▼ 把下面这些代码，粘贴到 attachEventListeners 函数的【内部】任何位置 ▼▼▼

    // --- 自动回复功能的事件连接 ---
    document.getElementById('automation-btn').addEventListener('click', showAutomationScreen);
    document.getElementById('back-from-automation').addEventListener('click', showDiscoverScreen);
    document.getElementById('save-automation-settings-btn').addEventListener('click', saveAutomationSettings);

    // 启动一个每秒更新一次倒计时的迷你定时器
    setInterval(updateAutomationStatusIndicator, 1000);

// ▲▲▲ 粘贴到这里结束 ▲▲▲
// ==========================================================
// ▼▼▼ 把这段新代码完整地粘贴到 attachEventListeners 函数里 ▼▼▼

// --- 使用事件委托，统一处理“用户面具预设”列表中的所有点击 ---
document.getElementById('user-persona-presets-list').addEventListener('click', (event) => {
    // 检查被点击的元素是不是“编辑按钮”
    const editButton = event.target.closest('.edit-preset-btn');
    if (editButton) {
        // 如果是，就调用编辑函数
        editUserPersonaPreset(event);
        return; // 结束处理
    }

    // 检查被点击的元素是不是“删除按钮”
    const deleteButton = event.target.closest('.delete-preset-btn');
    if (deleteButton) {
        // 如果是，就调用我们之前修改好的删除函数
        deleteUserPersonaPreset(event);
    }
});

// ▲▲▲ 新代码粘贴到这里结束 ▲▲▲
// ==========================================================
// =========== ▼▼▼ 地图功能 - 事件绑定（缺失部分） ▼▼▼ ========
// ==========================================================
// 地图管理页的按钮
document.getElementById('back-from-map-management').addEventListener('click', showDiscoverScreen);
document.getElementById('create-new-map-btn').addEventListener('click', () => openMapDetailsModal());

// 地图详情弹窗的按钮 (创建/编辑地图本身)
document.getElementById('close-map-details-modal').addEventListener('click', () => {
    document.getElementById('map-details-modal').style.display = 'none';
});
document.getElementById('save-map-details-btn').addEventListener('click', async () => {
    const mapName = document.getElementById('map-name-input').value.trim();
    if (!mapName) {
        alert('请输入地图名称！');
        return;
    }
    const mapDescription = document.getElementById('map-description-input').value.trim();
    
    if (editingMapId) {
        // 编辑现有地图
        const map = await kokoMemory.get('maps', editingMapId);
        if (map) {
            map.name = mapName;
            map.description = mapDescription;
            await kokoMemory.put('maps', map);
        }
    } else {
        // 创建新地图
        const newMap = {
            id: 'map_' + Date.now(),
            name: mapName,
            description: mapDescription,
            locations: []
        };
        await kokoMemory.put('maps', newMap);
    }
    document.getElementById('map-details-modal').style.display = 'none';
    await renderMapList(); // 刷新列表
});

// 地图编辑器页面的按钮
document.getElementById('back-from-map-screen').addEventListener('click', showMapManagementScreen);
document.getElementById('add-map-location-btn').addEventListener('click', () => {
    // 默认在地图中心添加一个点
    openLocationModal({ isEditing: false, x: 500, y: 500 });
});

// 地图网格区域的点击事件 (添加/编辑地点)
document.getElementById('map-grid-container').addEventListener('click', (e) => {
    const icon = e.target.closest('.map-icon');
    if (icon) {
        // 如果点击的是一个已存在的图标，则进入编辑模式
        const locationId = icon.dataset.locationId;
        const location = currentMapData.locations.find(loc => loc.id === locationId);
        if (location) {
            openLocationModal({ isEditing: true, location: location });
        }
    } else {
        // 如果点击的是地图空白处，则进入添加模式
        const rect = e.currentTarget.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        openLocationModal({ isEditing: false, x: x, y: y });
    }
});

// 地点信息弹窗的按钮
document.getElementById('close-map-location-modal').addEventListener('click', () => {
    document.getElementById('map-location-modal').style.display = 'none';
});
document.getElementById('delete-map-location-btn').addEventListener('click', async () => {
    if (editingLocationId) {
        currentMapData.locations = currentMapData.locations.filter(loc => loc.id !== editingLocationId);
        await kokoMemory.put('maps', currentMapData);
        renderMapIcons();
        document.getElementById('map-location-modal').style.display = 'none';
    }
});
// 保存地点按钮（修改版：默认 Tier 2）
document.getElementById('save-map-location-btn').addEventListener('click', async () => {
    const name = document.getElementById('location-name-input').value.trim();
    if (!name) {
        alert('请输入地点名称！');
        return;
    }
    
    // 1. 构建基础数据
    const locationData = {
        name: name,
        icon: document.getElementById('location-icon-input').value.trim(),
        description: document.getElementById('location-description-input').value.trim(),
        x: parseInt(document.getElementById('location-x-input').value),
        y: parseInt(document.getElementById('location-y-input').value),
        // ▼▼▼ 修改：不再从输入框读取，而是默认设为 2 (普通大小) ▼▼▼
        tier: 2, 
        parentId: currentMapParentId 
    };

    if (editingLocationId) {
        const index = currentMapData.locations.findIndex(loc => loc.id === editingLocationId);
        if (index > -1) {
            // 编辑时，保留原有的 parentId
            const oldParentId = currentMapData.locations[index].parentId || null;
            currentMapData.locations[index] = { 
                ...currentMapData.locations[index], 
                ...locationData, 
                parentId: oldParentId 
            };
        }
    } else {
        if (!currentMapData.locations) {
            currentMapData.locations = [];
        }
        currentMapData.locations.push({
            id: 'loc_' + Date.now(),
            ...locationData
        });
    }
    
    await kokoMemory.put('maps', currentMapData);
    renderMapIcons();
    document.getElementById('map-location-modal').style.display = 'none';
});

// 地图管理列表的事件委托 (处理编辑和删除)
document.getElementById('map-list').addEventListener('click', async (e) => {
    const mapItem = e.target.closest('.preset-item');
    if (!mapItem) return;

    const mapId = mapItem.dataset.mapId;
    const map = await kokoMemory.get('maps', mapId);

    if (e.target.closest('.edit-map-btn')) {
        // 点击了编辑按钮
        openMapDetailsModal(map);
    } else if (e.target.closest('.delete-map-btn')) {
        // 点击了删除按钮
        const confirmed = await showCustomConfirm('删除地图', `确定要永久删除地图“${map.name}”及其所有地点吗？`, true);
        if (confirmed) {
            await kokoMemory.delete('maps', mapId);
            await renderMapList();
        }
    }
});
// ==========================================================
// ▼▼▼ 把这段新代码粘贴到 attachEventListeners 函数的内部 ▼▼▼

const chatContactNameEl = document.getElementById('chat-contact-name');
const heartVoicePanel = document.getElementById('heart-voice-panel');

chatContactNameEl.addEventListener('click', (e) => {
    e.stopPropagation(); // 阻止事件冒泡

    // 如果面板已经是显示的，就隐藏它
    if (heartVoicePanel.style.display === 'block') {
        heartVoicePanel.style.display = 'none';
        return;
    }
    
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact || !contact.history) return;

    // 从后往前查找最新的一条心声消息
    const lastHeartVoice = contact.history.slice().reverse().find(m => m.type === 'heart_voice');

    if (lastHeartVoice) {
        const data = lastHeartVoice.content;
        document.getElementById('hv-emotion').textContent = data.emotion || '...';
        document.getElementById('hv-thoughts').textContent = data.thoughts || '...';
        document.getElementById('hv-heart-rate').textContent = data.heartRate || '...';
        document.getElementById('hv-jealousy').textContent = data.jealousy || '无';
        
        // 显示面板
        heartVoicePanel.style.display = 'block';
    } else {
        // 如果没有找到心声记录，可以给个提示
        alert('还没有任何心声记录哦。');
    }
});

// 点击心声面板本身不会关闭它
heartVoicePanel.addEventListener('click', e => e.stopPropagation());

// 点击页面其他地方，关闭心声面板
document.addEventListener('click', (e) => {
    if (heartVoicePanel.style.display === 'block') {
        heartVoicePanel.style.display = 'none';
    }
});
// ▲▲▲ 粘贴到这里结束 ▲▲▲
// =========== ▲▲▲ 地图功能 - 事件绑定（缺失部分） END ▲▲▲ ========
// (粘贴到 attachEventListeners 函数内部)

// --- ✨ 新增：收藏夹事件绑定 ---

// 1. 发现页的"我的收藏"入口
document.getElementById('discover-screen').addEventListener('click', (e) => {
    if (e.target.closest('#favorites-btn')) {
        showFavoritesScreen();
    }
});

// 2. 收藏夹页面的"返回"按钮
document.getElementById('back-from-favorites').addEventListener('click', showDiscoverScreen);

// 3. 聊天编辑栏的"收藏已选"按钮
document.getElementById('favorite-selected-btn').addEventListener('click', favoriteSelectedMessages);
document.getElementById('forward-selected-btn').addEventListener('click', openForwardChatModal);
// 4. 收藏夹内部的"取消收藏"按钮 (V2 - 事件委托)
    document.getElementById('favorites-content-list').addEventListener('click', (e) => {
        // ✨ 核心修改：现在监听的是卡片头部的 .unfavorite-btn
        const unfavBtn = e.target.closest('.unfavorite-btn');
        if (unfavBtn) {
            e.stopPropagation();
            const sessionId = unfavBtn.dataset.sessionId; // ✨ 获取 session ID
            if (sessionId) {
                unfavoriteSession(sessionId); // ✨ 调用新的删除函数
            }
        }
    });
// --- ✨ 收藏夹事件绑定 结束 ---
// ==========================================================
// ... 在 attachEventListeners 函数中 ...

// 随便找个地方加上这行代码
document.getElementById('map-management-btn').addEventListener('click', showMapManagementScreen);
    // =========================================================
// --- 新增：日记批量删除功能的事件绑定 ---

// 右上角的“编辑”按钮
document.getElementById('edit-diary-btn').addEventListener('click', enterDiaryEditMode);

// 底部操作栏的“取消”按钮
document.getElementById('cancel-diary-edit-btn').addEventListener('click', exitDiaryEditMode);

// 底部操作栏的“删除已选”按钮
document.getElementById('delete-selected-diary-btn').addEventListener('click', async () => {
    if (diaryEditModeState.selectedEntryIds.size === 0) {
        return alert('请先选择要删除的日记。');
    }
    const confirmed = await showCustomConfirm('删除日记', `确定要删除选中的 ${diaryEditModeState.selectedEntryIds.size} 篇日记吗？`, true);
    if (confirmed) {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (contact && contact.diary) {
            // 核心：过滤掉所有被选中的日记
            contact.diary = contact.diary.filter(entry => !diaryEditModeState.selectedEntryIds.has(entry.id));
            await kokoMemory.put('contacts', contact);
            exitDiaryEditMode(); // 退出编辑模式并刷新列表
        }
    }
});

// 修改日记列表的点击事件，让它能处理编辑模式下的选择
const diaryContentList = document.getElementById('diary-content-list');
const oldListener = diaryContentList.onclick; // 保存旧的监听器
diaryContentList.onclick = null; // 移除旧的

diaryContentList.addEventListener('click', async (e) => {
    // 如果是编辑模式...
    if (diaryEditModeState.active) {
        const entryEl = e.target.closest('.diary-entry');
        if (entryEl) {
            const checkbox = entryEl.querySelector('.diary-select-checkbox');
            if (!checkbox) return;

            // 核心：如果点击的不是复选框本身，就手动帮它切换选中状态
            if (e.target !== checkbox) {
                checkbox.checked = !checkbox.checked;
            }

            const diaryId = checkbox.dataset.diaryId;
            if (checkbox.checked) {
                diaryEditModeState.selectedEntryIds.add(diaryId);
                entryEl.classList.add('selected');
            } else {
                diaryEditModeState.selectedEntryIds.delete(diaryId);
                entryEl.classList.remove('selected');
            }
        }
        return; // 编辑模式下，不执行后面的单个删除逻辑
    }

    // 如果不是编辑模式，就执行原来的单个删除逻辑
    if (oldListener) {
        oldListener.call(diaryContentList, e);
    }
});
// ==========================================================
// --- 音乐搜索按钮事件 ---
document.getElementById('music-search-btn-modal').addEventListener('click', () => {
    const keyword = document.getElementById('music-search-keyword-modal').value.trim();
    if (keyword) searchMusicInModal(keyword);
});
// 让回车键也能搜索
document.getElementById('music-search-keyword-modal').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        const keyword = e.target.value.trim();
        if (keyword) searchMusicInModal(keyword);
    }
});
// V-Final 新增: 锁屏音乐播放器控制逻辑
// ==========================================================
const lockScreenMusicControls = document.querySelector('#lock-screen-music-widget .music-controls');
if (lockScreenMusicControls) {
    lockScreenMusicControls.addEventListener('click', (e) => {
        // 阻止事件冒泡，防止点击按钮时解锁屏幕
        e.stopPropagation();

        if (e.target.classList.contains('fa-play')) {
            if (globalAudioPlayer.src) {
                globalAudioPlayer.play();
            }
        } else if (e.target.classList.contains('fa-pause')) {
            globalAudioPlayer.pause();
        } else if (e.target.classList.contains('fa-forward-step')) {
            // 调用我们已有的下一首函数
            switchSong(currentSongIndex + 1, true, true);
        } else if (e.target.classList.contains('fa-backward-step')) {
            // 调用我们已有的上一首函数
            switchSong(currentSongIndex - 1, true, true);
        }
    });
}
// ==========================================================
// --- 主题导入导出事件 ---
document.getElementById('export-theme-btn').addEventListener('click', exportTheme);

document.getElementById('import-theme-btn').addEventListener('click', () => {
    // 点击按钮时，触发隐藏的文件输入框
    document.getElementById('theme-file-input').click();
});

// 监听文件选择变化
document.getElementById('theme-file-input').addEventListener('change', importTheme);
// 最终修复版 V2：宠物互动逻辑 (拖动 + 点击)，兼容所有浏览器
// ==========================================================
const petContainer = document.getElementById('chat-pet-container');

if (petContainer) {
    // --- 拖动与点击判断逻辑 ---
    let isPetDragging = false;
    let petOffsetX = 0, petOffsetY = 0;
    
    // ▼▼▼ 新增变量，用于判断是否为点击 ▼▼▼
    let dragStartX = 0, dragStartY = 0;
    let hasMoved = false; 
    const dragThreshold = 5; // 移动超过5像素才算拖动

    function petDragStart(e) {
        isPetDragging = true;
        hasMoved = false; // 每次开始时，重置为“未移动”
        petContainer.style.transition = 'none';
        
        const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
        
        // 记录拖动起始点
        dragStartX = clientX;
        dragStartY = clientY;

        petOffsetX = clientX - petContainer.offsetLeft;
        petOffsetY = clientY - petContainer.offsetTop;

        // 注意：在触摸设备上，preventDefault 仍然是必要的，以防止页面滚动
        if (e.type === 'touchmove') {
            e.preventDefault();
        }
    }

    function petDragMove(e) {
        if (!isPetDragging) return;
        
        const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
        
        // ▼▼▼ 核心判断：检查移动距离 ▼▼▼
        const deltaX = Math.abs(clientX - dragStartX);
        const deltaY = Math.abs(clientY - dragStartY);
        if (deltaX > dragThreshold || deltaY > dragThreshold) {
            hasMoved = true; // 只要移动超过阈值，就标记为已移动
        }
        
        // 只有在确定是拖动时才移动位置
        if (hasMoved) {
            let newX = clientX - petOffsetX;
            let newY = clientY - petOffsetY;
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const petWidth = petContainer.offsetWidth;
            const petHeight = petContainer.offsetHeight;
            newX = Math.max(0, Math.min(newX, screenWidth - petWidth));
            newY = Math.max(0, Math.min(newY, screenHeight - petHeight));
            petContainer.style.left = `${newX}px`;
            petContainer.style.top = `${newY}px`;
            petContainer.style.bottom = 'auto';
        }

        if (e.type === 'touchmove') {
            e.preventDefault();
        }
    }

    function petDragEnd(e) {
        if (!isPetDragging) return;
        isPetDragging = false;
        
        // ▼▼▼ 核心逻辑：在拖动结束时判断 ▼▼▼
        if (!hasMoved) {
            // 如果从按下到松开，基本没移动过，就执行点击函数！
            petClickInteraction(e);
        }
    }

    function petClickInteraction(e) {
        const sound = document.getElementById('slime-sound');
        if (sound) {
            sound.currentTime = 0;
            sound.play();
        }

        const slimeEl = petContainer.querySelector('.slime');
        if (!slimeEl) return;

        slimeEl.classList.add('happy-jiggle');
        setTimeout(() => {
            slimeEl.classList.remove('happy-jiggle');
        }, 500);

        const allExpressions = ['expression-happy', 'expression-sad', 'expression-annoyed', 'expression-shocked', 'expression-pleased', 'expression-dizzy', 'expression-doubtful', 'expression-cat-face'];
        let currentExpression = '';
        
        for(const exp of allExpressions) {
            if (slimeEl.classList.contains(exp)) {
                currentExpression = exp;
                break;
            }
        }
        
        const nextPossibleExpressions = allExpressions.filter(exp => exp !== currentExpression);
        const randomExpression = nextPossibleExpressions[Math.floor(Math.random() * nextPossibleExpressions.length)];

        setTimeout(() => {
            allExpressions.forEach(exp => slimeEl.classList.remove(exp));
            if (randomExpression) {
                slimeEl.classList.add(randomExpression);
            }
        }, 100);
    }

    // --- 统一绑定所有事件 ---
    petContainer.addEventListener('mousedown', petDragStart);
    petContainer.addEventListener('touchstart', petDragStart, { passive: false });

    // ▲▲▲ 最重要的改动：删除了下面这行有问题的代码 ▲▲▲
    // petContainer.addEventListener('click', petClickInteraction); 

    document.addEventListener('mousemove', petDragMove);
    document.addEventListener('mouseup', petDragEnd);
    document.addEventListener('touchmove', petDragMove, { passive: false });
    document.addEventListener('touchend', petDragEnd);
}
// ▼▼▼ 把这段全新的代码粘贴到 attachEventListeners 函数里 ▼▼▼

// ▼▼▼ ✨ 使用这个【正确版本】替换 ✨ ▼▼▼
    document.querySelector('.contacts-container').addEventListener('click', async function(e) {
        const optionsBtn = e.target.closest('.contact-options-btn');
        if (optionsBtn) {
            e.stopPropagation();
            const contactId = optionsBtn.dataset.contactId;
            showContactItemMenu(contactId, optionsBtn);
            return;
        }
        
        const contactItem = e.target.closest('.contact-item');
        if (contactItem) {
            // 无论什么状态，都只管打开聊天界面
            openChat(contactItem.dataset.contactId);
        }
    });
    // ▲▲▲ 替换结束 ▲▲▲

// 第2个：这是全新的，监听菜单项的点击
document.getElementById('contact-item-menu').addEventListener('click', async (e) => {
    const menuItem = e.target.closest('.menu-item');
    if (!menuItem) return;
    const contactId = document.getElementById('contact-item-menu').dataset.contactId;
    if (!contactId) return;

    switch (menuItem.id) {
        case 'menu-item-pin':
            await togglePinContact(contactId);
            break;
       case 'menu-item-group':
            // ▼▼▼ 核心修改 ▼▼▼
            showGroupSelectorModal(contactId); // 去掉 alert，调用真正的函数
            // ▲▲▲ 修改结束 ▲▲▲
            break;
        case 'menu-item-rewind':
            await handleLongPressDelete(contactId); 
            break;
    }
    document.getElementById('contact-item-menu').style.display = 'none';
});
// --- 新增：为联系人列表的“更多操作”菜单添加点击外部关闭的功能 ---
const contactItemMenu = document.getElementById('contact-item-menu');

// 1. 点击菜单内部时，阻止事件冒泡，防止菜单自己关闭自己
contactItemMenu.addEventListener('click', function(event) {
    event.stopPropagation();
});

// 2. 在整个页面上添加点击事件监听
document.addEventListener('click', function(event) {
    // 检查被点击的元素是不是打开菜单的那个“三个点”按钮
    const isOptionsButton = event.target.closest('.contact-options-btn');
    
    // 如果点击的既不是按钮，也不是菜单本身，就隐藏菜单
    if (!isOptionsButton && contactItemMenu.style.display === 'block') {
        contactItemMenu.style.display = 'none';
    }
});
// --- 新增：控制顶栏“更多操作”菜单的显示与隐藏 ---
const moreOptionsBtn = document.getElementById('more-chat-options-btn');
const chatOptionsMenu = document.getElementById('chat-options-menu');

if (moreOptionsBtn) {
    moreOptionsBtn.addEventListener('click', function(event) {
        event.stopPropagation();
        // ▼▼▼ ✨ 在这里粘贴新代码 ✨ ▼▼▼
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if(contact) {
            updateBlockButtonText(contact.blockedStatus); // 根据当前状态更新按钮
        }
        // ▲▲▲ 粘贴结束 ▲▲▲
        const isShown = chatOptionsMenu.style.display === 'block';
        chatOptionsMenu.style.display = isShown ? 'none' : 'block';
    });

    chatOptionsMenu.addEventListener('click', function(event) {
        event.stopPropagation();
    });

    // --- 重新绑定事件到新菜单项 ---
    document.getElementById('rewind-btn-menu').addEventListener('click', handleRewind);
    document.getElementById('summarize-chat-btn-menu').addEventListener('click', handleChatSummarization);
    document.getElementById('contact-settings-btn-menu').addEventListener('click', showCharProfileScreen);
    
    document.getElementById('toggle-chat-pet-btn-menu').addEventListener('click', () => {
        // 这是原先 toggle-chat-pet-btn 的逻辑
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact || !contact.pet) return;
        contact.isChatPetVisible = !contact.isChatPetVisible;
        const chatPetContainer = document.getElementById('chat-pet-container');
        if (contact.isChatPetVisible) {
            chatPetContainer.style.display = 'block';
            updateChatPetVisuals(contact);
        } else {
            chatPetContainer.style.display = 'none';
        }
        kokoMemory.put('contacts', contact);
        chatOptionsMenu.style.display = 'none'; // 点击后关闭菜单
    });

    document.getElementById('delete-history-btn-menu').addEventListener('click', () => {
        // 这是原先 delete-history-btn 的逻辑
        if (editModeState.active) {
            exitEditMode();
        } else {
            enterEditMode();
        }
        chatOptionsMenu.style.display = 'none'; // 点击后关闭菜单
    });
}
// 点击页面其他任何地方，都隐藏菜单
document.addEventListener('click', function(event) {
    // 确保点击的不是按钮本身
    if (moreOptionsBtn && !moreOptionsBtn.contains(event.target)) {
        chatOptionsMenu.style.display = 'none';
    }
});
// ▼▼▼ ✨ 使用这个【正确版本】替换 ✨ ▼▼▼
    document.getElementById('block-contact-btn-menu').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;

        if (contact.blockedStatus === 'user_blocked_ai') {
            // --- 解除拉黑 ---
            contact.blockedStatus = 'none';
            await kokoMemory.put('contacts', contact);
            alert(`你已将 ${contact.name} 解除拉黑。`);
            
            updateBlockButtonText('none');      // 1. 更新按钮文字
            updateChatInputLockState('none'); // 2. ✨ 立刻解锁输入框

        } else {
            // --- 执行拉黑 ---
            contact.blockedStatus = 'user_blocked_ai';
            await kokoMemory.put('contacts', contact);
            alert(`你已拉黑 ${contact.name}。`);
            
            updateBlockButtonText('user_blocked_ai');      // 1. 更新按钮文字
            updateChatInputLockState('user_blocked_ai'); // 2. ✨ 立刻锁定输入框
            // 3. ⚠️ 删掉了 openSmsChat(contact.id); 这一行
        }
        
        document.getElementById('chat-options-menu').style.display = 'none';
    });
    // ▲▲▲ 替换结束 ▲▲▲
// --- ▼▼▼ 新增：视频通话界面的事件绑定 ▼▼▼ ---
document.getElementById('hang-up-btn').addEventListener('click', () => {
    endVideoCall('user');
});

document.getElementById('video-call-send-btn').addEventListener('click', sendVideoCallMessage);

document.getElementById('video-call-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendVideoCallMessage();
    }
});
// ... 在 attachEventListeners() 函数内部 ...
// 【新增】处理预设下拉菜单的选择事件
    document.getElementById('api-preset-select').addEventListener('change', (e) => {
        const presetId = e.target.value;
        const preset = state.apiPresets.find(p => p.id === presetId);
        if (preset) {
            document.getElementById('api-key-input').value = preset.apiKey || '';
            document.getElementById('api-endpoint-input').value = preset.endpoint || '';
            updateModelDropdown([preset.model], document.getElementById('model-select'), preset.model);
            
            const fetchBtn = document.getElementById('fetch-models-btn');
            if (fetchBtn) fetchBtn.click();
        }
    });

    // 【新增】处理“另存为预设”按钮点击事件
    document.getElementById('save-as-api-preset-btn').addEventListener('click', async () => {
        const apiKey = document.getElementById('api-key-input').value;
        const endpoint = document.getElementById('api-endpoint-input').value.trim();
        const model = document.getElementById('model-select').value;

        if (!apiKey || !endpoint || !model) {
            return alert('请先将API密钥、地址和模型填写完整再保存为预设。');
        }

        const presetName = await showCustomPrompt('为这个预设取个名字', '');
        if (presetName && presetName.trim()) {
            const newPreset = {
                id: 'api_preset_' + Date.now(),
                name: presetName.trim(),
                apiKey,
                endpoint,
                model
            };

            state.apiPresets.push(newPreset);
            await kokoMemory.put('apiPresets', newPreset);
            await renderApiPresetDropdown(); // 更新下拉菜单
            alert(`预设“${newPreset.name}”已保存！`);
        }
    });

    // 【新增】处理“管理预设”按钮和其页面的返回按钮
    document.getElementById('manage-api-presets-btn').addEventListener('click', showApiPresetManagementScreen);
    document.getElementById('back-from-api-presets').addEventListener('click', () => {
        // 返回时，重新打开API设置页面并刷新下拉菜单
        document.getElementById('api-settings-btn').click();
    });
// (粘贴到 attachEventListeners 函数的末尾)

// --- ✨ 新增：外观设置的实时预览监听器 ---

// CSS 主题
document.getElementById('theme-css-input').addEventListener('input', (e) => {
    updatePreview('theme', e.target.value);
});

// CSS 气泡
document.getElementById('bubble-css-input').addEventListener('input', (e) => {
    updatePreview('bubble', e.target.value);
});

// CSS 叙事
document.getElementById('narrative-css-input').addEventListener('input', (e) => {
    updatePreview('narrative', e.target.value);
});

// 字体大小
document.getElementById('font-size-input').addEventListener('input', (e) => {
    updatePreview('fontsize', e.target.value);
});

// 字体 URL 和 字体名称 (两者任一变动都触发更新)
const updateFontPreview = () => {
    const fontName = document.getElementById('font-name-input').value.trim();
    const fontUrl = document.getElementById('font-url-input').value.trim();
    updatePreview('font', fontName, fontUrl);
};
document.getElementById('font-url-input').addEventListener('input', updateFontPreview);
document.getElementById('font-name-input').addEventListener('input', updateFontPreview);

// --- ✨ 监听器添加结束 ---
// --- 外观设置页面的事件绑定 (V2 - 带预览版) ---
document.getElementById('appearance-settings-btn').addEventListener('click', () => {
    // 打开设置页面前，先用已保存的设置填充输入框
    document.getElementById('bubble-css-input').value = userSettings.customBubbleCss || '';
    document.getElementById('theme-css-input').value = userSettings.customThemeCss || '';
    document.getElementById('narrative-css-input').value = userSettings.customNarrativeCss || '';
    document.getElementById('font-size-input').value = userSettings.customFontSize || '';
    document.getElementById('font-url-input').value = userSettings.customFontUrl || '';
    document.getElementById('font-name-input').value = userSettings.customFontName || '';
    
    hideAllScreens();
    document.getElementById('appearance-settings-screen').style.display = 'flex';

    // ✨ 核心新增：初始化预览框并加载当前设置
    initializePreviewFrame();
    // 确保DOM渲染完成后再加载内容
    setTimeout(loadPreviewFromInputs, 50); 
});

document.getElementById('back-from-appearance-settings').addEventListener('click', showProfileScreen);

// 背景上传按钮
document.getElementById('upload-background-btn').addEventListener('click', () => {
    document.getElementById('background-file-input').click();
});

// 背景文件选择后的处理
document.getElementById('background-file-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;

    if (file.size > 5 * 1024 * 1024) { // 限制5MB大小
        alert('图片文件不能超过 5MB');
        return;
    }

    const reader = new FileReader();
    reader.onload = (event) => {
        const base64String = event.target.result;
        userSettings.chatBackground = base64String; // 实时保存到变量
        document.getElementById('chat-screen').style.backgroundImage = `url(${base64String})`;
        updatePreview('background', base64String);
        alert('背景已更新，点击“应用并保存”来永久保存。');
    };
    reader.readAsDataURL(file);
    e.target.value = ''; // 清空input，以便可以再次选择同一个文件
});

// 恢复默认背景按钮
document.getElementById('reset-background-btn').addEventListener('click', () => {
    userSettings.chatBackground = null;
    applyAppearanceSettings(); // 立即应用默认样式
    updatePreview('background', '');
    alert('背景已恢复默认，点击“应用并保存”来永久保存。');
});
attachGroupSettingsListeners();
// 保存外观设置按钮
document.getElementById('save-appearance-btn').addEventListener('click', saveAppearanceSettings);
}
attachEventListeners();
// --- 紧急修复：重新绑定搜索按钮 ---
    const searchBtnFix = document.getElementById('search-chat-btn');
    if (searchBtnFix) {
        // 先移除可能存在的旧监听器（以防万一）
        const newSearchBtn = searchBtnFix.cloneNode(true);
        searchBtnFix.parentNode.replaceChild(newSearchBtn, searchBtnFix);
        // 重新绑定
        newSearchBtn.addEventListener('click', showChatSearch);
        console.log("已手动修复搜索按钮连接！");
    }
    // =========================================
    // 🚑 搜索按钮紧急修复补丁 (手机专享版) 🚑
    // =========================================
    setTimeout(() => { // 延迟一点点执行，确保按钮肯定已经生出来了
        const fixSearchBtn = document.getElementById('search-chat-btn');
        if (fixSearchBtn) {
            // 1. 用“克隆大法”清除所有可能坏掉的旧连接
            const freshBtn = fixSearchBtn.cloneNode(true);
            fixSearchBtn.parentNode.replaceChild(freshBtn, fixSearchBtn);

            // 2. 重新接上正确的功能线
            freshBtn.addEventListener('click', (e) => {
                // 阻止任何可能的干扰
                e.stopPropagation();
                e.preventDefault();

                // 🔔 如果你想确认按钮是否真的被点到了，可以把下面这行最前面的 // 删掉
                // alert("按钮活啦！正在打开搜索...");

                // 调用搜索界面
                if (typeof showChatSearch === 'function') {
                    showChatSearch();
                } else {
                    alert("糟糕！showChatSearch 功能函数不见了！");
                }
            });

            console.log("✅ 搜索按钮已实施紧急修复！");
        } else {
            console.error("❌ 居然找不到搜索按钮，它可能被别的代码误删了！");
        }
    }, 1000); // 等待1秒再执行，非常保险
    // =========================================
await initApp();
}); 
</script>
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js')
        .then(registration => console.log('ServiceWorker 注册成功: ', registration))
        .catch(error => console.log('ServiceWorker 注册失败: ', error));
    });
  }
</script>


</div></body></html>